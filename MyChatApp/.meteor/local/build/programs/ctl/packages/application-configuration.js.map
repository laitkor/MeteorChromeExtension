{"version":3,"file":"\\packages\\application-configuration.js","sources":["application-configuration/config.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,0C;;AAEA,e;;;AAGA,2C;AACA,+E;AACA,gB;AACA,G;AACA,qF;AACA,G;;AAEA,mC;;AAEA,6B;AACA,iC;AACA,Y;AACA,0E;AACA,8E;AACA,C;;AAEA,S;AACA,S;AACA,a;AACA,oC;;AAEA,4B;AACA,c;AACA,0C;AACA,uB;AACA,O;AACA,0C;AACA,uB;AACA,O;AACA,kD;AACA,uB;AACA,O;AACA,uD;AACA,8B;AACA,G;AACA,G;;AAEA,+E;AACA,U;AACA,2C;AACA,0B;AACA,c;AACA,E;;AAEA,4C;AACA,0B;AACA,c;AACA,E;;;AAGA,oB;;AAEA,K;AACA,+B;AACA,yD;AACA,U;AACA,iB;AACA,S;AACA,wC;AACA,2D;AACA,O;AACA,iB;AACA,0D;AACA,K;AACA,uB;AACA,yB;AACA,iB;AACA,2B;AACA,qC;AACA,4C;AACA,S;AACA,O;AACA,M;AACA,G;AACA,a;AACA,sE;AACA,E;;AAEA,sC;AACA,mD;AACA,2B;AACA,G;AACA,mB;AACA,mD;AACA,e;AACA,2D;AACA,G;AACA,4B;AACA,gB;AACA,E;;AAEA,2C;AACA,c;AACA,yB;AACA,mD;AACA,c;AACA,sB;AACA,K;AACA,G;AACA,c;AACA,E;;AAEA,gE;AACA,mF;AACA,0E;AACA,kB;AACA,2C;AACA,gD;;AAEA,gF;AACA,2D;AACA,+E;AACA,8C;AACA,wB;AACA,6C;AACA,sB;AACA,iF;AACA,yB;AACA,oD;AACA,4B;AACA,K;AACA,I;AACA,gB;AACA,8B;;AAEA,6E;AACA,U;AACA,6B;AACA,6E;AACA,6C;AACA,4B;AACA,2D;AACA,kC;AACA,mC;AACA,O;AACA,sB;AACA,K;;AAEA,U;AACA,uB;AACA,sB;AACA,uB;AACA,K;AACA,I;AACA,E;;AAEA,yE;;AAEA,8E;AACA,gF;AACA,wB;AACA,sC;AACA,qC;AACA,wB;AACA,sB;AACA,O;AACA,uB;AACA,+C;AACA,iC;AACA,+D;AACA,mC;AACA,W;AACA,c;AACA,4C;AACA,O;AACA,O;AACA,yB;AACA,I;;AAEA,c;AACA,6E;AACA,6C;AACA,4B;AACA,8E;AACA,+E;AACA,0D;AACA,uD;AACA,+B;AACA,gC;AACA,yD;AACA,S;AACA,O;AACA,O;AACA,0B;AACA,wB;AACA,sB;AACA,gB;AACA,2B;AACA,6B;AACA,4B;AACA,O;AACA,G;;AAEA,E","sourcesContent":["var Future = Npm.require(\"fibers/future\");\r\n\r\nAppConfig = {};\r\n\r\n\r\nAppConfig.findGalaxy = _.once(function () {\r\n  if (!('GALAXY' in process.env || 'ULTRAWORLD_DDP_ENDPOINT' in process.env)) {\r\n    return null;\r\n  }\r\n  return Follower.connect(process.env.ULTRAWORLD_DDP_ENDPOINT || process.env.GALAXY);\r\n});\r\n\r\nvar ultra = AppConfig.findGalaxy();\r\n\r\nvar subFuture = new Future();\r\nvar subFutureJobs = new Future();\r\nif (ultra) {\r\n  ultra.subscribe(\"oneApp\", process.env.GALAXY_APP, subFuture.resolver());\r\n  ultra.subscribe(\"oneJob\", process.env.GALAXY_JOB, subFutureJobs.resolver());\r\n}\r\n\r\nvar Apps;\r\nvar Jobs;\r\nvar Services;\r\nvar collectionFuture = new Future();\r\n\r\nMeteor.startup(function () {\r\n  if (ultra) {\r\n    Apps = new Meteor.Collection(\"apps\", {\r\n      connection: ultra\r\n    });\r\n    Jobs = new Meteor.Collection(\"jobs\", {\r\n      connection: ultra\r\n    });\r\n    Services = new Meteor.Collection('services', {\r\n      connection: ultra\r\n    });\r\n    // allow us to block on the collections being ready\r\n    collectionFuture.return();\r\n  }\r\n});\r\n\r\n// XXX: Remove this once we allow the same collection to be new'd from multiple\r\n// places.\r\nAppConfig._getAppCollection = function () {\r\n  collectionFuture.wait();\r\n  return Apps;\r\n};\r\n\r\nAppConfig._getJobsCollection = function () {\r\n  collectionFuture.wait();\r\n  return Jobs;\r\n};\r\n\r\n\r\nvar staticAppConfig;\r\n\r\ntry {\r\n  if (process.env.APP_CONFIG) {\r\n    staticAppConfig = JSON.parse(process.env.APP_CONFIG);\r\n  } else {\r\n    var settings;\r\n    try {\r\n      if (process.env.METEOR_SETTINGS) {\r\n        settings = JSON.parse(process.env.METEOR_SETTINGS);\r\n      }\r\n    } catch (e) {\r\n      Log.warn(\"Could not parse METEOR_SETTINGS as JSON\");\r\n    }\r\n    staticAppConfig = {\r\n      settings: settings,\r\n      packages: {\r\n        'mongo-livedata': {\r\n          url: process.env.MONGO_URL,\r\n          oplog: process.env.MONGO_OPLOG_URL\r\n        }\r\n      }\r\n    };\r\n  }\r\n} catch (e) {\r\n  Log.warn(\"Could not parse initial APP_CONFIG environment variable\");\r\n};\r\n\r\nAppConfig.getAppConfig = function () {\r\n  if (!subFuture.isResolved() && staticAppConfig) {\r\n    return staticAppConfig;\r\n  }\r\n  subFuture.wait();\r\n  var myApp = Apps.findOne(process.env.GALAXY_APP);\r\n  if (!myApp) {\r\n    throw new Error(\"there is no app config for this app\");\r\n  }\r\n  var config = myApp.config;\r\n  return config;\r\n};\r\n\r\nAppConfig.getStarForThisJob = function () {\r\n  if (ultra) {\r\n    subFutureJobs.wait();\r\n    var job = Jobs.findOne(process.env.GALAXY_JOB);\r\n    if (job) {\r\n      return job.star;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nAppConfig.configurePackage = function (packageName, configure) {\r\n  var appConfig = AppConfig.getAppConfig(); // Will either be based in the env var,\r\n                                         // or wait for galaxy to connect.\r\n  var lastConfig =\r\n        (appConfig && appConfig.packages &&\r\n         appConfig.packages[packageName]) || {};\r\n\r\n  // Always call the configure callback \"soon\" even if the initial configuration\r\n  // is empty (synchronously, though deferred would be OK).\r\n  // XXX make sure that all callers of configurePackage deal well with multiple\r\n  // callback invocations!  eg, email does not\r\n  configure(lastConfig);\r\n  var configureIfDifferent = function (app) {\r\n    if (!EJSON.equals(\r\n           app.config && app.config.packages && app.config.packages[packageName],\r\n           lastConfig)) {\r\n      lastConfig = app.config.packages[packageName];\r\n      configure(lastConfig);\r\n    }\r\n  };\r\n  var subHandle;\r\n  var observed = new Future();\r\n\r\n  // This is not required to finish, so defer it so it doesn't block anything\r\n  // else.\r\n  Meteor.defer( function () {\r\n    // there's a Meteor.startup() that produces the various collections, make\r\n    // sure it runs first before we continue.\r\n    collectionFuture.wait();\r\n    subHandle = Apps.find(process.env.GALAXY_APP).observe({\r\n      added: configureIfDifferent,\r\n      changed: configureIfDifferent\r\n    });\r\n    observed.return();\r\n  });\r\n\r\n  return {\r\n    stop: function () {\r\n      observed.wait();\r\n      subHandle.stop();\r\n    }\r\n  };\r\n};\r\n\r\nAppConfig.configureService = function (serviceName, version, configure) {\r\n\r\n  // Collect all the endpoints for this service, from both old- and new-format\r\n  // documents, and call the `configure` callback with all the service endpoints\r\n  // that we know about.\r\n  var callConfigure = function (doc) {\r\n    var serviceDocs = Services.find({\r\n      name: serviceName,\r\n      version: version\r\n    });\r\n    var endpoints = [];\r\n    serviceDocs.forEach(function (serviceDoc) {\r\n      if (serviceDoc.providers) {\r\n        _.each(serviceDoc.providers, function (endpoint, app) {\r\n          endpoints.push(endpoint);\r\n        });\r\n      } else {\r\n        endpoints.push(serviceDoc.endpoint);\r\n      }\r\n    });\r\n    configure(endpoints);\r\n  };\r\n\r\n  if (ultra) {\r\n    // there's a Meteor.startup() that produces the various collections, make\r\n    // sure it runs first before we continue.\r\n    collectionFuture.wait();\r\n    // First try to subscribe to the new format service registrations; if that\r\n    // sub doesn't exist, then ultraworld hasn't updated to the new format yet,\r\n    // so try the old format `servicesByName` sub instead.\r\n    ultra.subscribe('services', serviceName, version, {\r\n      onError: function (err) {\r\n        if (err.error === 404) {\r\n          ultra.subscribe('servicesByName', serviceName);\r\n        }\r\n      }\r\n    });\r\n    return Services.find({\r\n      name: serviceName,\r\n      version: version\r\n    }).observe({\r\n      added: callConfigure,\r\n      changed: callConfigure,\r\n      removed: callConfigure\r\n    });\r\n  }\r\n\r\n};\r\n"]}