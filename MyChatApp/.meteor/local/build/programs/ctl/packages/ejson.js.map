{"version":3,"file":"\\packages\\ejson.js","sources":["ejson/ejson.js","ejson/stringify.js","ejson/base64.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,W;AACA,e;;AAEA,qB;AACA,iE;AACA,+D;AACA,6C;AACA,8B;AACA,4D;AACA,sE;AACA,qD;AACA,oE;AACA,6D;AACA,gB;AACA,oE;AACA,iD;AACA,E;AACA,0C;AACA,+B;AACA,yD;AACA,8B;AACA,E;;AAEA,iC;AACA,+D;AACA,E;;AAEA,yB;AACA,W;AACA,oC;AACA,sD;AACA,M;AACA,iC;AACA,iC;AACA,M;AACA,iC;AACA,oC;AACA,M;AACA,mC;AACA,iC;AACA,K;AACA,I;AACA,2E;AACA,uB;AACA,oC;AACA,wD;AACA,M;AACA,4B;AACA,iC;AACA,e;AACA,uB;AACA,iB;AACA,gC;AACA,iB;AACA,U;AACA,kB;AACA,6B;AACA,M;AACA,mC;AACA,2B;AACA,K;AACA,I;AACA,a;AACA,oC;AACA,wD;AACA,M;AACA,iC;AACA,2E;AACA,sD;AACA,M;AACA,iC;AACA,0C;AACA,M;AACA,mC;AACA,uC;AACA,K;AACA,I;AACA,yB;AACA,oC;AACA,wD;AACA,M;AACA,iC;AACA,8C;AACA,qB;AACA,O;AACA,4D;AACA,6C;AACA,S;AACA,M;AACA,iC;AACA,sB;AACA,yC;AACA,+C;AACA,S;AACA,+B;AACA,M;AACA,mC;AACA,sB;AACA,iD;AACA,iD;AACA,S;AACA,oB;AACA,K;AACA,I;AACA,a;AACA,oC;AACA,8E;AACA,M;AACA,iC;AACA,sC;AACA,M;AACA,iC;AACA,2D;AACA,iC;AACA,S;AACA,wD;AACA,M;AACA,mC;AACA,+B;AACA,wC;AACA,6E;AACA,4C;AACA,kD;AACA,qC;AACA,S;AACA,K;AACA,G;AACA,E;;AAEA,sC;AACA,e;AACA,4C;AACA,yC;AACA,uC;AACA,E;;;AAGA,sD;AACA,4B;AACA,gD;AACA,0C;AACA,mB;AACA,gB;AACA,4C;AACA,iC;AACA,wB;;AAEA,+B;AACA,8B;AACA,e;;AAEA,4C;AACA,qC;AACA,2D;AACA,2B;AACA,yB;;AAEA,2C;AACA,kB;AACA,yB;AACA,mC;AACA,K;AACA,4D;AACA,+B;AACA,kC;AACA,K;AACA,a;AACA,E;;AAEA,8E;AACA,sE;AACA,yC;AACA,sD;AACA,yC;AACA,sC;AACA,yC;AACA,K;AACA,G;AACA,mB;AACA,E;;AAEA,qC;AACA,wC;AACA,4B;AACA,mB;AACA,iC;AACA,6B;AACA,iC;AACA,G;AACA,c;AACA,E;;AAEA,sD;AACA,uD;AACA,6D;AACA,E;AACA,8B;AACA,kD;AACA,mB;AACA,gB;AACA,8C;AACA,2B;AACA,wB;;AAEA,+B;AACA,8B;AACA,e;;AAEA,qC;AACA,oC;AACA,+C;AACA,8B;AACA,2B;AACA,e;AACA,O;AACA,8D;AACA,iC;AACA,sC;AACA,K;AACA,K;AACA,a;AACA,E;;AAEA,0D;AACA,6D;;AAEA,uE;AACA,sB;AACA,4C;AACA,oD;AACA,0B;AACA,yC;AACA,iE;AACA,a;AACA,0D;AACA,6C;AACA,8C;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,uC;AACA,0C;AACA,qD;AACA,6B;AACA,mC;AACA,gB;AACA,U;AACA,mB;AACA,G;AACA,E;;AAEA,4C;AACA,qC;AACA,yD;AACA,oD;AACA,U;AACA,gC;AACA,G;AACA,E;;AAEA,+B;AACA,+B;AACA,+D;AACA,+C;AACA,E;;AAEA,iC;AACA,+E;AACA,sC;AACA,E;;AAEA,yC;AACA,Q;AACA,mE;AACA,c;AACA,gB;AACA,+B;AACA,uF;AACA,4F;AACA,4E;AACA,iB;AACA,wD;AACA,iB;AACA,6C;AACA,uC;AACA,+C;AACA,8B;AACA,mB;AACA,oC;AACA,wB;AACA,qB;AACA,K;AACA,gB;AACA,G;AACA,uC;AACA,gC;AACA,uC;AACA,gC;AACA,2B;AACA,8B;AACA,mB;AACA,8B;AACA,mB;AACA,oC;AACA,6C;AACA,qB;AACA,K;AACA,gB;AACA,G;AACA,oE;AACA,4D;AACA,yB;AACA,4E;AACA,G;AACA,gD;AACA,U;AACA,0B;AACA,mB;AACA,iC;AACA,sB;AACA,O;AACA,U;AACA,sC;AACA,8B;AACA,qB;AACA,O;AACA,2B;AACA,qB;AACA,O;AACA,qD;AACA,qB;AACA,O;AACA,U;AACA,kB;AACA,O;AACA,qC;AACA,U;AACA,U;AACA,wC;AACA,2B;AACA,qB;AACA,O;AACA,gD;AACA,qB;AACA,O;AACA,U;AACA,kB;AACA,O;AACA,kC;AACA,G;AACA,E;;AAEA,4B;AACA,U;AACA,4B;AACA,a;AACA,iB;AACA,4C;AACA,wB;AACA,iC;AACA,8E;AACA,8E;AACA,0B;AACA,a;AACA,0B;AACA,oC;AACA,wC;AACA,oB;AACA,K;AACA,e;AACA,G;AACA,wD;AACA,yC;AACA,+E;AACA,iB;AACA,a;AACA,kC;AACA,iC;AACA,e;AACA,G;AACA,0E;AACA,sC;AACA,qB;AACA,G;AACA,8B;AACA,+B;AACA,wE;AACA,G;AACA,yB;AACA,W;AACA,mC;AACA,kC;AACA,K;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;;AC/YA,qE;AACA,E;AACA,c;AACA,gB;AACA,E;AACA,oB;AACA,E;AACA,6D;;AAEA,wB;AACA,gC;AACA,C;;AAEA,wE;;AAEA,uC;;AAEA,sC;AACA,oC;AACA,sC;AACA,a;AACA,gC;AACA,c;AACA,0B;;AAEA,mD;;AAEA,yB;AACA,gB;AACA,wB;AACA,gB;AACA,sE;AACA,oD;AACA,iB;AACA,yB;AACA,+E;AACA,U;AACA,gB;AACA,6E;AACA,kC;AACA,iB;AACA,oB;AACA,K;AACA,mF;AACA,6C;AACA,iB;;AAEA,6B;AACA,mD;;AAEA,kF;AACA,6B;;AAEA,4B;AACA,uC;AACA,mF;AACA,O;;AAEA,mF;AACA,kB;;AAEA,iC;AACA,iB;AACA,+B;AACA,+F;AACA,c;AACA,0C;AACA,O;AACA,e;AACA,K;;;AAGA,qD;AACA,6B;AACA,kB;AACA,yB;AACA,+B;AACA,8D;AACA,c;AACA,gE;AACA,O;AACA,O;;;AAGA,oE;AACA,+B;;AAEA,+B;AACA,e;AACA,6B;AACA,6F;AACA,Y;AACA,wC;AACA,K;AACA,a;AACA,G;AACA,C;;AAEA,wE;;AAEA,uD;AACA,sE;AACA,iD;AACA,sB;AACA,e;AACA,oB;AACA,c;AACA,gC;AACA,0B;AACA,kD;AACA,uB;AACA,8C;AACA,uB;AACA,K;AACA,+B;AACA,G;AACA,qE;AACA,E;;;;;;;;;;;;;;;;;;;ACrHA,mB;;AAEA,uF;;AAEA,sB;;AAEA,gD;AACA,4C;AACA,E;;AAEA,iC;AACA,kB;AACA,e;AACA,e;AACA,e;AACA,e;AACA,0C;AACA,oB;AACA,W;AACA,iC;AACA,iC;AACA,Y;AACA,W;AACA,oC;AACA,gC;AACA,Y;AACA,W;AACA,qC;AACA,0B;AACA,8B;AACA,8B;AACA,8B;AACA,8B;AACA,e;AACA,e;AACA,e;AACA,e;AACA,Y;AACA,K;AACA,G;AACA,kB;AACA,4B;AACA,4B;AACA,kB;AACA,uB;AACA,Q;AACA,8B;AACA,kB;AACA,uB;AACA,G;AACA,yB;AACA,E;;AAEA,8B;AACA,mC;AACA,E;;AAEA,4B;AACA,mB;AACA,c;AACA,G;AACA,0B;AACA,E;;AAEA,kC;AACA,gF;AACA,iB;AACA,mC;AACA,kB;AACA,K;AACA,mC;AACA,e;AACA,G;AACA,8C;AACA,E;;AAEA,+B;AACA,yC;AACA,0C;AACA,U;AACA,0C;AACA,Y;AACA,G;AACA,iC;;AAEA,iB;AACA,iB;AACA,mB;;AAEA,Y;;AAEA,wC;AACA,0B;AACA,sB;AACA,oB;AACA,W;AACA,gB;AACA,iD;AACA,mB;AACA,Y;AACA,W;AACA,gB;AACA,iD;AACA,2B;AACA,qB;AACA,4B;AACA,Y;AACA,W;AACA,mB;AACA,6B;AACA,uB;AACA,gC;AACA,O;AACA,Y;AACA,W;AACA,mB;AACA,6B;AACA,O;AACA,Y;AACA,K;AACA,G;AACA,a;AACA,E;;AAEA,sC;;AAEA,sC","sourcesContent":["EJSON = {};\r\nEJSONTest = {};\r\n\r\nvar customTypes = {};\r\n// Add a custom type, using a method of your choice to get to and\r\n// from a basic JSON-able representation.  The factory argument\r\n// is a function of JSON-able --> your object\r\n// The type you add must have:\r\n// - A toJSONValue() method, so that Meteor can serialize it\r\n// - a typeName() method, to show how to look it up in our type table.\r\n// It is okay if these methods are monkey-patched on.\r\n// EJSON.clone will use toJSONValue and the given factory to produce\r\n// a clone, but you may specify a method clone() that will be\r\n// used instead.\r\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\r\n// but you may provide a method equals() instead.\r\n//\r\nEJSON.addType = function (name, factory) {\r\n  if (_.has(customTypes, name))\r\n    throw new Error(\"Type \" + name + \" already present\");\r\n  customTypes[name] = factory;\r\n};\r\n\r\nvar isInfOrNan = function (obj) {\r\n  return _.isNaN(obj) || obj === Infinity || obj === -Infinity;\r\n};\r\n\r\nvar builtinConverters = [\r\n  { // Date\r\n    matchJSONValue: function (obj) {\r\n      return _.has(obj, '$date') && _.size(obj) === 1;\r\n    },\r\n    matchObject: function (obj) {\r\n      return obj instanceof Date;\r\n    },\r\n    toJSONValue: function (obj) {\r\n      return {$date: obj.getTime()};\r\n    },\r\n    fromJSONValue: function (obj) {\r\n      return new Date(obj.$date);\r\n    }\r\n  },\r\n  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\r\n    // which we match.)\r\n    matchJSONValue: function (obj) {\r\n      return _.has(obj, '$InfNaN') && _.size(obj) === 1;\r\n    },\r\n    matchObject: isInfOrNan,\r\n    toJSONValue: function (obj) {\r\n      var sign;\r\n      if (_.isNaN(obj))\r\n        sign = 0;\r\n      else if (obj === Infinity)\r\n        sign = 1;\r\n      else\r\n        sign = -1;\r\n      return {$InfNaN: sign};\r\n    },\r\n    fromJSONValue: function (obj) {\r\n      return obj.$InfNaN/0;\r\n    }\r\n  },\r\n  { // Binary\r\n    matchJSONValue: function (obj) {\r\n      return _.has(obj, '$binary') && _.size(obj) === 1;\r\n    },\r\n    matchObject: function (obj) {\r\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\r\n        || (obj && _.has(obj, '$Uint8ArrayPolyfill'));\r\n    },\r\n    toJSONValue: function (obj) {\r\n      return {$binary: base64Encode(obj)};\r\n    },\r\n    fromJSONValue: function (obj) {\r\n      return base64Decode(obj.$binary);\r\n    }\r\n  },\r\n  { // Escaping one level\r\n    matchJSONValue: function (obj) {\r\n      return _.has(obj, '$escape') && _.size(obj) === 1;\r\n    },\r\n    matchObject: function (obj) {\r\n      if (_.isEmpty(obj) || _.size(obj) > 2) {\r\n        return false;\r\n      }\r\n      return _.any(builtinConverters, function (converter) {\r\n        return converter.matchJSONValue(obj);\r\n      });\r\n    },\r\n    toJSONValue: function (obj) {\r\n      var newObj = {};\r\n      _.each(obj, function (value, key) {\r\n        newObj[key] = EJSON.toJSONValue(value);\r\n      });\r\n      return {$escape: newObj};\r\n    },\r\n    fromJSONValue: function (obj) {\r\n      var newObj = {};\r\n      _.each(obj.$escape, function (value, key) {\r\n        newObj[key] = EJSON.fromJSONValue(value);\r\n      });\r\n      return newObj;\r\n    }\r\n  },\r\n  { // Custom\r\n    matchJSONValue: function (obj) {\r\n      return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;\r\n    },\r\n    matchObject: function (obj) {\r\n      return EJSON._isCustomType(obj);\r\n    },\r\n    toJSONValue: function (obj) {\r\n      var jsonValue = Meteor._noYieldsAllowed(function () {\r\n        return obj.toJSONValue();\r\n      });\r\n      return {$type: obj.typeName(), $value: jsonValue};\r\n    },\r\n    fromJSONValue: function (obj) {\r\n      var typeName = obj.$type;\r\n      if (!_.has(customTypes, typeName))\r\n        throw new Error(\"Custom EJSON type \" + typeName + \" is not defined\");\r\n      var converter = customTypes[typeName];\r\n      return Meteor._noYieldsAllowed(function () {\r\n        return converter(obj.$value);\r\n      });\r\n    }\r\n  }\r\n];\r\n\r\nEJSON._isCustomType = function (obj) {\r\n  return obj &&\r\n    typeof obj.toJSONValue === 'function' &&\r\n    typeof obj.typeName === 'function' &&\r\n    _.has(customTypes, obj.typeName());\r\n};\r\n\r\n\r\n// for both arrays and objects, in-place modification.\r\nvar adjustTypesToJSONValue =\r\nEJSON._adjustTypesToJSONValue = function (obj) {\r\n  // Is it an atom that we need to adjust?\r\n  if (obj === null)\r\n    return null;\r\n  var maybeChanged = toJSONValueHelper(obj);\r\n  if (maybeChanged !== undefined)\r\n    return maybeChanged;\r\n\r\n  // Other atoms are unchanged.\r\n  if (typeof obj !== 'object')\r\n    return obj;\r\n\r\n  // Iterate over array or object structure.\r\n  _.each(obj, function (value, key) {\r\n    if (typeof value !== 'object' && value !== undefined &&\r\n        !isInfOrNan(value))\r\n      return; // continue\r\n\r\n    var changed = toJSONValueHelper(value);\r\n    if (changed) {\r\n      obj[key] = changed;\r\n      return; // on to the next key\r\n    }\r\n    // if we get here, value is an object but not adjustable\r\n    // at this level.  recurse.\r\n    adjustTypesToJSONValue(value);\r\n  });\r\n  return obj;\r\n};\r\n\r\n// Either return the JSON-compatible version of the argument, or undefined (if\r\n// the item isn't itself replaceable, but maybe some fields in it are)\r\nvar toJSONValueHelper = function (item) {\r\n  for (var i = 0; i < builtinConverters.length; i++) {\r\n    var converter = builtinConverters[i];\r\n    if (converter.matchObject(item)) {\r\n      return converter.toJSONValue(item);\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\n\r\nEJSON.toJSONValue = function (item) {\r\n  var changed = toJSONValueHelper(item);\r\n  if (changed !== undefined)\r\n    return changed;\r\n  if (typeof item === 'object') {\r\n    item = EJSON.clone(item);\r\n    adjustTypesToJSONValue(item);\r\n  }\r\n  return item;\r\n};\r\n\r\n// for both arrays and objects. Tries its best to just\r\n// use the object you hand it, but may return something\r\n// different if the object you hand it itself needs changing.\r\n//\r\nvar adjustTypesFromJSONValue =\r\nEJSON._adjustTypesFromJSONValue = function (obj) {\r\n  if (obj === null)\r\n    return null;\r\n  var maybeChanged = fromJSONValueHelper(obj);\r\n  if (maybeChanged !== obj)\r\n    return maybeChanged;\r\n\r\n  // Other atoms are unchanged.\r\n  if (typeof obj !== 'object')\r\n    return obj;\r\n\r\n  _.each(obj, function (value, key) {\r\n    if (typeof value === 'object') {\r\n      var changed = fromJSONValueHelper(value);\r\n      if (value !== changed) {\r\n        obj[key] = changed;\r\n        return;\r\n      }\r\n      // if we get here, value is an object but not adjustable\r\n      // at this level.  recurse.\r\n      adjustTypesFromJSONValue(value);\r\n    }\r\n  });\r\n  return obj;\r\n};\r\n\r\n// Either return the argument changed to have the non-json\r\n// rep of itself (the Object version) or the argument itself.\r\n\r\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\r\n// EJSON.fromJSONValue\r\nvar fromJSONValueHelper = function (value) {\r\n  if (typeof value === 'object' && value !== null) {\r\n    if (_.size(value) <= 2\r\n        && _.all(value, function (v, k) {\r\n          return typeof k === 'string' && k.substr(0, 1) === '$';\r\n        })) {\r\n      for (var i = 0; i < builtinConverters.length; i++) {\r\n        var converter = builtinConverters[i];\r\n        if (converter.matchJSONValue(value)) {\r\n          return converter.fromJSONValue(value);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return value;\r\n};\r\n\r\nEJSON.fromJSONValue = function (item) {\r\n  var changed = fromJSONValueHelper(item);\r\n  if (changed === item && typeof item === 'object') {\r\n    item = EJSON.clone(item);\r\n    adjustTypesFromJSONValue(item);\r\n    return item;\r\n  } else {\r\n    return changed;\r\n  }\r\n};\r\n\r\nEJSON.stringify = function (item, options) {\r\n  var json = EJSON.toJSONValue(item);\r\n  if (options && (options.canonical || options.indent)) {\r\n    return EJSON._canonicalStringify(json, options);\r\n  } else {\r\n    return JSON.stringify(json);\r\n  }\r\n};\r\n\r\nEJSON.parse = function (item) {\r\n  if (typeof item !== 'string')\r\n    throw new Error(\"EJSON.parse argument should be a string\");\r\n  return EJSON.fromJSONValue(JSON.parse(item));\r\n};\r\n\r\nEJSON.isBinary = function (obj) {\r\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\r\n    (obj && obj.$Uint8ArrayPolyfill));\r\n};\r\n\r\nEJSON.equals = function (a, b, options) {\r\n  var i;\r\n  var keyOrderSensitive = !!(options && options.keyOrderSensitive);\r\n  if (a === b)\r\n    return true;\r\n  if (_.isNaN(a) && _.isNaN(b))\r\n    return true; // This differs from the IEEE spec for NaN equality, b/c we don't want\r\n                 // anything ever with a NaN to be poisoned from becoming equal to anything.\r\n  if (!a || !b) // if either one is falsy, they'd have to be === to be equal\r\n    return false;\r\n  if (!(typeof a === 'object' && typeof b === 'object'))\r\n    return false;\r\n  if (a instanceof Date && b instanceof Date)\r\n    return a.valueOf() === b.valueOf();\r\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\r\n    if (a.length !== b.length)\r\n      return false;\r\n    for (i = 0; i < a.length; i++) {\r\n      if (a[i] !== b[i])\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  if (typeof (a.equals) === 'function')\r\n    return a.equals(b, options);\r\n  if (typeof (b.equals) === 'function')\r\n    return b.equals(a, options);\r\n  if (a instanceof Array) {\r\n    if (!(b instanceof Array))\r\n      return false;\r\n    if (a.length !== b.length)\r\n      return false;\r\n    for (i = 0; i < a.length; i++) {\r\n      if (!EJSON.equals(a[i], b[i], options))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  // fallback for custom types that don't implement their own equals\r\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\r\n    case 1: return false;\r\n    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\r\n  }\r\n  // fall back to structural equality of objects\r\n  var ret;\r\n  if (keyOrderSensitive) {\r\n    var bKeys = [];\r\n    _.each(b, function (val, x) {\r\n        bKeys.push(x);\r\n    });\r\n    i = 0;\r\n    ret = _.all(a, function (val, x) {\r\n      if (i >= bKeys.length) {\r\n        return false;\r\n      }\r\n      if (x !== bKeys[i]) {\r\n        return false;\r\n      }\r\n      if (!EJSON.equals(val, b[bKeys[i]], options)) {\r\n        return false;\r\n      }\r\n      i++;\r\n      return true;\r\n    });\r\n    return ret && i === bKeys.length;\r\n  } else {\r\n    i = 0;\r\n    ret = _.all(a, function (val, key) {\r\n      if (!_.has(b, key)) {\r\n        return false;\r\n      }\r\n      if (!EJSON.equals(val, b[key], options)) {\r\n        return false;\r\n      }\r\n      i++;\r\n      return true;\r\n    });\r\n    return ret && _.size(b) === i;\r\n  }\r\n};\r\n\r\nEJSON.clone = function (v) {\r\n  var ret;\r\n  if (typeof v !== \"object\")\r\n    return v;\r\n  if (v === null)\r\n    return null; // null has typeof \"object\"\r\n  if (v instanceof Date)\r\n    return new Date(v.getTime());\r\n  // RegExps are not really EJSON elements (eg we don't define a serialization\r\n  // for them), but they're immutable anyway, so we can support them in clone.\r\n  if (v instanceof RegExp)\r\n    return v;\r\n  if (EJSON.isBinary(v)) {\r\n    ret = EJSON.newBinary(v.length);\r\n    for (var i = 0; i < v.length; i++) {\r\n      ret[i] = v[i];\r\n    }\r\n    return ret;\r\n  }\r\n  // XXX: Use something better than underscore's isArray\r\n  if (_.isArray(v) || _.isArguments(v)) {\r\n    // For some reason, _.map doesn't work in this context on Opera (weird test\r\n    // failures).\r\n    ret = [];\r\n    for (i = 0; i < v.length; i++)\r\n      ret[i] = EJSON.clone(v[i]);\r\n    return ret;\r\n  }\r\n  // handle general user-defined typed Objects if they have a clone method\r\n  if (typeof v.clone === 'function') {\r\n    return v.clone();\r\n  }\r\n  // handle other custom types\r\n  if (EJSON._isCustomType(v)) {\r\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\r\n  }\r\n  // handle other objects\r\n  ret = {};\r\n  _.each(v, function (value, key) {\r\n    ret[key] = EJSON.clone(value);\r\n  });\r\n  return ret;\r\n};\r\n","// Based on json2.js from https://github.com/douglascrockford/JSON-js\r\n//\r\n//    json2.js\r\n//    2012-10-08\r\n//\r\n//    Public Domain.\r\n//\r\n//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\r\n\r\nfunction quote(string) {\r\n  return JSON.stringify(string);\r\n}\r\n\r\nvar str = function (key, holder, singleIndent, outerIndent, canonical) {\r\n\r\n  // Produce a string from holder[key].\r\n\r\n  var i;          // The loop counter.\r\n  var k;          // The member key.\r\n  var v;          // The member value.\r\n  var length;\r\n  var innerIndent = outerIndent;\r\n  var partial;\r\n  var value = holder[key];\r\n\r\n  // What happens next depends on the value's type.\r\n\r\n  switch (typeof value) {\r\n  case 'string':\r\n    return quote(value);\r\n  case 'number':\r\n    // JSON numbers must be finite. Encode non-finite numbers as null.\r\n    return isFinite(value) ? String(value) : 'null';\r\n  case 'boolean':\r\n    return String(value);\r\n  // If the type is 'object', we might be dealing with an object or an array or\r\n  // null.\r\n  case 'object':\r\n    // Due to a specification blunder in ECMAScript, typeof null is 'object',\r\n    // so watch out for that case.\r\n    if (!value) {\r\n      return 'null';\r\n    }\r\n    // Make an array to hold the partial results of stringifying this object value.\r\n    innerIndent = outerIndent + singleIndent;\r\n    partial = [];\r\n\r\n    // Is the value an array?\r\n    if (_.isArray(value) || _.isArguments(value)) {\r\n\r\n      // The value is an array. Stringify every element. Use null as a placeholder\r\n      // for non-JSON values.\r\n\r\n      length = value.length;\r\n      for (i = 0; i < length; i += 1) {\r\n        partial[i] = str(i, value, singleIndent, innerIndent, canonical) || 'null';\r\n      }\r\n\r\n      // Join all of the elements together, separated with commas, and wrap them in\r\n      // brackets.\r\n\r\n      if (partial.length === 0) {\r\n        v = '[]';\r\n      } else if (innerIndent) {\r\n        v = '[\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + ']';\r\n      } else {\r\n        v = '[' + partial.join(',') + ']';\r\n      }\r\n      return v;\r\n    }\r\n\r\n\r\n    // Iterate through all of the keys in the object.\r\n    var keys = _.keys(value);\r\n    if (canonical)\r\n      keys = keys.sort();\r\n    _.each(keys, function (k) {\r\n      v = str(k, value, singleIndent, innerIndent, canonical);\r\n      if (v) {\r\n        partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\r\n      }\r\n    });\r\n\r\n\r\n    // Join all of the member texts together, separated with commas,\r\n    // and wrap them in braces.\r\n\r\n    if (partial.length === 0) {\r\n      v = '{}';\r\n    } else if (innerIndent) {\r\n      v = '{\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + '}';\r\n    } else {\r\n      v = '{' + partial.join(',') + '}';\r\n    }\r\n    return v;\r\n  }\r\n}\r\n\r\n// If the JSON object does not yet have a stringify method, give it one.\r\n\r\nEJSON._canonicalStringify = function (value, options) {\r\n  // Make a fake root object containing our value under the key of ''.\r\n  // Return the result of stringifying the value.\r\n  options = _.extend({\r\n    indent: \"\",\r\n    canonical: false\r\n  }, options);\r\n  if (options.indent === true) {\r\n    options.indent = \"  \";\r\n  } else if (typeof options.indent === 'number') {\r\n    var newIndent = \"\";\r\n    for (var i = 0; i < options.indent; i++) {\r\n      newIndent += ' ';\r\n    }\r\n    options.indent = newIndent;\r\n  }\r\n  return str('', {'': value}, options.indent, \"\", options.canonical);\r\n};\r\n","// Base 64 encoding\r\n\r\nvar BASE_64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\nvar BASE_64_VALS = {};\r\n\r\nfor (var i = 0; i < BASE_64_CHARS.length; i++) {\r\n  BASE_64_VALS[BASE_64_CHARS.charAt(i)] = i;\r\n};\r\n\r\nbase64Encode = function (array) {\r\n  var answer = [];\r\n  var a = null;\r\n  var b = null;\r\n  var c = null;\r\n  var d = null;\r\n  for (var i = 0; i < array.length; i++) {\r\n    switch (i % 3) {\r\n    case 0:\r\n      a = (array[i] >> 2) & 0x3F;\r\n      b = (array[i] & 0x03) << 4;\r\n      break;\r\n    case 1:\r\n      b = b | (array[i] >> 4) & 0xF;\r\n      c = (array[i] & 0xF) << 2;\r\n      break;\r\n    case 2:\r\n      c = c | (array[i] >> 6) & 0x03;\r\n      d = array[i] & 0x3F;\r\n      answer.push(getChar(a));\r\n      answer.push(getChar(b));\r\n      answer.push(getChar(c));\r\n      answer.push(getChar(d));\r\n      a = null;\r\n      b = null;\r\n      c = null;\r\n      d = null;\r\n      break;\r\n    }\r\n  }\r\n  if (a != null) {\r\n    answer.push(getChar(a));\r\n    answer.push(getChar(b));\r\n    if (c == null)\r\n      answer.push('=');\r\n    else\r\n      answer.push(getChar(c));\r\n    if (d == null)\r\n      answer.push('=');\r\n  }\r\n  return answer.join(\"\");\r\n};\r\n\r\nvar getChar = function (val) {\r\n  return BASE_64_CHARS.charAt(val);\r\n};\r\n\r\nvar getVal = function (ch) {\r\n  if (ch === '=') {\r\n    return -1;\r\n  }\r\n  return BASE_64_VALS[ch];\r\n};\r\n\r\nEJSON.newBinary = function (len) {\r\n  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\r\n    var ret = [];\r\n    for (var i = 0; i < len; i++) {\r\n      ret.push(0);\r\n    }\r\n    ret.$Uint8ArrayPolyfill = true;\r\n    return ret;\r\n  }\r\n  return new Uint8Array(new ArrayBuffer(len));\r\n};\r\n\r\nbase64Decode = function (str) {\r\n  var len = Math.floor((str.length*3)/4);\r\n  if (str.charAt(str.length - 1) == '=') {\r\n    len--;\r\n    if (str.charAt(str.length - 2) == '=')\r\n      len--;\r\n  }\r\n  var arr = EJSON.newBinary(len);\r\n\r\n  var one = null;\r\n  var two = null;\r\n  var three = null;\r\n\r\n  var j = 0;\r\n\r\n  for (var i = 0; i < str.length; i++) {\r\n    var c = str.charAt(i);\r\n    var v = getVal(c);\r\n    switch (i % 4) {\r\n    case 0:\r\n      if (v < 0)\r\n        throw new Error('invalid base64 string');\r\n      one = v << 2;\r\n      break;\r\n    case 1:\r\n      if (v < 0)\r\n        throw new Error('invalid base64 string');\r\n      one = one | (v >> 4);\r\n      arr[j++] = one;\r\n      two = (v & 0x0F) << 4;\r\n      break;\r\n    case 2:\r\n      if (v >= 0) {\r\n        two = two | (v >> 2);\r\n        arr[j++] = two;\r\n        three = (v & 0x03) << 6;\r\n      }\r\n      break;\r\n    case 3:\r\n      if (v >= 0) {\r\n        arr[j++] = three | v;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  return arr;\r\n};\r\n\r\nEJSONTest.base64Encode = base64Encode;\r\n\r\nEJSONTest.base64Decode = base64Decode;\r\n"]}