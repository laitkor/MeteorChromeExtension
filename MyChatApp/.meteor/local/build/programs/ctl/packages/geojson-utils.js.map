{"version":3,"file":"\\packages\\geojson-utils.js","sources":["geojson-utils/pre.js","geojson-utils/geojson-utils.js","geojson-utils/post.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,gF;AACA,2E;AACA,sB;;;;;;;;;;;;;;;;;;;;ACFA,c;AACA,e;;AAEA,+C;AACA,wD;AACA,yB;AACA,G;;AAEA,gF;AACA,gD;AACA,wB;AACA,0D;AACA,4D;AACA,kB;AACA,kC;AACA,iC;AACA,U;AACA,gB;AACA,wC;AACA,uC;AACA,Y;AACA,gB;AACA,oC;AACA,mC;AACA,Y;AACA,gB;AACA,wC;AACA,uC;AACA,Y;AACA,+E;AACA,+E;AACA,8E;AACA,uB;AACA,8B;AACA,4B;AACA,yD;AACA,6B;AACA,8B;AACA,mF;AACA,e;AACA,W;AACA,S;AACA,O;AACA,K;AACA,mD;AACA,sB;AACA,G;;AAEA,iB;;AAEA,iD;AACA,4B;;AAEA,gD;AACA,gC;AACA,gC;AACA,K;;AAEA,qD;AACA,qD;;AAEA,iF;AACA,G;;AAEA,qD;AACA,uK;AACA,G;;AAEA,qB;AACA,gG;;AAEA,gC;AACA,wB;;AAEA,6C;AACA,kD;AACA,+B;AACA,O;AACA,sB;AACA,K;;AAEA,sB;AACA,oE;AACA,iK;AACA,K;;AAEA,iB;AACA,G;;AAEA,2C;AACA,mF;;AAEA,yB;AACA,6C;AACA,6F;AACA,K;AACA,gC;;AAEA,0B;AACA,6C;AACA,kF;AACA,K;;AAEA,qB;AACA,G;;AAEA,0C;AACA,kC;AACA,G;;AAEA,0C;AACA,kC;AACA,G;;AAEA,sC;AACA,kE;AACA,0E;AACA,4C;AACA,kC;AACA,iF;AACA,0B;AACA,wB;AACA,sC;AACA,qC;AACA,yC;AACA,iE;AACA,0E;AACA,mG;AACA,mG;AACA,mB;AACA,2C;AACA,2C;AACA,K;AACA,Y;AACA,wB;AACA,2B;AACA,M;AACA,G;;AAEA,iD;AACA,gD;AACA,wC;AACA,0B;AACA,wB;AACA,wB;AACA,wB;AACA,6B;AACA,6B;AACA,Y;AACA,sB;AACA,2D;AACA,M;AACA,G;;AAEA,4D;AACA,2C;AACA,kC;AACA,gC;AACA,gC;AACA,gC;AACA,6C;AACA,6C;AACA,8E;AACA,+E;AACA,yD;AACA,8B;AACA,+C;AACA,I;;AAEA,qD;AACA,0C;AACA,kE;AACA,mC;AACA,2D;AACA,6E;AACA,qB;AACA,sB;AACA,uC;AACA,gE;AACA,8C;AACA,c;AACA,2C;AACA,O;AACA,kC;AACA,2C;AACA,wD;AACA,uB;AACA,S;AACA,O;AACA,K;AACA,gB;AACA,G;;AAEA,wE;AACA,iC;AACA,iB;AACA,4C;AACA,wC;AACA,8B;AACA,e;;AAEA,iD;AACA,gB;AACA,wB;AACA,uB;AACA,Q;AACA,gB;AACA,wB;AACA,uB;AACA,Q;AACA,0B;AACA,0B;AACA,K;;AAEA,c;AACA,gB;AACA,I;;AAEA,wE;AACA,qC;AACA,iB;AACA,Y;AACA,4C;AACA,wC;AACA,8B;AACA,e;;AAEA,iD;AACA,gB;AACA,wB;AACA,uB;AACA,Q;AACA,gB;AACA,wB;AACA,uB;AACA,Q;AACA,oC;AACA,6B;AACA,6B;AACA,K;;AAEA,8B;AACA,Y;AACA,sB;AACA,mC;AACA,M;AACA,I;;AAEA,iF;AACA,sD;AACA,0G;AACA,sB;AACA,sC;AACA,c;AACA,8B;AACA,6B;AACA,O;AACA,O;;AAEA,sD;AACA,uC;AACA,oD;AACA,oC;AACA,kG;AACA,gF;AACA,8B;;AAEA,gC;;AAEA,mE;;AAEA,6C;;AAEA,6B;AACA,+E;AACA,yB;AACA,e;AACA,qB;AACA,8B;AACA,gB;;AAEA,2C;AACA,yB;;AAEA,uD;;AAEA,qC;AACA,iC;AACA,gB;;AAEA,8D;;AAEA,8D;AACA,yD;;AAEA,wD;AACA,wD;AACA,+D;AACA,uG;AACA,wC;;AAEA,4E;;AAEA,sD;AACA,sD;AACA,iE;AACA,uE;AACA,0C;;AAEA,oD;AACA,oD;AACA,iE;AACA,qE;AACA,0C;;AAEA,gD;AACA,qD;AACA,mG;AACA,sC;AACA,oB;AACA,kC;AACA,W;AACA,S;;AAEA,gF;AACA,uD;AACA,gC;AACA,mB;AACA,wF;AACA,oB;AACA,uC;AACA,qC;AACA,oB;AACA,yC;AACA,qC;AACA,S;AACA,gF;AACA,8B;AACA,iB;AACA,O;AACA,K;;AAEA,6B;AACA,iC;AACA,a;;AAEA,2B;AACA,wB;AACA,oC;AACA,+B;;AAEA,+B;AACA,c;AACA,sB;AACA,mC;AACA,O;AACA,O;AACA,G;;AAEA,iE;AACA,oD;AACA,qE;AACA,oC;;AAEA,qD;AACA,qD;;AAEA,yD;AACA,yE;AACA,8E;AACA,+E;AACA,iF;;AAEA,Y;AACA,sB;AACA,yE;AACA,M;AACA,I;;AAEA,K;;;;;;;;;;;;;;;;;;;AC3XA,4E;AACA,8E;AACA,yB","sourcesContent":["// Define an object named exports. This will cause geojson-utils.js to put `gju`\r\n// as a field on it, instead of in the global namespace.  See also post.js.\r\nmodule = {exports:{}};\r\n\r\n","(function () {\r\n  var gju = {};\r\n\r\n  // Export the geojson object for **CommonJS**\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = gju;\r\n  }\r\n\r\n  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js\r\n  gju.lineStringsIntersect = function (l1, l2) {\r\n    var intersects = [];\r\n    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {\r\n      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {\r\n        var a1 = {\r\n          x: l1.coordinates[i][1],\r\n          y: l1.coordinates[i][0]\r\n        },\r\n          a2 = {\r\n            x: l1.coordinates[i + 1][1],\r\n            y: l1.coordinates[i + 1][0]\r\n          },\r\n          b1 = {\r\n            x: l2.coordinates[j][1],\r\n            y: l2.coordinates[j][0]\r\n          },\r\n          b2 = {\r\n            x: l2.coordinates[j + 1][1],\r\n            y: l2.coordinates[j + 1][0]\r\n          },\r\n          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),\r\n          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),\r\n          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\r\n        if (u_b != 0) {\r\n          var ua = ua_t / u_b,\r\n            ub = ub_t / u_b;\r\n          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\r\n            intersects.push({\r\n              'type': 'Point',\r\n              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (intersects.length == 0) intersects = false;\r\n    return intersects;\r\n  }\r\n\r\n  // Bounding Box\r\n\r\n  function boundingBoxAroundPolyCoords (coords) {\r\n    var xAll = [], yAll = []\r\n\r\n    for (var i = 0; i < coords[0].length; i++) {\r\n      xAll.push(coords[0][i][1])\r\n      yAll.push(coords[0][i][0])\r\n    }\r\n\r\n    xAll = xAll.sort(function (a,b) { return a - b })\r\n    yAll = yAll.sort(function (a,b) { return a - b })\r\n\r\n    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]\r\n  }\r\n\r\n  gju.pointInBoundingBox = function (point, bounds) {\r\n    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) \r\n  }\r\n\r\n  // Point in Polygon\r\n  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices\r\n\r\n  function pnpoly (x,y,coords) {\r\n    var vert = [ [0,0] ]\r\n\r\n    for (var i = 0; i < coords.length; i++) {\r\n      for (var j = 0; j < coords[i].length; j++) {\r\n        vert.push(coords[i][j])\r\n      }\r\n      vert.push([0,0])\r\n    }\r\n\r\n    var inside = false\r\n    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {\r\n      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside\r\n    }\r\n\r\n    return inside\r\n  }\r\n\r\n  gju.pointInPolygon = function (p, poly) {\r\n    var coords = (poly.type == \"Polygon\") ? [ poly.coordinates ] : poly.coordinates\r\n\r\n    var insideBox = false\r\n    for (var i = 0; i < coords.length; i++) {\r\n      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true\r\n    }\r\n    if (!insideBox) return false\r\n\r\n    var insidePoly = false\r\n    for (var i = 0; i < coords.length; i++) {\r\n      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true\r\n    }\r\n\r\n    return insidePoly\r\n  }\r\n\r\n  gju.numberToRadius = function (number) {\r\n    return number * Math.PI / 180;\r\n  }\r\n\r\n  gju.numberToDegree = function (number) {\r\n    return number * 180 / Math.PI;\r\n  }\r\n\r\n  // written with help from @tautologe\r\n  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {\r\n    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],\r\n      dist = (radiusInMeters / 1000) / 6371,\r\n      // convert meters to radiant\r\n      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],\r\n      steps = steps || 15,\r\n      // 15 sided circle\r\n      poly = [[center[0], center[1]]];\r\n    for (var i = 0; i < steps; i++) {\r\n      var brng = 2 * Math.PI * i / steps;\r\n      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)\r\n              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));\r\n      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),\r\n                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));\r\n      poly[i] = [];\r\n      poly[i][1] = gju.numberToDegree(lat);\r\n      poly[i][0] = gju.numberToDegree(lng);\r\n    }\r\n    return {\r\n      \"type\": \"Polygon\",\r\n      \"coordinates\": [poly]\r\n    };\r\n  }\r\n\r\n  // assumes rectangle starts at lower left point\r\n  gju.rectangleCentroid = function (rectangle) {\r\n    var bbox = rectangle.coordinates[0];\r\n    var xmin = bbox[0][0],\r\n      ymin = bbox[0][1],\r\n      xmax = bbox[2][0],\r\n      ymax = bbox[2][1];\r\n    var xwidth = xmax - xmin;\r\n    var ywidth = ymax - ymin;\r\n    return {\r\n      'type': 'Point',\r\n      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]\r\n    };\r\n  }\r\n\r\n  // from http://www.movable-type.co.uk/scripts/latlong.html\r\n  gju.pointDistance = function (pt1, pt2) {\r\n    var lon1 = pt1.coordinates[0],\r\n      lat1 = pt1.coordinates[1],\r\n      lon2 = pt2.coordinates[0],\r\n      lat2 = pt2.coordinates[1],\r\n      dLat = gju.numberToRadius(lat2 - lat1),\r\n      dLon = gju.numberToRadius(lon2 - lon1),\r\n      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))\r\n        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),\r\n      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    // Earth radius is 6371 km\r\n    return (6371 * c) * 1000; // returns meters\r\n  },\r\n\r\n  // checks if geometry lies entirely within a circle\r\n  // works with Point, LineString, Polygon\r\n  gju.geometryWithinRadius = function (geometry, center, radius) {\r\n    if (geometry.type == 'Point') {\r\n      return gju.pointDistance(geometry, center) <= radius;\r\n    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {\r\n      var point = {};\r\n      var coordinates;\r\n      if (geometry.type == 'Polygon') {\r\n        // it's enough to check the exterior ring of the Polygon\r\n        coordinates = geometry.coordinates[0];\r\n      } else {\r\n        coordinates = geometry.coordinates;\r\n      }\r\n      for (var i in coordinates) {\r\n        point.coordinates = coordinates[i];\r\n        if (gju.pointDistance(point, center) > radius) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\r\n  gju.area = function (polygon) {\r\n    var area = 0;\r\n    // TODO: polygon holes at coordinates[1]\r\n    var points = polygon.coordinates[0];\r\n    var j = points.length - 1;\r\n    var p1, p2;\r\n\r\n    for (var i = 0; i < points.length; j = i++) {\r\n      var p1 = {\r\n        x: points[i][1],\r\n        y: points[i][0]\r\n      };\r\n      var p2 = {\r\n        x: points[j][1],\r\n        y: points[j][0]\r\n      };\r\n      area += p1.x * p2.y;\r\n      area -= p1.y * p2.x;\r\n    }\r\n\r\n    area /= 2;\r\n    return area;\r\n  },\r\n\r\n  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\r\n  gju.centroid = function (polygon) {\r\n    var f, x = 0,\r\n      y = 0;\r\n    // TODO: polygon holes at coordinates[1]\r\n    var points = polygon.coordinates[0];\r\n    var j = points.length - 1;\r\n    var p1, p2;\r\n\r\n    for (var i = 0; i < points.length; j = i++) {\r\n      var p1 = {\r\n        x: points[i][1],\r\n        y: points[i][0]\r\n      };\r\n      var p2 = {\r\n        x: points[j][1],\r\n        y: points[j][0]\r\n      };\r\n      f = p1.x * p2.y - p2.x * p1.y;\r\n      x += (p1.x + p2.x) * f;\r\n      y += (p1.y + p2.y) * f;\r\n    }\r\n\r\n    f = gju.area(polygon) * 6;\r\n    return {\r\n      'type': 'Point',\r\n      'coordinates': [y / f, x / f]\r\n    };\r\n  },\r\n\r\n  gju.simplify = function (source, kink) { /* source[] array of geojson points */\r\n    /* kink\tin metres, kinks above this depth kept  */\r\n    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */\r\n    kink = kink || 20;\r\n    source = source.map(function (o) {\r\n      return {\r\n        lng: o.coordinates[0],\r\n        lat: o.coordinates[1]\r\n      }\r\n    });\r\n\r\n    var n_source, n_stack, n_dest, start, end, i, sig;\r\n    var dev_sqr, max_dev_sqr, band_sqr;\r\n    var x12, y12, d12, x13, y13, d13, x23, y23, d23;\r\n    var F = (Math.PI / 180.0) * 0.5;\r\n    var index = new Array(); /* aray of indexes of source points to include in the reduced line */\r\n    var sig_start = new Array(); /* indices of start & end of working section */\r\n    var sig_end = new Array();\r\n\r\n    /* check for simple cases */\r\n\r\n    if (source.length < 3) return (source); /* one or two points */\r\n\r\n    /* more complex case. initialize stack */\r\n\r\n    n_source = source.length;\r\n    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */\r\n    band_sqr *= band_sqr;\r\n    n_dest = 0;\r\n    sig_start[0] = 0;\r\n    sig_end[0] = n_source - 1;\r\n    n_stack = 1;\r\n\r\n    /* while the stack is not empty  ... */\r\n    while (n_stack > 0) {\r\n\r\n      /* ... pop the top-most entries off the stacks */\r\n\r\n      start = sig_start[n_stack - 1];\r\n      end = sig_end[n_stack - 1];\r\n      n_stack--;\r\n\r\n      if ((end - start) > 1) { /* any intermediate points ? */\r\n\r\n        /* ... yes, so find most deviant intermediate point to\r\n        either side of line joining start & end points */\r\n\r\n        x12 = (source[end].lng() - source[start].lng());\r\n        y12 = (source[end].lat() - source[start].lat());\r\n        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);\r\n        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */\r\n        d12 = (x12 * x12) + (y12 * y12);\r\n\r\n        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {\r\n\r\n          x13 = source[i].lng() - source[start].lng();\r\n          y13 = source[i].lat() - source[start].lat();\r\n          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);\r\n          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));\r\n          d13 = (x13 * x13) + (y13 * y13);\r\n\r\n          x23 = source[i].lng() - source[end].lng();\r\n          y23 = source[i].lat() - source[end].lat();\r\n          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);\r\n          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));\r\n          d23 = (x23 * x23) + (y23 * y23);\r\n\r\n          if (d13 >= (d12 + d23)) dev_sqr = d23;\r\n          else if (d23 >= (d12 + d13)) dev_sqr = d13;\r\n          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle\r\n          if (dev_sqr > max_dev_sqr) {\r\n            sig = i;\r\n            max_dev_sqr = dev_sqr;\r\n          }\r\n        }\r\n\r\n        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */\r\n          /* ... no, so transfer current start point */\r\n          index[n_dest] = start;\r\n          n_dest++;\r\n        } else { /* ... yes, so push two sub-sections on stack for further processing */\r\n          n_stack++;\r\n          sig_start[n_stack - 1] = sig;\r\n          sig_end[n_stack - 1] = end;\r\n          n_stack++;\r\n          sig_start[n_stack - 1] = start;\r\n          sig_end[n_stack - 1] = sig;\r\n        }\r\n      } else { /* ... no intermediate points, so transfer current start point */\r\n        index[n_dest] = start;\r\n        n_dest++;\r\n      }\r\n    }\r\n\r\n    /* transfer last point */\r\n    index[n_dest] = n_source - 1;\r\n    n_dest++;\r\n\r\n    /* make return array */\r\n    var r = new Array();\r\n    for (var i = 0; i < n_dest; i++)\r\n      r.push(source[index[i]]);\r\n\r\n    return r.map(function (o) {\r\n      return {\r\n        type: \"Point\",\r\n        coordinates: [o.lng, o.lat]\r\n      }\r\n    });\r\n  }\r\n\r\n  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint\r\n  gju.destinationPoint = function (pt, brng, dist) {\r\n    dist = dist/6371;  // convert dist to angular distance in radians\r\n    brng = gju.numberToRadius(brng);\r\n\r\n    var lat1 = gju.numberToRadius(pt.coordinates[0]);\r\n    var lon1 = gju.numberToRadius(pt.coordinates[1]);\r\n\r\n    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +\r\n                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );\r\n    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),\r\n                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));\r\n    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180ยบ\r\n\r\n    return {\r\n      'type': 'Point',\r\n      'coordinates': [gju.numberToDegree(lat2), gju.numberToDegree(lon2)]\r\n    };\r\n  };\r\n\r\n})();\r\n","// This exports object was created in pre.js.  Now copy the `exports` object\r\n// from it into the package-scope variable `GeoJSON`, which will get exported.\r\nGeoJSON = module.exports;\r\n\r\n"]}