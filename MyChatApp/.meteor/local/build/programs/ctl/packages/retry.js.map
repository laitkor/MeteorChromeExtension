{"version":3,"file":"\\packages\\retry.js","sources":["retry/retry.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,2C;AACA,E;AACA,W;AACA,yD;AACA,kE;AACA,kD;AACA,sD;AACA,mE;AACA,qE;;AAEA,4B;AACA,kB;AACA,qD;AACA,kC;AACA,kB;AACA,oE;AACA,8B;AACA,uC;AACA,mB;AACA,gB;AACA,uB;AACA,M;AACA,yB;AACA,E;;AAEA,2B;;AAEA,mC;AACA,sB;AACA,oB;AACA,wB;AACA,oC;AACA,2B;AACA,I;;AAEA,sE;AACA,oC;AACA,8B;AACA,oB;;AAEA,8B;AACA,6B;;AAEA,2B;AACA,sB;AACA,yD;AACA,kE;AACA,wB;AACA,0D;AACA,4C;AACA,mB;AACA,I;;AAEA,0E;AACA,oC;AACA,oB;AACA,uC;AACA,wB;AACA,oC;AACA,qD;AACA,mB;AACA,G;;AAEA,G","sourcesContent":["// Retry logic with an exponential backoff.\r\n//\r\n// options:\r\n//  baseTimeout: time for initial reconnect attempt (ms).\r\n//  exponent: exponential factor to increase timeout each attempt.\r\n//  maxTimeout: maximum time between retries (ms).\r\n//  minCount: how many times to reconnect \"instantly\".\r\n//  minTimeout: time to wait for the first `minCount` retries (ms).\r\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\r\n\r\nRetry = function (options) {\r\n  var self = this;\r\n  _.extend(self, _.defaults(_.clone(options || {}), {\r\n    baseTimeout: 1000, // 1 second\r\n    exponent: 2.2,\r\n    // The default is high-ish to ensure a server can recover from a\r\n    // failure caused by load.\r\n    maxTimeout: 5 * 60000, // 5 minutes\r\n    minTimeout: 10,\r\n    minCount: 2,\r\n    fuzz: 0.5 // +- 25%\r\n  }));\r\n  self.retryTimer = null;\r\n};\r\n\r\n_.extend(Retry.prototype, {\r\n\r\n  // Reset a pending retry, if any.\r\n  clear: function () {\r\n    var self = this;\r\n    if (self.retryTimer)\r\n      clearTimeout(self.retryTimer);\r\n    self.retryTimer = null;\r\n  },\r\n\r\n  // Calculate how long to wait in milliseconds to retry, based on the\r\n  // `count` of which retry this is.\r\n  _timeout: function (count) {\r\n    var self = this;\r\n\r\n    if (count < self.minCount)\r\n      return self.minTimeout;\r\n\r\n    var timeout = Math.min(\r\n      self.maxTimeout,\r\n      self.baseTimeout * Math.pow(self.exponent, count));\r\n    // fuzz the timeout randomly, to avoid reconnect storms when a\r\n    // server goes down.\r\n    timeout = timeout * ((Random.fraction() * self.fuzz) +\r\n                         (1 - self.fuzz/2));\r\n    return timeout;\r\n  },\r\n\r\n  // Call `fn` after a delay, based on the `count` of which retry this is.\r\n  retryLater: function (count, fn) {\r\n    var self = this;\r\n    var timeout = self._timeout(count);\r\n    if (self.retryTimer)\r\n      clearTimeout(self.retryTimer);\r\n    self.retryTimer = Meteor.setTimeout(fn, timeout);\r\n    return timeout;\r\n  }\r\n\r\n});\r\n"]}