{"version":3,"file":"\\packages\\follower-livedata.js","sources":["follower-livedata/follower.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,2B;AACA,0C;;;AAGA,iD;;AAEA,G;AACA,gF;AACA,+E;AACA,uD;AACA,E;AACA,a;AACA,+F;AACA,I;AACA,E;AACA,6E;AACA,yB;AACA,E;AACA,6E;AACA,wD;AACA,E;AACA,+E;AACA,qE;AACA,G;AACA,Y;AACA,uC;AACA,qB;AACA,wB;AACA,yC;AACA,gB;AACA,yD;;AAEA,8C;;AAEA,wB;AACA,uC;AACA,+E;AACA,O;AACA,qC;AACA,8B;AACA,S;AACA,M;;AAEA,6B;;AAEA,yB;AACA,yC;AACA,oB;AACA,6B;AACA,8B;AACA,yB;AACA,sB;AACA,2B;AACA,8B;;;AAGA,+E;AACA,8B;AACA,kD;;AAEA,qB;AACA,2B;AACA,4B;;AAEA,uC;AACA,sB;AACA,4B;AACA,sD;AACA,0B;AACA,sB;AACA,+B;AACA,S;AACA,S;AACA,6B;AACA,4D;AACA,oB;AACA,qD;AACA,O;AACA,wB;AACA,M;;AAEA,2C;AACA,0B;AACA,wB;AACA,iD;AACA,uF;AACA,S;AACA,M;;AAEA,qC;AACA,sB;AACA,kC;AACA,O;AACA,qC;AACA,oF;;AAEA,8E;AACA,kC;AACA,qC;AACA,O;;AAEA,iB;AACA,oC;AACA,kB;AACA,Y;AACA,c;AACA,yC;AACA,uC;AACA,yC;AACA,+B;AACA,O;AACA,sB;;AAEA,sC;AACA,wC;AACA,uE;AACA,2C;AACA,kC;AACA,oB;AACA,yB;AACA,mB;AACA,W;AACA,yD;AACA,0F;AACA,W;AACA,2B;AACA,0D;AACA,mD;AACA,W;AACA,0C;AACA,gC;;AAEA,2C;AACA,0B;AACA,uB;AACA,6B;AACA,2B;AACA,4D;AACA,a;AACA,kB;AACA,iE;AACA,8B;AACA,gD;AACA,qC;AACA,oB;AACA,4E;AACA,gD;AACA,a;;AAEA,W;AACA,gC;AACA,W;AACA,O;;AAEA,M;;AAEA,iB;;AAEA,uC;AACA,2E;AACA,qB;AACA,c;AACA,uE;AACA,oB;AACA,wC;AACA,yB;AACA,6C;AACA,uF;AACA,kC;AACA,mC;AACA,kB;AACA,4D;AACA,qD;AACA,a;AACA,2D;AACA,kC;AACA,W;AACA,W;AACA,O;AACA,M;;AAEA,yC;AACA,mE;AACA,M;;AAEA,yC;;AAEA,mC;AACA,yB;AACA,6C;AACA,4B;AACA,iC;AACA,M;;AAEA,kC;AACA,0B;AACA,6C;AACA,6C;AACA,2C;AACA,qB;AACA,c;AACA,6C;AACA,O;AACA,M;;AAEA,+B;AACA,4C;AACA,M;;AAEA,8B;AACA,0B;AACA,M;;;AAGA,+E;AACA,wE;AACA,wB;AACA,6C;AACA,sC;AACA,sD;AACA,6E;AACA,kC;AACA,4C;AACA,6C;AACA,W;AACA,4E;AACA,c;AACA,0C;AACA,2C;AACA,O;AACA,M;;AAEA,uC;AACA,mC;AACA,M;;AAEA,wC;AACA,oC;AACA,M;;AAEA,gB;AACA,G;;AAEA,E","sourcesContent":["var fs = Npm.require('fs');\r\nvar Future = Npm.require('fibers/future');\r\n\r\n\r\nvar MONITOR_INTERVAL = 5*1000; // every 5 seconds\r\n\r\n/**\r\n * Follower.connect() replaces DDP.connect() for connecting to DDP services that\r\n * implement a leadership set.  The follower connection tries to keep connected\r\n * to the leader, and fails over as the leader changes.\r\n *\r\n * Options: {\r\n * group: The name of the leadership group to connect to.  Default \"package.leadershipLivedata\"\r\n * }\r\n *\r\n * A Follower connection implements the following interfaces over and above a\r\n * normal DDP connection:\r\n *\r\n * onLost(callback): calls callback when the library considers itself to have\r\n * tried all its known options for the leadership group.\r\n *\r\n * onFound(callback): Called when the follower was previously lost, but has now\r\n * successfully connected to something in the right leadership group.\r\n */\r\nFollower = {\r\n  connect: function (urlSet, options) {\r\n    var electorTries;\r\n    options = _.extend({\r\n      group: \"package.leadershipLivedata\"\r\n    }, options);\r\n    // start each elector as untried/assumed connectable.\r\n\r\n    var makeElectorTries = function (urlSet) {\r\n\r\n      electorTries = {};\r\n      if (typeof urlSet === 'string') {\r\n        urlSet = _.map(urlSet.split(','), function (url) {return url.trim();});\r\n      }\r\n      _.each(urlSet, function (url) {\r\n        electorTries[url] = 0;\r\n      });\r\n    };\r\n\r\n    makeElectorTries(urlSet);\r\n\r\n    var tryingUrl = null;\r\n    var outstandingGetElectorate = false;\r\n    var conn = null;\r\n    var prevReconnect = null;\r\n    var prevDisconnect = null;\r\n    var prevApply = null;\r\n    var leader = null;\r\n    var connectedTo = null;\r\n    var intervalHandle = null;\r\n\r\n\r\n    // Used to defer all method calls until we're sure that we connected to the\r\n    // right leadership group.\r\n    var connectedToLeadershipGroup = new Future();\r\n\r\n    var lost = false;\r\n    var lostCallbacks = [];\r\n    var foundCallbacks = [];\r\n\r\n    var findFewestTries = function () {\r\n      var min = 10000;\r\n      var minElector = null;\r\n      _.each(electorTries, function (tries, elector) {\r\n        if (tries < min) {\r\n          min = tries;\r\n          minElector = elector;\r\n        }\r\n      });\r\n      if (min > 1 && !lost) {\r\n        // we've tried everything once; we just became lost.\r\n        lost = true;\r\n        _.each(lostCallbacks, function (f) { f(); });\r\n      }\r\n      return minElector;\r\n    };\r\n\r\n    var updateElectorate = function (res) {\r\n      leader = res.leader;\r\n      electorTries = {};\r\n      _.each(res.electorate, function (elector) {\r\n        electorTries[elector] = 0; // verified that this is in the current elector set.\r\n      });\r\n    };\r\n\r\n    var tryElector = function (url) {\r\n      if (tryingUrl) {\r\n        electorTries[tryingUrl]++;\r\n      }\r\n      url = url || findFewestTries();\r\n      //console.log(\"trying\", url, electorTries, tryingUrl, process.env.GALAXY_JOB);\r\n\r\n      // Don't keep trying the same url as fast as we can if it's not working.\r\n      if (electorTries[url] > 2) {\r\n        Meteor._sleepForMs(3 * 1000);\r\n      }\r\n\r\n      if (conn) {\r\n        prevReconnect.apply(conn, [{\r\n          url: url\r\n        }]);\r\n      } else {\r\n        conn = DDP.connect(url, options);\r\n        prevReconnect = conn.reconnect;\r\n        prevDisconnect = conn.disconnect;\r\n        prevApply = conn.apply;\r\n      }\r\n      tryingUrl = url;\r\n\r\n      if (!outstandingGetElectorate) {\r\n        outstandingGetElectorate = true;\r\n        conn.call('getElectorate', options.group, function (err, res) {\r\n          outstandingGetElectorate = false;\r\n          connectedTo = tryingUrl;\r\n          if (err) {\r\n            tryElector();\r\n            return;\r\n          }\r\n          if (!_.contains(res.electorate, connectedTo)) {\r\n            Log.warn(\"electorate \" + res.electorate + \" does not contain \" + connectedTo);\r\n          }\r\n          tryingUrl = null;\r\n          if (! connectedToLeadershipGroup.isResolved()) {\r\n            connectedToLeadershipGroup[\"return\"]();\r\n          }\r\n          // we got an answer!  Connected!\r\n          electorTries[url] = 0;\r\n\r\n          if (res.leader === connectedTo) {\r\n            // we're good.\r\n            if (lost) {\r\n              // we're found.\r\n              lost = false;\r\n              _.each(foundCallbacks, function (f) { f(); });\r\n            }\r\n          } else {\r\n            // let's connect to the leader anyway, if we think it\r\n            // is connectable.\r\n            if (electorTries[res.leader] == 0) {\r\n              tryElector(res.leader);\r\n            } else {\r\n              // XXX: leader is probably down, we're probably going to elect\r\n              // soon.  Wait for the next round.\r\n            }\r\n\r\n          }\r\n          updateElectorate(res);\r\n        });\r\n      }\r\n\r\n    };\r\n\r\n    tryElector();\r\n\r\n    var checkConnection = function () {\r\n      if (conn.status().status !== 'connected' || connectedTo !== leader) {\r\n        tryElector();\r\n      } else {\r\n        conn.call('getElectorate', options.group, function (err, res) {\r\n          if (err) {\r\n            electorTries[connectedTo]++;\r\n            tryElector();\r\n          } else if (res.leader !== leader) {\r\n            // update the electorate, and then definitely try to connect to the leader.\r\n            updateElectorate(res);\r\n            tryElector(res.leader);\r\n          } else {\r\n            if (! connectedToLeadershipGroup.isResolved()) {\r\n              connectedToLeadershipGroup[\"return\"]();\r\n            }\r\n            //console.log(\"updating electorate with\", res);\r\n            updateElectorate(res);\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    var monitorConnection = function () {\r\n      return Meteor.setInterval(checkConnection, MONITOR_INTERVAL);\r\n    };\r\n\r\n    intervalHandle = monitorConnection();\r\n\r\n    conn.disconnect = function () {\r\n      if (intervalHandle)\r\n        Meteor.clearInterval(intervalHandle);\r\n      intervalHandle = null;\r\n      prevDisconnect.apply(conn);\r\n    };\r\n\r\n    conn.reconnect = function () {\r\n      if (!intervalHandle)\r\n        intervalHandle = monitorConnection();\r\n      if (arguments[0] && arguments[0].url) {\r\n        makeElectorTries(arguments[0].url);\r\n        tryElector();\r\n      } else {\r\n        prevReconnect.apply(conn, arguments);\r\n      }\r\n    };\r\n\r\n    conn.getUrl = function () {\r\n      return _.keys(electorTries).join(',');\r\n    };\r\n\r\n    conn.tries = function () {\r\n      return electorTries;\r\n    };\r\n\r\n\r\n    // Assumes that `call` is implemented in terms of `apply`. All method calls\r\n    // should be deferred until we are sure we've connected to the right\r\n    // leadership group.\r\n    conn.apply = function (/* arguments */) {\r\n      var args = _.toArray(arguments);\r\n      if (typeof args[args.length-1] === 'function') {\r\n        // this needs to be independent of this fiber if there is a callback.\r\n        Meteor.defer(function () {\r\n          connectedToLeadershipGroup.wait();\r\n          return prevApply.apply(conn, args);\r\n        });\r\n        return null; // if there is a callback, the return value is not used\r\n      } else {\r\n        connectedToLeadershipGroup.wait();\r\n        return prevApply.apply(conn, args);\r\n      }\r\n    };\r\n\r\n    conn.onLost = function (callback) {\r\n      lostCallbacks.push(callback);\r\n    };\r\n\r\n    conn.onFound = function (callback) {\r\n      foundCallbacks.push(callback);\r\n    };\r\n\r\n    return conn;\r\n  }\r\n\r\n};\r\n"]}