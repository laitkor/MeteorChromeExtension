{"version":3,"file":"\\packages\\ctl.js","sources":["ctl/ctl.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,0C;;AAEA,mB;AACA,e;AACA,yB;AACA,oC;AACA,kB;AACA,oC;AACA,qB;;AAEA,oC;AACA,G;AACA,G;;AAEA,gC;AACA,yC;AACA,yB;AACA,4B;AACA,c;AACA,gF;AACA,oB;AACA,M;AACA,oB;AACA,G;AACA,0C;AACA,kC;AACA,4C;AACA,gD;AACA,kC;AACA,6D;AACA,uE;AACA,G;AACA,0D;AACA,+D;AACA,E;;AAEA,mB;AACA,gB;AACA,yB;AACA,gB;AACA,G;;;AAGA,mB;AACA,oB;AACA,0C;AACA,gB;AACA,G;;AAEA,gC;AACA,yC;AACA,yB;AACA,2B;AACA,c;AACA,4E;AACA,8B;AACA,M;AACA,oB;AACA,G;;AAEA,2E;AACA,oB;AACA,8B;AACA,+D;AACA,+B;AACA,4B;AACA,kC;AACA,a;AACA,sB;AACA,iB;AACA,a;AACA,mC;AACA,K;AACA,iC;AACA,E;;AAEA,mB;AACA,e;AACA,wB;AACA,e;AACA,G;;AAEA,mD;AACA,yB;AACA,oB;AACA,O;AACA,yD;AACA,6B;AACA,qB;AACA,qB;AACA,0B;AACA,Q;AACA,+B;AACA,qB;AACA,0B;AACA,Q;AACA,+B;AACA,wB;AACA,O;AACA,O;AACA,iE;AACA,e;AACA,sB;AACA,e;AACA,a;AACA,uB;AACA,G;AACA,E;;;AAGA,mB;AACA,sB;AACA,2C;AACA,yB;AACA,4C;AACA,oC;AACA,8C;AACA,4D;AACA,0B;AACA,2B;AACA,gC;AACA,wB;AACA,iB;AACA,M;AACA,uD;AACA,wC;AACA,8C;AACA,2B;AACA,yB;AACA,wB;AACA,iB;AACA,e;AACA,sD;AACA,mD;AACA,+E;AACA,6C;AACA,0C;AACA,gD;AACA,0D;AACA,O;AACA,0D;AACA,wC;AACA,uC;AACA,M;AACA,gF;AACA,+B;AACA,e;AACA,gC;AACA,W;AACA,iB;AACA,Y;AACA,W;AACA,iB;AACA,Y;AACA,W;AACA,iB;AACA,Y;AACA,Y;AACA,gC;AACA,iD;AACA,Y;AACA,K;AACA,8E;AACA,a;AACA,gF;;AAEA,uE;AACA,uD;AACA,iD;AACA,uB;AACA,wC;AACA,+B;AACA,uC;AACA,6E;AACA,+B;AACA,+C;AACA,K;AACA,iE;AACA,e;AACA,2B;AACA,gC;AACA,+B;AACA,iB;AACA,+B;AACA,qC;AACA,O;AACA,U;AACA,oB;AACA,G;AACA,G;;AAEA,wB;AACA,wB;AACA,E","sourcesContent":["var Future = Npm.require(\"fibers/future\");\r\n\r\nCtl.Commands.push({\r\n  name: \"help\",\r\n  func: function (argv) {\r\n    if (!argv._.length || argv.help)\r\n      Ctl.usage();\r\n    var cmd = argv._.splice(0,1)[0];\r\n    argv.help = true;\r\n\r\n    Ctl.findCommand(cmd).func(argv);\r\n  }\r\n});\r\n\r\nvar startFun = function (argv) {\r\n  if (argv.help || argv._.length !== 0) {\r\n    process.stderr.write(\r\n      \"Usage: ctl start\\n\" +\r\n        \"\\n\" +\r\n        \"Starts the app. For now, this just means that it runs the 'server'\\n\" +\r\n        \"program.\\n\"\r\n    );\r\n    process.exit(1);\r\n  }\r\n  Ctl.subscribeToAppJobs(Ctl.myAppName());\r\n  var jobs = Ctl.jobsCollection();\r\n  var thisJob = jobs.findOne(Ctl.myJobId());\r\n  Ctl.updateProxyActiveTags(['', thisJob.star]);\r\n  if (Ctl.hasProgram(\"console\")) {\r\n    console.log(\"starting console for app\", Ctl.myAppName());\r\n    Ctl.startServerlikeProgramIfNotPresent(\"console\", [\"admin\"], true);\r\n  }\r\n  console.log(\"starting server for app\", Ctl.myAppName());\r\n  Ctl.startServerlikeProgramIfNotPresent(\"server\", [\"runner\"]);\r\n};\r\n\r\nCtl.Commands.push({\r\n  name: \"start\",\r\n  help: \"Start this app\",\r\n  func: startFun\r\n});\r\n\r\n\r\nCtl.Commands.push({\r\n  name: \"endUpdate\",\r\n  help: \"Start this app to end an update\",\r\n  func: startFun\r\n});\r\n\r\nvar stopFun =  function (argv) {\r\n  if (argv.help || argv._.length !== 0) {\r\n    process.stderr.write(\r\n      \"Usage: ctl stop\\n\" +\r\n        \"\\n\" +\r\n        \"Stops the app. For now, this just means that it kills all jobs\\n\" +\r\n        \"other than itself.\\n\"\r\n    );\r\n    process.exit(1);\r\n  }\r\n\r\n  // Get all jobs (other than this job: don't commit suicide!) that are not\r\n  // already killed.\r\n  var jobs = Ctl.getJobsByApp(\r\n    Ctl.myAppName(), {_id: {$ne: Ctl.myJobId()}, done: false});\r\n  jobs.forEach(function (job) {\r\n    // Don't commit suicide.\r\n    if (job._id === Ctl.myJobId())\r\n      return;\r\n    // It's dead, Jim.\r\n    if (job.done)\r\n      return;\r\n    Ctl.kill(job.program, job._id);\r\n  });\r\n  console.log(\"Server stopped.\");\r\n};\r\n\r\nCtl.Commands.push({\r\n  name: \"stop\",\r\n  help: \"Stop this app\",\r\n  func: stopFun\r\n});\r\n\r\nvar waitForDone = function (jobCollection, jobId) {\r\n  var fut = new Future();\r\n  var found = false;\r\n  try {\r\n    var observation = jobCollection.find(jobId).observe({\r\n      added: function (doc) {\r\n        found = true;\r\n        if (doc.done)\r\n          fut['return']();\r\n      },\r\n      changed: function (doc) {\r\n        if (doc.done)\r\n          fut['return']();\r\n      },\r\n      removed: function (doc) {\r\n        fut['return']();\r\n      }\r\n    });\r\n    // if the document doesn't exist at all, it's certainly done.\r\n    if (!found)\r\n      fut['return']();\r\n    fut.wait();\r\n  } finally {\r\n    observation.stop();\r\n  }\r\n};\r\n\r\n\r\nCtl.Commands.push({\r\n  name: \"beginUpdate\",\r\n  help: \"Stop this app to begin an update\",\r\n  func: function (argv) {\r\n    Ctl.subscribeToAppJobs(Ctl.myAppName());\r\n    var jobs = Ctl.jobsCollection();\r\n    var thisJob = jobs.findOne(Ctl.myJobId());\r\n    // Look at all the server jobs that are on the old star.\r\n    var oldJobSelector = {\r\n      app: Ctl.myAppName(),\r\n      star: {$ne: thisJob.star},\r\n      program: \"server\",\r\n      done: false\r\n    };\r\n    var oldServers = jobs.find(oldJobSelector).fetch();\r\n    // Start a new job for each of them.\r\n    var newServersAlreadyPresent = jobs.find({\r\n      app: Ctl.myAppName(),\r\n      star: thisJob.star,\r\n      program: \"server\",\r\n      done: false\r\n    }).count();\r\n    // discount any new servers we've already started.\r\n    oldServers.splice(0, newServersAlreadyPresent);\r\n    console.log(\"starting \" + oldServers.length + \" new servers to match old\");\r\n    _.each(oldServers, function (oldServer) {\r\n      Ctl.startServerlikeProgram(\"server\",\r\n                                 oldServer.tags,\r\n                                 oldServer.env.ADMIN_APP);\r\n    });\r\n    // Wait for them all to come up and bind to the proxy.\r\n    var updateProxyActiveTagsOptions = {\r\n      requireRegisteredBindingCount: {}\r\n    };\r\n    // How many new servers should be up when we update the tags, given how many\r\n    // servers we're aiming at:\r\n    var target;\r\n    switch (oldServers.length) {\r\n    case 0:\r\n      target = 0;\r\n      break;\r\n    case 1:\r\n      target = 1;\r\n      break;\r\n    case 2:\r\n      target = 1;\r\n      break;\r\n    default:\r\n      var c = oldServers.length;\r\n      target =  Math.min(c - 1, Math.ceil(c*.8));\r\n      break;\r\n    }\r\n    updateProxyActiveTagsOptions.requireRegisteredBindingCount[thisJob.star] =\r\n      target;\r\n    Ctl.updateProxyActiveTags(['', thisJob.star], updateProxyActiveTagsOptions);\r\n\r\n    // (eventually) tell the proxy to switch over to using the new star\r\n    // One by one, kill all the old star's server jobs.\r\n    var jobToKill = jobs.findOne(oldJobSelector);\r\n    while (jobToKill) {\r\n      Ctl.kill(\"server\", jobToKill._id);\r\n      // Wait for it to go down\r\n      waitForDone(jobs, jobToKill._id);\r\n      // Spend some time in between to allow any reconnect storm to die down.\r\n      Meteor._sleepForMs(5000);\r\n      jobToKill = jobs.findOne(oldJobSelector);\r\n    }\r\n    // Now kill all old non-server jobs.  They're less important.\r\n    jobs.find({\r\n      app: Ctl.myAppName(),\r\n      star: {$ne: thisJob.star},\r\n      program: {$ne: \"server\"},\r\n      done: false\r\n    }).forEach(function (job) {\r\n      Ctl.kill(job.program, job._id);\r\n    });\r\n    // fin\r\n    process.exit(0);\r\n  }\r\n});\r\n\r\nmain = function (argv) {\r\n  return Ctl.main(argv);\r\n};\r\n"]}