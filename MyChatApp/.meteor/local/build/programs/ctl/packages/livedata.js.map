{"version":3,"file":"\\packages\\livedata.js","sources":["livedata/common.js","livedata/stream_client_nodejs.js","livedata/stream_client_common.js","livedata/stream_server.js","livedata/heartbeat.js","livedata/livedata_server.js","livedata/writefence.js","livedata/crossbar.js","livedata/livedata_common.js","livedata/random_stream.js","livedata/livedata_connection.js","livedata/server_convenience.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kB;;;;;;;;;;;;;;;;;;;ACAA,6C;AACA,6C;AACA,4C;AACA,E;AACA,6E;AACA,gF;AACA,kB;AACA,E;AACA,gF;AACA,6E;AACA,2C;AACA,0D;AACA,kB;AACA,0B;;AAEA,2B;AACA,e;AACA,c;;AAEA,sD;AACA,2B;;AAEA,4C;;AAEA,qB;;AAEA,e;AACA,2B;AACA,E;;AAEA,+C;;AAEA,uE;AACA,oE;AACA,wB;AACA,yB;AACA,oB;AACA,uC;AACA,6B;AACA,K;AACA,I;;AAEA,yC;AACA,8B;AACA,oB;AACA,wB;AACA,I;;AAEA,iC;AACA,oB;;AAEA,iC;AACA,wE;AACA,gF;AACA,0E;AACA,sB;AACA,uD;AACA,K;;AAEA,mC;AACA,8E;AACA,qE;AACA,0B;AACA,yB;AACA,a;AACA,K;;AAEA,uC;AACA,yE;AACA,uE;AACA,gF;AACA,gF;AACA,sC;AACA,mD;AACA,K;;AAEA,iC;;AAEA,oB;AACA,4C;AACA,wC;AACA,sC;AACA,yB;;AAEA,sE;AACA,kD;AACA,2E;AACA,I;;AAEA,yB;AACA,oB;;AAEA,iC;AACA,sB;AACA,+B;AACA,yB;AACA,qB;AACA,K;;AAEA,gF;AACA,I;;AAEA,sC;AACA,oB;;AAEA,+B;AACA,yC;AACA,kC;AACA,K;AACA,I;;AAEA,kC;AACA,oB;AACA,iE;;AAEA,2E;AACA,kE;AACA,kB;AACA,sD;;AAEA,gF;AACA,uE;AACA,6E;AACA,6E;AACA,yE;AACA,wD;AACA,oC;AACA,4B;AACA,6B;AACA,M;;AAEA,iC;AACA,6C;AACA,yC;AACA,4B;;AAEA,+D;AACA,qC;AACA,mC;;AAEA,8D;AACA,gE;AACA,sE;AACA,mC;AACA,iB;AACA,iC;AACA,uB;AACA,M;;AAEA,0E;AACA,yC;AACA,qD;;AAEA,+E;AACA,kB;AACA,6B;AACA,O;;;AAGA,qE;AACA,6B;AACA,O;;;AAGA,gF;AACA,6D;AACA,2C;AACA,e;;AAEA,+D;AACA,+B;AACA,S;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC9KA,0E;AACA,wC;AACA,uC;AACA,+C;AACA,E;AACA,oC;AACA,qC;AACA,qD;AACA,E;;AAEA,6C;AACA,6D;AACA,sD;AACA,mF;AACA,yC;AACA,sD;AACA,iD;AACA,2D;AACA,wB;AACA,2B;AACA,G;;AAEA,uD;AACA,iD;AACA,gB;AACA,oB;AACA,4C;AACA,wD;AACA,6E;AACA,4C;AACA,c;AACA,0E;AACA,mE;;AAEA,0E;AACA,4E;AACA,wD;AACA,4C;AACA,8C;AACA,O;;AAEA,2C;AACA,4B;AACA,uE;AACA,0D;AACA,2C;AACA,G;;AAEA,uC;AACA,2D;AACA,sC;AACA,G;;AAEA,8D;AACA,sE;AACA,kE;AACA,sE;AACA,+B;AACA,I;AACA,kE;AACA,sE;AACA,iE;AACA,uE;AACA,2C;;AAEA,yB;AACA,yB;AACA,M;AACA,+B;AACA,E;;AAEA,8B;AACA,6C;AACA,E;;AAEA,iC;AACA,iD;AACA,a;AACA,E;;AAEA,uC;;;AAGA,+C;;AAEA,4B;AACA,iC;AACA,oB;;AAEA,wE;AACA,qD;;AAEA,mC;AACA,qC;AACA,6C;AACA,I;;;AAGA,4B;AACA,oB;AACA,kB;;AAEA,+D;AACA,c;AACA,iC;;AAEA,mD;;AAEA,qC;;AAEA,wB;AACA,0B;AACA,2B;AACA,uB;AACA,mB;AACA,M;;;AAGA,8E;AACA,sC;AACA,+B;AACA,uC;AACA,M;;AAEA,oB;AACA,4B;AACA,gC;;AAEA,I;;AAEA,yB;AACA,iC;AACA,oB;AACA,4B;;AAEA,sB;AACA,mC;AACA,K;;AAEA,iC;AACA,2D;AACA,K;;AAEA,uC;AACA,0C;AACA,2B;AACA,+B;AACA,sB;AACA,a;AACA,K;;AAEA,wC;AACA,qD;AACA,6B;AACA,K;;AAEA,wB;AACA,qE;AACA,qB;AACA,I;;AAEA,kC;AACA,oB;AACA,4B;;AAEA,qE;AACA,uD;AACA,iC;AACA,a;;AAEA,2E;AACA,mE;AACA,mE;AACA,6B;AACA,6B;AACA,sC;AACA,K;;AAEA,oB;AACA,wB;;AAEA,0B;AACA,0D;AACA,uB;AACA,mB;AACA,M;;AAEA,6C;AACA,iD;;AAEA,yB;AACA,I;;AAEA,gC;AACA,oB;;AAEA,oB;AACA,8D;AACA,I;;AAEA,kE;AACA,iB;AACA,wB;AACA,0E;AACA,+C;AACA,uB;AACA,I;;AAEA,4B;AACA,oB;;AAEA,oB;AACA,6B;AACA,uC;AACA,sC;AACA,oC;AACA,Q;AACA,K;;AAEA,0C;AACA,yC;AACA,oE;AACA,yB;AACA,I;;AAEA,0B;AACA,oB;;AAEA,iC;AACA,a;;AAEA,uC;AACA,6C;AACA,yC;AACA,wC;AACA,yB;;AAEA,6B;AACA,I;;;AAGA,kC;AACA,uB;AACA,oB;AACA,6B;AACA,oC;AACA,8B;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACxPA,6B;;AAEA,uE;;AAEA,4B;AACA,kB;AACA,mC;AACA,yB;;AAEA,+E;AACA,8D;AACA,uC;AACA,6E;AACA,iD;AACA,4B;AACA,0E;AACA,G;;AAEA,kB;AACA,qC;AACA,uB;AACA,wB;AACA,uB;AACA,uE;AACA,+C;AACA,2B;AACA,+E;AACA,0E;AACA,6E;AACA,4E;AACA,+E;AACA,8D;AACA,gC;AACA,wE;AACA,oE;AACA,wB;AACA,4C;AACA,I;;AAEA,8E;AACA,uE;AACA,0D;AACA,yD;AACA,qC;AACA,oC;;AAEA,mD;AACA,wB;AACA,6E;AACA,G;AACA,+E;AACA,4E;AACA,8E;AACA,kC;AACA,sH;AACA,gE;AACA,mH;;AAEA,qE;AACA,iD;AACA,mB;AACA,O;AACA,K;;AAEA,oC;AACA,oC;;AAEA,kD;;AAEA,uD;AACA,+E;AACA,+E;AACA,gE;AACA,4C;AACA,gD;AACA,uB;AACA,e;AACA,O;AACA,K;;AAEA,mC;AACA,yB;AACA,M;AACA,oC;AACA,+D;AACA,O;AACA,mC;;AAEA,uE;AACA,mE;AACA,uE;AACA,uE;AACA,+B;AACA,kD;;AAEA,wE;AACA,kE;AACA,6D;AACA,uB;AACA,O;AACA,K;;AAEA,E;;AAEA,kC;AACA,iD;AACA,8C;AACA,iC;AACA,oB;AACA,+C;AACA,kD;AACA,uB;AACA,O;AACA,I;;AAEA,8B;AACA,4B;AACA,oB;AACA,uC;AACA,I;;AAEA,oE;AACA,sD;AACA,0C;AACA,oB;AACA,iE;AACA,6D;AACA,oE;AACA,oD;AACA,2G;AACA,oD;AACA,wD;AACA,wE;AACA,2C;;AAEA,gE;AACA,iE;AACA,gE;AACA,2D;AACA,6B;;AAEA,6E;AACA,mC;AACA,+C;AACA,+D;AACA,gE;AACA,0D;AACA,8C;AACA,S;AACA,8D;AACA,8C;AACA,W;AACA,Q;AACA,iD;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC5JA,qB;AACA,gE;AACA,uE;AACA,iC;AACA,iE;AACA,yD;;AAEA,gC;AACA,kB;;AAEA,qD;AACA,mD;AACA,oC;AACA,sC;;AAEA,uC;AACA,sC;AACA,E;;AAEA,+B;AACA,qB;AACA,oB;AACA,wC;AACA,uC;AACA,I;;AAEA,sB;AACA,oB;AACA,gB;AACA,wC;AACA,I;;AAEA,6C;AACA,oB;AACA,sD;AACA,iD;AACA,4B;AACA,M;AACA,I;;AAEA,4C;AACA,oB;AACA,qD;AACA,gD;AACA,2B;AACA,M;AACA,I;;AAEA,6C;AACA,oB;AACA,wC;AACA,yD;AACA,2C;AACA,K;AACA,I;;AAEA,4C;AACA,oB;AACA,uC;AACA,wD;AACA,0C;AACA,K;AACA,I;;AAEA,sE;AACA,wC;AACA,oB;AACA,yC;AACA,qB;AACA,uB;AACA,uC;AACA,I;;AAEA,qE;AACA,oC;AACA,uC;AACA,oB;AACA,wC;AACA,sB;AACA,I;;AAEA,6B;AACA,oB;AACA,kE;AACA,sE;AACA,wC;AACA,0C;AACA,0C;AACA,K;AACA,I;;AAEA,6B;AACA,oB;;AAEA,oE;AACA,0C;AACA,uC;AACA,yC;AACA,0C;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACrGA,e;;AAEA,kC;;AAEA,8B;AACA,6D;AACA,6D;AACA,2E;AACA,E;AACA,oE;AACA,qE;AACA,a;;AAEA,0D;AACA,uC;AACA,kB;AACA,kD;AACA,4E;AACA,E;;AAEA,yC;;AAEA,0B;AACA,oB;AACA,iB;AACA,2D;AACA,yC;AACA,O;AACA,e;AACA,I;;AAEA,mE;AACA,oB;AACA,mD;AACA,sB;AACA,a;AACA,6C;;AAEA,oE;AACA,gB;AACA,wB;AACA,a;;AAEA,iC;AACA,qD;AACA,yC;AACA,iE;AACA,gF;AACA,mC;AACA,oB;AACA,0C;AACA,oC;AACA,c;AACA,O;AACA,K;AACA,oC;AACA,iC;AACA,uC;AACA,4C;AACA,sE;AACA,qD;AACA,K;AACA,I;;AAEA,wD;AACA,kD;AACA,oB;AACA,mD;AACA,sB;AACA,a;;AAEA,6D;AACA,+B;;AAEA,sC;AACA,qE;AACA,6C;AACA,mC;AACA,a;AACA,K;AACA,6C;AACA,Y;AACA,iB;AACA,0D;AACA,oE;AACA,S;AACA,K;;AAEA,c;AACA,yE;AACA,iE;AACA,qC;AACA,O;AACA,wB;AACA,Y;AACA,2D;AACA,kF;AACA,K;;AAEA,G;AACA,G;;AAEA,oD;AACA,yE;AACA,kB;AACA,uC;AACA,sB;AACA,oC;AACA,E;;AAEA,2D;;;AAGA,2C;;AAEA,wB;AACA,oB;AACA,qC;AACA,I;;AAEA,6B;AACA,oB;AACA,sE;AACA,4C;;AAEA,uC;AACA,yE;AACA,Q;;AAEA,uC;AACA,wD;AACA,O;AACA,O;AACA,I;;AAEA,8C;AACA,oB;AACA,oB;AACA,yE;AACA,uC;AACA,qC;AACA,4B;AACA,Q;AACA,sC;AACA,0B;AACA,Q;AACA,qC;AACA,gC;AACA,O;AACA,O;AACA,4D;AACA,I;;AAEA,oD;AACA,oB;AACA,qC;AACA,sB;AACA,mB;AACA,mB;AACA,0C;AACA,mC;AACA,K;AACA,gD;AACA,6B;AACA,0C;AACA,0B;AACA,+D;AACA,O;AACA,c;AACA,qE;AACA,Q;AACA,uE;AACA,I;;AAEA,uD;AACA,oB;AACA,2B;AACA,qC;AACA,iB;AACA,6E;AACA,2C;AACA,8B;AACA,mE;AACA,U;AACA,2E;AACA,O;AACA,mE;AACA,I;;AAEA,8C;AACA,oB;AACA,qC;AACA,mB;AACA,gE;AACA,gB;AACA,K;AACA,gD;AACA,sC;AACA,iC;AACA,sD;AACA,gC;AACA,Y;AACA,uB;AACA,4D;AACA,+B;AACA,gE;AACA,6D;AACA,S;;AAEA,+D;AACA,K;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,2D;AACA,kB;AACA,wB;;AAEA,uB;AACA,yB;;AAEA,2B;AACA,uB;;AAEA,qE;AACA,0D;AACA,oB;;AAEA,uB;AACA,6B;;AAEA,yC;AACA,uB;AACA,2B;;AAEA,qB;;AAEA,4B;;AAEA,oE;AACA,gF;AACA,uC;AACA,yB;;AAEA,6E;AACA,yE;AACA,0C;;AAEA,4D;AACA,sE;AACA,0B;;AAEA,8D;AACA,4B;;;AAGA,gE;AACA,mD;AACA,+B;;AAEA,gD;AACA,gD;;AAEA,sE;AACA,sE;AACA,6C;AACA,2B;AACA,gB;AACA,wB;AACA,mB;AACA,M;AACA,4B;AACA,yE;AACA,yB;AACA,sC;AACA,c;AACA,sD;AACA,yB;AACA,O;AACA,M;AACA,yC;AACA,oC;AACA,I;;AAEA,6C;AACA,gD;AACA,8D;AACA,qB;AACA,8B;AACA,W;;AAEA,8D;AACA,oC;AACA,mD;AACA,iD;AACA,8B;AACA,qB;AACA,Q;AACA,6B;AACA,iC;AACA,O;AACA,O;AACA,2B;AACA,G;;AAEA,2D;AACA,+B;AACA,E;;AAEA,6B;;AAEA,yC;AACA,oB;AACA,wB;AACA,uD;AACA,U;AACA,yD;AACA,gD;AACA,S;AACA,K;AACA,I;;AAEA,oD;AACA,oB;AACA,wB;AACA,oF;AACA,I;;AAEA,sD;AACA,oB;AACA,0B;AACA,a;;AAEA,0B;AACA,iB;AACA,uB;AACA,mC;AACA,e;AACA,sB;AACA,S;AACA,K;AACA,I;;AAEA,8C;AACA,oB;AACA,wB;AACA,sE;AACA,I;;AAEA,iC;AACA,oB;AACA,Y;AACA,0C;AACA,8C;AACA,6C;AACA,M;AACA,I;;AAEA,gD;AACA,oB;AACA,sD;AACA,kD;AACA,K;AACA,uD;AACA,iE;AACA,+C;AACA,e;AACA,I;;AAEA,oE;AACA,oB;AACA,sD;AACA,+C;AACA,I;;AAEA,8D;AACA,oB;AACA,sD;AACA,yC;AACA,yB;AACA,kD;AACA,K;AACA,I;;AAEA,sE;AACA,oB;AACA,sD;AACA,iD;AACA,I;;AAEA,mC;AACA,oB;AACA,8E;AACA,6E;AACA,qE;AACA,mE;AACA,yC;AACA,uC;AACA,O;AACA,I;;AAEA,0D;AACA,sB;AACA,oB;;AAEA,+D;AACA,wE;AACA,8B;;AAEA,yB;AACA,uB;AACA,a;;AAEA,yB;AACA,4B;AACA,4B;AACA,K;;AAEA,sB;AACA,0B;AACA,wC;AACA,K;;AAEA,2C;AACA,8B;AACA,wB;;AAEA,6D;AACA,kC;;AAEA,8B;AACA,6D;AACA,qE;AACA,gF;AACA,yC;;AAEA,sE;AACA,qE;AACA,wD;AACA,mB;AACA,S;AACA,O;;AAEA,8B;AACA,qC;AACA,I;;AAEA,wE;AACA,yD;AACA,wB;AACA,oB;AACA,sB;AACA,+B;AACA,qD;AACA,0C;AACA,K;AACA,I;;AAEA,6B;AACA,kD;AACA,oB;AACA,6C;AACA,yB;AACA,8C;AACA,mB;AACA,I;;AAEA,kE;AACA,+D;AACA,qD;AACA,I;AACA,oE;AACA,qE;AACA,oE;AACA,sE;AACA,mE;AACA,qB;AACA,I;AACA,oE;AACA,oE;AACA,oE;AACA,Y;AACA,qC;AACA,oB;AACA,iD;AACA,a;;AAEA,qE;AACA,mE;AACA,oE;AACA,yC;AACA,M;AACA,wE;AACA,wE;AACA,qE;AACA,gD;AACA,2D;AACA,+B;AACA,gD;AACA,yB;AACA,2B;AACA,wC;AACA,iB;AACA,a;AACA,K;AACA,2D;AACA,yB;AACA,2B;AACA,wC;AACA,iB;AACA,a;AACA,K;;AAEA,8B;AACA,2B;AACA,a;AACA,8B;;AAEA,mC;AACA,qD;AACA,iB;AACA,mC;AACA,e;AACA,O;;AAEA,yB;AACA,2B;;AAEA,mC;AACA,uB;AACA,iC;AACA,0B;AACA,wB;AACA,U;;AAEA,mD;AACA,mE;AACA,Y;AACA,6C;AACA,8D;AACA,e;AACA,M;;AAEA,kB;AACA,I;;AAEA,sB;AACA,yB;AACA,sB;;AAEA,kC;AACA,yC;AACA,2C;AACA,kE;AACA,sD;AACA,e;AACA,O;;AAEA,oD;AACA,mB;AACA,mC;AACA,mE;AACA,e;AACA,O;;AAEA,yC;AACA,oE;AACA,gE;AACA,qB;AACA,e;;AAEA,2D;AACA,qE;;AAEA,M;;AAEA,2B;AACA,sB;;AAEA,qC;AACA,M;;AAEA,qC;AACA,sB;;AAEA,kC;AACA,wD;AACA,oC;AACA,yC;AACA,6C;AACA,kE;AACA,4E;AACA,2D;AACA,e;AACA,O;;AAEA,8C;;AAEA,kE;AACA,iE;AACA,c;AACA,4C;AACA,wC;AACA,8D;AACA,gE;AACA,6D;AACA,4D;AACA,gD;AACA,uB;AACA,mB;AACA,8C;AACA,S;;AAEA,yB;AACA,4D;AACA,qB;AACA,mB;AACA,oC;AACA,6D;AACA,oB;AACA,e;AACA,O;;AAEA,wC;AACA,gC;AACA,Q;;AAEA,6C;AACA,4B;AACA,4B;AACA,6B;AACA,yB;AACA,0C;AACA,8B;AACA,S;AACA,W;AACA,gF;AACA,2E;AACA,4C;AACA,+E;AACA,a;AACA,W;AACA,mB;AACA,0B;AACA,O;;AAEA,2D;AACA,iE;;AAEA,wC;AACA,iE;;AAEA,uC;AACA,mB;AACA,gE;AACA,iE;AACA,gE;AACA,K;AACA,I;;AAEA,0B;AACA,oB;AACA,+B;AACA,mC;AACA,I;;AAEA,8C;AACA,oB;AACA,mE;AACA,8D;AACA,mC;AACA,Q;AACA,wD;AACA,6D;AACA,kE;AACA,W;AACA,Q;AACA,sD;AACA,wD;AACA,+C;AACA,W;AACA,O;AACA,O;AACA,I;;AAEA,oE;AACA,sB;AACA,gC;AACA,oB;;AAEA,sD;AACA,0E;AACA,qC;;AAEA,4E;AACA,yE;AACA,M;AACA,6E;AACA,0E;AACA,8E;AACA,+E;AACA,+B;AACA,2C;;AAEA,4E;AACA,sC;AACA,kC;AACA,wB;AACA,O;;AAEA,+E;AACA,+E;AACA,yB;AACA,4B;AACA,yC;AACA,8B;AACA,yB;;AAEA,qE;AACA,uC;AACA,yB;AACA,6B;;AAEA,yD;AACA,wD;AACA,yE;AACA,0D;AACA,oD;AACA,O;;AAEA,4E;AACA,2E;AACA,Y;AACA,4C;AACA,8B;;AAEA,8E;AACA,4E;AACA,0D;AACA,yC;AACA,6B;AACA,2C;AACA,2C;AACA,2C;AACA,gC;AACA,O;AACA,O;AACA,I;;AAEA,+D;AACA,oB;;AAEA,+B;AACA,0C;AACA,c;AACA,mC;AACA,Q;AACA,oC;;AAEA,sB;AACA,I;;AAEA,qC;AACA,8C;AACA,oB;;AAEA,0C;AACA,mD;AACA,2C;AACA,oC;AACA,K;;AAEA,6C;;AAEA,c;AACA,yE;;AAEA,wB;AACA,I;;AAEA,+E;AACA,kD;AACA,4C;AACA,oB;;AAEA,gD;AACA,wB;AACA,O;AACA,yB;;AAEA,gD;AACA,wB;AACA,O;AACA,6B;AACA,I;;AAEA,2D;AACA,oE;AACA,kC;AACA,+B;AACA,oB;;AAEA,sE;AACA,kE;AACA,kE;AACA,sE;AACA,kC;AACA,M;AACA,oE;AACA,gF;;AAEA,iC;AACA,uC;;AAEA,8D;AACA,mC;AACA,kB;AACA,wD;;AAEA,mE;AACA,oE;AACA,oE;AACA,qE;AACA,kE;AACA,qE;AACA,kE;AACA,qC;;AAEA,2E;AACA,kB;;AAEA,kE;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,4D;AACA,6B;AACA,qD;AACA,kB;AACA,6C;AACA,kE;;AAEA,0B;;AAEA,4E;AACA,wC;AACA,iC;AACA,oB;;AAEA,8B;;AAEA,uE;AACA,yD;AACA,mE;AACA,6B;AACA,0D;AACA,U;AACA,iD;AACA,G;;AAEA,iC;AACA,4B;;AAEA,+D;AACA,2B;;AAEA,mE;AACA,qB;AACA,uB;;AAEA,8B;AACA,sB;;AAEA,kD;AACA,+B;;AAEA,kD;AACA,mD;AACA,sD;;AAEA,kD;AACA,sD;AACA,wD;AACA,wC;;AAEA,oB;AACA,8C;AACA,qC;AACA,I;;AAEA,2D;AACA,oC;AACA,E;;AAEA,kC;AACA,4B;AACA,sE;AACA,kD;AACA,M;AACA,uE;AACA,wE;AACA,iE;;AAEA,oB;AACA,S;AACA,yC;AACA,uD;AACA,0E;AACA,kE;AACA,yC;AACA,0C;AACA,iB;AACA,oB;AACA,a;AACA,K;;AAEA,oD;AACA,8B;AACA,a;;AAEA,uE;AACA,0E;AACA,0E;AACA,gF;AACA,+D;AACA,M;AACA,0E;AACA,8E;AACA,8E;AACA,6C;AACA,iE;AACA,6C;AACA,4C;AACA,wC;AACA,c;AACA,W;AACA,iC;AACA,mC;AACA,M;AACA,wB;AACA,+B;AACA,gF;AACA,oC;AACA,mB;AACA,gC;AACA,2C;AACA,mC;AACA,mF;AACA,e;AACA,O;AACA,wC;AACA,8E;AACA,yD;AACA,+B;AACA,4C;AACA,yD;AACA,qD;AACA,+B;AACA,0E;AACA,+B;AACA,iB;AACA,S;AACA,+C;AACA,Q;;AAEA,kC;AACA,iC;AACA,S;AACA,mB;AACA,qB;AACA,kE;AACA,oE;AACA,2B;AACA,0E;AACA,qD;AACA,K;AACA,I;;AAEA,6E;AACA,4E;AACA,yE;AACA,2E;AACA,+B;AACA,2B;AACA,oB;AACA,0B;AACA,a;AACA,6B;AACA,8B;AACA,6D;AACA,uC;AACA,I;;AAEA,mC;AACA,oB;AACA,2C;AACA,wC;AACA,6B;AACA,2C;AACA,iB;AACA,O;AACA,I;;AAEA,6C;AACA,oC;AACA,oB;AACA,yC;AACA,wE;AACA,+E;AACA,uB;AACA,yD;AACA,sE;AACA,W;AACA,S;AACA,O;AACA,I;;AAEA,kE;AACA,qE;AACA,sE;AACA,gE;AACA,mC;AACA,0B;AACA,oB;AACA,4B;AACA,uE;AACA,kB;AACA,I;;AAEA,2B;AACA,oB;AACA,8B;AACA,a;AACA,iE;AACA,I;;AAEA,gF;AACA,+E;AACA,6E;AACA,oC;AACA,qB;AACA,oB;AACA,8B;AACA,a;AACA,0D;AACA,I;;AAEA,+B;AACA,oB;AACA,8B;AACA,iB;AACA,Q;AACA,yC;AACA,I;;AAEA,+E;AACA,0E;AACA,kB;AACA,+B;AACA,oB;AACA,+D;AACA,I;;AAEA,gD;AACA,oB;AACA,8B;AACA,a;AACA,wC;AACA,+D;AACA,8E;AACA,I;;AAEA,kD;AACA,oB;AACA,8B;AACA,a;AACA,wC;AACA,gF;AACA,I;;AAEA,0C;AACA,oB;AACA,8B;AACA,a;AACA,wC;AACA,sE;AACA,gE;AACA,+C;AACA,wE;AACA,I;;AAEA,sB;AACA,oB;AACA,8B;AACA,a;AACA,8B;AACA,2D;AACA,uB;AACA,sD;AACA,yB;AACA,K;AACA,G;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,6B;AACA,kB;;AAEA,sE;AACA,oE;AACA,iE;AACA,+C;AACA,4C;AACA,6B;AACA,4B;AACA,6D;AACA,wB;AACA,K;;AAEA,mE;AACA,wE;AACA,gE;AACA,uB;AACA,oC;AACA,iD;AACA,K;;AAEA,6B;AACA,uC;;AAEA,4B;;AAEA,+C;;AAEA,wC;;AAEA,iD;AACA,uD;AACA,iC;;AAEA,yD;AACA,+C;AACA,2B;AACA,gD;AACA,qC;AACA,M;;AAEA,0C;AACA,qC;AACA,+C;AACA,O;AACA,W;AACA,a;AACA,sC;AACA,uB;AACA,mC;AACA,iB;AACA,S;AACA,uC;AACA,wC;AACA,iB;AACA,S;;AAEA,oC;AACA,sC;AACA,gD;AACA,mB;AACA,W;AACA,6B;AACA,6C;AACA,mB;AACA,iB;AACA,S;;AAEA,qC;AACA,+C;AACA,iB;AACA,S;AACA,kD;AACA,mB;AACA,iC;AACA,yE;AACA,0C;AACA,O;AACA,O;;AAEA,oC;AACA,kC;AACA,2B;AACA,wC;AACA,iB;AACA,O;AACA,O;AACA,K;AACA,E;;AAEA,4B;;AAEA,+B;AACA,oB;AACA,8C;AACA,I;;AAEA,0C;AACA,oB;;AAEA,2E;AACA,mE;AACA,8C;AACA,mC;AACA,2C;AACA,kD;AACA,8C;AACA,sE;AACA,qB;AACA,a;AACA,K;;AAEA,gE;AACA,0D;AACA,wE;;AAEA,kC;AACA,+E;AACA,+E;AACA,wB;AACA,mE;AACA,qB;AACA,a;AACA,K;;AAEA,kD;AACA,6E;AACA,oE;AACA,oD;AACA,gC;AACA,yD;AACA,kB;AACA,O;AACA,I;AACA,K;AACA,yC;AACA,I;AACA,8C;AACA,8C;AACA,4B;AACA,I;AACA,gE;AACA,0E;AACA,8C;AACA,I;AACA,yD;AACA,mE;AACA,oE;AACA,sB;AACA,I;AACA,wB;AACA,kE;AACA,oE;AACA,mE;AACA,uC;AACA,K;AACA,8C;AACA,oB;;AAEA,4B;;AAEA,gD;AACA,uE;AACA,a;AACA,K;;AAEA,kD;AACA,iE;AACA,gE;AACA,kE;AACA,+D;AACA,kE;AACA,kE;AACA,6C;AACA,2C;AACA,6C;AACA,sB;AACA,yE;AACA,2E;AACA,yE;AACA,2C;AACA,Q;AACA,kE;AACA,Q;AACA,sC;AACA,Q;AACA,gF;AACA,0D;AACA,O;AACA,K;;AAEA,a;AACA,4C;AACA,U;AACA,oD;AACA,wE;AACA,6E;AACA,+D;AACA,gD;AACA,kD;AACA,4B;AACA,gD;AACA,mB;AACA,S;AACA,S;AACA,K;AACA,I;;AAEA,sC;AACA,oB;AACA,oC;AACA,uC;AACA,K;AACA,I;;AAEA,+B;AACA,oB;AACA,2C;AACA,qC;AACA,4E;AACA,wC;AACA,O;AACA,I;;AAEA,0C;AACA,oE;AACA,4C;AACA,wD;AACA,mE;AACA,gC;AACA,4C;AACA,I;;AAEA,qC;AACA,wC;AACA,mD;AACA,oB;;AAEA,2E;AACA,gC;AACA,qD;AACA,yB;AACA,mB;AACA,K;AACA,4B;;AAEA,iB;AACA,mE;AACA,sE;AACA,+B;AACA,yD;AACA,wC;AACA,iB;AACA,sD;AACA,Q;;AAEA,sB;AACA,6C;AACA,kB;AACA,mB;AACA,4D;AACA,Y;AACA,qE;AACA,gE;AACA,+B;AACA,wB;AACA,kC;AACA,kF;AACA,Q;AACA,4B;AACA,2D;AACA,8B;AACA,0C;AACA,sC;AACA,8C;AACA,U;AACA,kD;AACA,O;;AAEA,6C;AACA,4B;AACA,uB;AACA,6B;AACA,+B;AACA,wD;AACA,S;AACA,W;AACA,+E;AACA,0C;AACA,0E;AACA,0B;AACA,W;AACA,mB;AACA,sB;AACA,O;AACA,K;;AAEA,+E;AACA,4E;AACA,gF;AACA,6E;AACA,mD;AACA,mB;AACA,kC;AACA,uB;AACA,K;AACA,kB;AACA,sB;AACA,kB;AACA,I;;AAEA,wC;AACA,oB;AACA,2C;AACA,gB;AACA,gC;AACA,Q;AACA,kB;AACA,G;AACA,G;;AAEA,yD;AACA,2D;AACA,2E;AACA,wD;AACA,K;AACA,wB;AACA,gD;AACA,G;AACA,wB;AACA,E;;AAEA,iD;;;AAGA,8E;AACA,uB;AACA,2D;AACA,sD;AACA,qB;;AAEA,gF;AACA,yE;AACA,8E;AACA,qB;AACA,iC;AACA,yD;AACA,sC;AACA,+E;AACA,qD;AACA,G;;AAEA,4E;AACA,e;AACA,0B;AACA,2D;;AAEA,wD;AACA,E;;;AAGA,8E;AACA,oC;AACA,yE;AACA,oB;AACA,yC;AACA,kD;AACA,qC;AACA,G;AACA,gC;AACA,E;;;;;;;;;;;;;;;;;;;AC/8CA,+B;AACA,wD;;AAEA,oE;AACA,iE;AACA,kE;AACA,E;AACA,qC;AACA,kB;;AAEA,qB;AACA,qB;AACA,uB;AACA,8B;AACA,iC;AACA,E;;AAEA,qE;AACA,sE;AACA,gB;AACA,E;AACA,8D;;AAEA,2C;AACA,sE;AACA,mE;AACA,qE;AACA,sE;AACA,6D;AACA,2B;AACA,oB;;AAEA,qB;AACA,2C;;AAEA,mB;AACA,+E;;AAEA,8B;AACA,0B;AACA,Y;AACA,8B;AACA,sB;AACA,sE;AACA,yB;AACA,kC;AACA,0B;AACA,O;AACA,M;AACA,I;;AAEA,kE;AACA,0C;AACA,oB;AACA,oB;AACA,oD;AACA,iD;AACA,sB;AACA,sB;AACA,I;;AAEA,2D;AACA,mC;AACA,oB;AACA,mB;AACA,qE;AACA,wC;AACA,yC;AACA,I;;AAEA,sE;AACA,2B;AACA,oB;AACA,4B;AACA,qC;AACA,yB;AACA,O;AACA,e;AACA,kB;AACA,I;;AAEA,2B;AACA,oB;AACA,mB;AACA,wD;AACA,iD;AACA,wB;AACA,iE;AACA,qC;AACA,K;AACA,I;;AAEA,oE;AACA,uC;AACA,uB;AACA,oB;AACA,qB;AACA,iE;AACA,wB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACpGA,8E;;AAEA,0C;AACA,kB;AACA,0B;;AAEA,kB;AACA,oE;AACA,gB;AACA,sB;AACA,uD;AACA,2C;AACA,E;;AAEA,yC;AACA,iE;AACA,0D;AACA,kE;AACA,6B;AACA,I;AACA,8D;AACA,2C;AACA,I;AACA,iE;AACA,c;AACA,wC;AACA,oB;AACA,2B;AACA,6E;AACA,yC;AACA,8C;AACA,4C;AACA,K;AACA,Y;AACA,yB;AACA,6C;AACA,kD;AACA,iD;AACA,S;AACA,kC;AACA,O;AACA,M;AACA,I;;AAEA,gE;AACA,sE;AACA,gC;AACA,I;AACA,+D;AACA,sE;AACA,I;AACA,oE;AACA,iC;AACA,oB;AACA,+E;AACA,8E;AACA,+E;AACA,mE;AACA,+B;AACA,0D;AACA,6C;AACA,iD;AACA,2C;AACA,O;;AAEA,gD;AACA,oC;AACA,wB;AACA,O;AACA,I;;AAEA,+E;AACA,I;AACA,c;AACA,qD;AACA,uD;AACA,4B;AACA,8D;AACA,uE;AACA,8D;AACA,uD;AACA,wB;AACA,uE;AACA,2E;AACA,8B;AACA,8E;AACA,yE;AACA,0C;AACA,8C;AACA,wD;AACA,yC;AACA,sD;AACA,O;AACA,G;AACA,G;;AAEA,+E;AACA,2E;AACA,gF;AACA,6E;AACA,4B;AACA,2D;AACA,6C;AACA,G;;;;;;;;;;;;;;;;;;;ACvGA,S;;AAEA,4C;;AAEA,6D;;AAEA,uC;AACA,kB;;AAEA,sE;AACA,qE;AACA,iE;AACA,gE;AACA,wE;AACA,sE;AACA,yC;AACA,2C;;AAEA,mE;AACA,qE;AACA,c;AACA,oD;AACA,8B;;AAEA,oB;AACA,+B;;AAEA,gE;AACA,yB;AACA,wD;;AAEA,+D;AACA,uC;;AAEA,+C;AACA,uC;;AAEA,uE;AACA,2B;AACA,E;;AAEA,sC;AACA,wB;AACA,oB;AACA,+B;AACA,oB;AACA,I;AACA,+B;AACA,oB;AACA,4B;AACA,gF;AACA,yB;AACA,4B;AACA,G;AACA,G;;AAEA,qC;AACA,O;AACA,wC;AACA,e;AACA,yE;AACA,gB;AACA,G;AACA,kC;AACA,gD;AACA,sE;AACA,gB;AACA,G;;AAEA,6E;;AAEA,qE;AACA,gB;AACA,8B;AACA,8B;AACA,sB;AACA,6C;AACA,uC;AACA,O;AACA,uB;AACA,G;;AAEA,2D;AACA,0B;AACA,+D;AACA,K;;AAEA,a;AACA,E;;AAEA,+B;AACA,8B;AACA,sE;AACA,qB;AACA,6B;AACA,qB;AACA,8C;AACA,gC;AACA,0B;AACA,gC;AACA,O;AACA,O;AACA,4B;AACA,6B;AACA,+B;AACA,yB;AACA,G;AACA,0B;AACA,2D;AACA,2B;AACA,+D;AACA,K;AACA,6C;AACA,kD;AACA,G;AACA,8B;AACA,E;;AAEA,oE;AACA,qE;AACA,gE;AACA,wD;AACA,wD;;;;;;;;;;;;;;;;;;;AC1HA,2E;AACA,E;AACA,4E;AACA,6E;AACA,mE;AACA,E;AACA,4E;AACA,+E;AACA,0E;AACA,+E;AACA,4E;AACA,6E;AACA,E;AACA,+D;AACA,6D;AACA,gE;AACA,8C;AACA,E;AACA,mC;AACA,4D;AACA,2D;AACA,iF;AACA,gF;AACA,mC;AACA,kB;;AAEA,uD;;AAEA,sB;AACA,E;;AAEA,kE;AACA,gE;AACA,wE;AACA,yC;AACA,wB;AACA,8B;AACA,E;;AAEA,6E;AACA,6E;AACA,oE;AACA,mC;AACA,wE;AACA,6E;AACA,0D;AACA,2C;AACA,c;AACA,qB;AACA,G;AACA,e;AACA,oC;AACA,mD;AACA,kB;AACA,G;AACA,wC;AACA,sB;AACA,0D;AACA,4B;AACA,O;AACA,G;AACA,sC;AACA,E;;AAEA,sD;AACA,6E;AACA,+D;AACA,oC;AACA,2C;AACA,uC;AACA,E;;AAEA,qD;AACA,8C;AACA,yD;AACA,uE;AACA,oD;AACA,yE;AACA,gD;AACA,iE;AACA,8B;AACA,E;;AAEA,kC;AACA,kF;AACA,uE;AACA,qE;AACA,8B;AACA,oB;;AAEA,gD;AACA,4B;AACA,gD;AACA,qD;AACA,4C;AACA,8C;AACA,S;AACA,O;AACA,yF;AACA,K;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACtGA,sB;AACA,iC;AACA,oC;AACA,0D;AACA,C;;AAEA,gD;AACA,2C;AACA,W;AACA,gF;AACA,qE;AACA,gC;AACA,2E;AACA,6E;AACA,E;AACA,qE;AACA,oC;AACA,E;AACA,oE;AACA,iE;AACA,qE;AACA,8D;AACA,8D;AACA,mE;AACA,oE;AACA,+B;AACA,0C;AACA,kB;AACA,sB;AACA,gC;AACA,4D;AACA,iC;AACA,M;AACA,6B;AACA,4B;AACA,0C;AACA,iC;AACA,iD;AACA,gB;AACA,wB;AACA,c;;AAEA,wE;AACA,gF;AACA,gB;AACA,0B;;AAEA,6D;AACA,gC;AACA,uB;AACA,U;AACA,uD;AACA,2B;AACA,+B;AACA,6C;AACA,gF;AACA,qC;AACA,gD;AACA,O;AACA,G;;AAEA,6B;AACA,oE;AACA,4E;AACA,mD;AACA,4C;AACA,yB;AACA,4D;;AAEA,sD;AACA,oD;;AAEA,2E;AACA,gF;AACA,6E;AACA,0B;AACA,4B;;AAEA,gF;AACA,iB;AACA,I;AACA,0E;AACA,+E;AACA,4E;AACA,+E;AACA,mB;AACA,I;AACA,uD;AACA,+C;AACA,4E;AACA,8B;AACA,I;AACA,gF;AACA,+D;AACA,I;AACA,oE;AACA,+E;AACA,+E;AACA,gF;AACA,6E;AACA,+C;AACA,I;AACA,a;AACA,kC;AACA,mC;AACA,6D;AACA,0D;AACA,4D;AACA,8E;AACA,uE;AACA,6E;AACA,+E;AACA,+E;AACA,0D;AACA,qC;;AAEA,2E;AACA,yE;AACA,gF;AACA,+B;AACA,oC;AACA,8E;AACA,4D;AACA,8E;AACA,gC;AACA,8D;AACA,8E;AACA,6D;AACA,6B;;AAEA,uE;AACA,qB;AACA,uE;AACA,qC;AACA,yE;AACA,gF;AACA,4E;AACA,gB;AACA,kC;;AAEA,gF;AACA,oC;AACA,8E;AACA,8E;AACA,6D;AACA,6E;AACA,gF;AACA,uE;AACA,mD;AACA,I;AACA,iE;;AAEA,+D;AACA,6C;AACA,yE;AACA,yE;AACA,W;AACA,uC;AACA,yE;AACA,wE;AACA,0D;AACA,uE;AACA,gB;AACA,4B;;AAEA,iE;AACA,qC;AACA,kD;AACA,4B;;AAEA,sE;AACA,W;AACA,a;AACA,e;AACA,uE;AACA,uD;AACA,gE;AACA,+E;AACA,iC;AACA,2B;;AAEA,qB;AACA,sB;AACA,yC;;AAEA,gE;AACA,4E;AACA,uD;AACA,oC;AACA,+B;AACA,yD;AACA,mC;AACA,qB;AACA,c;AACA,sB;AACA,O;AACA,O;AACA,G;;AAEA,sC;AACA,S;AACA,kC;AACA,iB;AACA,sD;AACA,a;AACA,K;;AAEA,mC;AACA,uE;AACA,wE;AACA,qC;AACA,mC;AACA,kE;AACA,a;AACA,K;;AAEA,kC;AACA,8C;AACA,oC;AACA,4B;AACA,K;AACA,mC;AACA,gE;AACA,8C;AACA,+C;AACA,c;AACA,yB;AACA,wF;AACA,yE;AACA,4D;AACA,O;AACA,K;AACA,kC;AACA,iC;AACA,8C;AACA,0B;AACA,uC;AACA,K;AACA,kC;AACA,4B;AACA,uC;AACA,O;AACA,K;AACA,qF;AACA,+B;AACA,iC;AACA,gC;AACA,kC;AACA,iC;AACA,iC;AACA,gC;AACA,Q;AACA,qE;AACA,I;;AAEA,6B;AACA,6D;AACA,qE;AACA,2C;AACA,+B;AACA,4B;AACA,wC;AACA,2E;AACA,0C;AACA,6C;AACA,oB;;AAEA,oE;AACA,qE;AACA,oE;AACA,4D;AACA,qE;AACA,kE;AACA,0B;;AAEA,gF;AACA,wD;AACA,qD;AACA,8D;AACA,4C;AACA,K;;AAEA,uE;AACA,kB;AACA,+C;AACA,4B;AACA,O;;AAEA,oE;AACA,oE;AACA,oE;AACA,oE;AACA,oB;AACA,yB;AACA,kE;AACA,Q;AACA,qC;;AAEA,wE;AACA,6C;AACA,oD;AACA,kB;AACA,mB;AACA,e;AACA,uB;AACA,0B;AACA,S;AACA,O;AACA,I;;AAEA,kC;AACA,0B;AACA,6B;AACA,6B;AACA,K;AACA,I;;AAEA,wB;AACA,iF;AACA,6E;AACA,uF;AACA,U;AACA,0C;AACA,sC;AACA,gD;AACA,G;AACA,E;;AAEA,gF;AACA,sE;AACA,+E;AACA,2E;AACA,+C;AACA,wC;AACA,kB;;AAEA,sC;AACA,mC;AACA,2B;;AAEA,oC;AACA,wC;AACA,kC;AACA,sE;AACA,4B;AACA,4B;AACA,4B;;AAEA,kC;AACA,yD;AACA,E;AACA,mC;AACA,8E;AACA,oE;AACA,4B;AACA,oB;AACA,8E;AACA,gF;AACA,c;AACA,yB;AACA,uE;;AAEA,8E;AACA,Y;AACA,8B;;AAEA,4B;;AAEA,+E;AACA,Y;AACA,mB;AACA,wE;;AAEA,iC;AACA,0C;AACA,I;AACA,6E;AACA,qC;AACA,qC;AACA,oB;AACA,kD;AACA,4E;AACA,0B;AACA,mE;;AAEA,kC;AACA,6D;;AAEA,+E;AACA,8C;AACA,oD;AACA,K;AACA,I;AACA,2E;AACA,oE;AACA,4E;AACA,2D;AACA,yC;AACA,oB;AACA,yB;AACA,kE;AACA,uC;AACA,wC;AACA,gC;AACA,I;AACA,8E;AACA,uE;AACA,4E;AACA,sE;AACA,4B;AACA,oB;AACA,6B;AACA,gC;AACA,I;AACA,2C;AACA,0B;AACA,oB;AACA,gC;AACA,G;AACA,G;;AAEA,gC;AACA,qE;AACA,gF;AACA,gF;AACA,gD;AACA,oB;;AAEA,6B;AACA,mB;;AAEA,0E;AACA,2C;AACA,mB;AACA,kE;AACA,qD;AACA,2C;AACA,4C;AACA,6E;AACA,qC;AACA,gB;AACA,e;;AAEA,+B;;AAEA,qD;AACA,iB;AACA,8C;AACA,qC;AACA,0B;AACA,S;AACA,wB;AACA,iD;AACA,K;;AAEA,gB;AACA,I;;AAEA,2E;AACA,oB;;AAEA,0D;AACA,uB;AACA,wB;AACA,gD;AACA,4C;AACA,yC;AACA,yE;AACA,0E;AACA,iC;AACA,O;AACA,K;;AAEA,uE;AACA,uE;AACA,4B;AACA,M;AACA,wC;AACA,M;AACA,qC;AACA,yD;AACA,yD;AACA,c;AACA,M;AACA,sE;AACA,oE;AACA,sD;AACA,M;AACA,8E;AACA,4E;AACA,uB;AACA,+D;AACA,iD;AACA,yC;AACA,O;;AAEA,W;AACA,mB;AACA,uB;AACA,8C;;AAEA,8B;AACA,+E;AACA,+E;AACA,6E;AACA,yE;AACA,8C;AACA,4B;AACA,qD;AACA,O;AACA,8B;AACA,kE;AACA,2B;AACA,mD;AACA,O;AACA,Y;AACA,oE;AACA,uB;AACA,iC;AACA,e;AACA,mB;AACA,oC;AACA,wB;AACA,qB;AACA,uC;AACA,yC;AACA,yC;AACA,yB;AACA,4B;AACA,yD;AACA,iD;AACA,U;AACA,0B;AACA,wD;AACA,wB;AACA,S;AACA,Q;AACA,mE;AACA,K;;AAEA,0C;AACA,kB;AACA,yB;AACA,4C;AACA,iB;;AAEA,uC;AACA,Q;AACA,0B;AACA,8C;AACA,4C;AACA,uB;AACA,6C;AACA,kC;AACA,4B;AACA,O;AACA,M;;AAEA,sB;AACA,8E;AACA,8E;AACA,6E;AACA,uE;AACA,wE;AACA,uB;AACA,sC;AACA,2C;AACA,kD;;AAEA,qC;AACA,+C;AACA,+C;AACA,0B;AACA,W;AACA,S;AACA,K;;AAEA,kB;AACA,I;;AAEA,a;AACA,2F;AACA,mE;AACA,qD;AACA,oB;AACA,yB;AACA,sB;AACA,e;AACA,sB;AACA,e;AACA,4B;AACA,qB;AACA,sB;AACA,Q;AACA,6B;AACA,mB;AACA,wB;AACA,Y;AACA,mE;AACA,O;AACA,O;;AAEA,6D;AACA,a;AACA,kB;AACA,I;;AAEA,+B;AACA,oB;AACA,2C;AACA,qC;AACA,4E;AACA,wC;AACA,O;AACA,I;;AAEA,0D;AACA,oE;AACA,4C;AACA,wD;AACA,mE;AACA,gC;AACA,4C;AACA,I;;AAEA,qC;AACA,4E;AACA,4E;AACA,2D;AACA,+E;AACA,4E;AACA,2E;AACA,2E;AACA,2E;AACA,6E;AACA,6E;AACA,2E;AACA,yE;AACA,4E;AACA,8E;AACA,6E;AACA,6E;AACA,2E;AACA,6D;AACA,wC;AACA,mD;AACA,oB;;AAEA,2E;AACA,gC;AACA,qD;AACA,yB;AACA,mB;AACA,K;AACA,4B;;AAEA,mB;AACA,oE;AACA,oC;AACA,yD;AACA,wC;AACA,iB;AACA,sD;AACA,Q;AACA,K;;AAEA,8E;AACA,uC;AACA,6B;;AAEA,mE;AACA,iC;AACA,a;AACA,0B;AACA,6B;AACA,2C;AACA,kB;AACA,Q;AACA,S;;AAEA,iD;AACA,kE;;AAEA,yE;AACA,8E;AACA,yE;AACA,8D;AACA,+E;AACA,6E;AACA,6E;AACA,wE;AACA,4E;AACA,iD;AACA,0B;AACA,2C;AACA,gC;AACA,kD;AACA,O;AACA,wB;AACA,M;;AAEA,sE;AACA,4E;AACA,0E;AACA,8E;AACA,iD;AACA,M;AACA,yE;AACA,yE;AACA,4E;AACA,wE;AACA,a;;AAEA,0C;AACA,e;AACA,wC;AACA,+B;AACA,Q;;AAEA,6C;AACA,2B;AACA,8B;AACA,6B;AACA,iE;AACA,S;;AAEA,+B;AACA,8B;;AAEA,W;AACA,4E;AACA,8C;AACA,wF;AACA,gC;AACA,4E;AACA,0C;AACA,wD;AACA,4E;AACA,+D;AACA,e;AACA,kB;AACA,6D;AACA,W;AACA,W;AACA,O;AACA,iB;AACA,0B;AACA,O;;AAEA,+B;AACA,oD;AACA,K;;AAEA,oE;AACA,+D;AACA,wC;AACA,8B;AACA,qB;AACA,6C;AACA,yB;AACA,O;AACA,oB;AACA,wB;AACA,6B;AACA,K;;AAEA,gE;AACA,iE;AACA,sD;AACA,M;AACA,oE;AACA,iB;AACA,2C;AACA,2E;AACA,4D;AACA,K;;;AAGA,sE;AACA,iD;;AAEA,+D;AACA,oB;AACA,4B;AACA,sE;AACA,sE;AACA,uE;AACA,0B;AACA,mC;AACA,uE;AACA,4C;AACA,U;AACA,c;AACA,iE;AACA,qC;AACA,gC;AACA,qC;AACA,O;AACA,K;AACA,sE;AACA,yE;AACA,+D;AACA,mB;AACA,oB;AACA,mB;AACA,mB;AACA,oB;AACA,M;;AAEA,6C;AACA,8B;AACA,sC;AACA,K;;AAEA,2C;AACA,2B;AACA,yB;AACA,uB;AACA,iD;AACA,2B;AACA,sB;AACA,O;;AAEA,uB;AACA,gE;AACA,yC;AACA,gD;AACA,Y;AACA,8E;AACA,wD;AACA,qD;AACA,qD;AACA,uE;AACA,wE;AACA,K;;AAEA,0D;AACA,mD;AACA,kC;;AAEA,yD;AACA,oC;AACA,iB;AACA,2B;AACA,K;AACA,iE;AACA,I;;AAEA,gF;AACA,uE;AACA,e;AACA,+B;AACA,oB;AACA,uC;AACA,wB;AACA,O;AACA,I;AACA,8E;AACA,gF;AACA,mE;AACA,mD;AACA,oB;AACA,+C;AACA,0E;;AAEA,yB;AACA,mD;AACA,4C;AACA,gD;AACA,qB;AACA,e;AACA,4C;AACA,2D;AACA,sD;AACA,yE;AACA,6E;AACA,uC;AACA,+E;AACA,2B;AACA,oD;AACA,gB;AACA,mE;AACA,mC;AACA,wC;AACA,wC;AACA,oD;AACA,S;AACA,S;AACA,O;AACA,kC;AACA,2D;AACA,K;AACA,I;;AAEA,kE;AACA,wD;AACA,gC;AACA,oB;AACA,6D;AACA,qE;AACA,sD;AACA,Q;AACA,mE;AACA,mE;AACA,oD;AACA,4D;AACA,uC;AACA,O;AACA,O;AACA,I;;AAEA,8D;AACA,yB;AACA,oB;AACA,yC;AACA,I;;AAEA,6D;AACA,mE;AACA,mC;AACA,gC;AACA,oB;AACA,mC;AACA,I;;AAEA,2C;AACA,oB;AACA,8D;AACA,I;;AAEA,8C;AACA,oB;AACA,iE;AACA,I;;AAEA,+C;AACA,oB;AACA,kE;AACA,I;;AAEA,sB;AACA,oB;AACA,uD;AACA,I;;AAEA,K;AACA,0B;AACA,K;AACA,uB;AACA,oB;AACA,yB;AACA,gC;AACA,wB;AACA,I;;AAEA,gC;AACA,oB;AACA,+E;AACA,gC;AACA,a;AACA,0B;AACA,yB;AACA,iC;AACA,I;;AAEA,gF;AACA,2E;AACA,6B;AACA,sC;AACA,oB;AACA,kD;AACA,0D;AACA,I;;AAEA,6E;AACA,uC;AACA,0C;AACA,oB;AACA,+D;AACA,I;;AAEA,uC;AACA,oB;;AAEA,oE;AACA,uC;AACA,mD;AACA,iD;AACA,gC;AACA,0D;AACA,sE;AACA,wE;AACA,mE;AACA,kE;AACA,+B;AACA,4E;AACA,W;AACA,iC;AACA,U;AACA,+B;AACA,oC;AACA,S;AACA,S;AACA,8B;AACA,K;;AAEA,8D;AACA,4B;AACA,+B;;AAEA,4C;AACA,+E;AACA,wC;AACA,K;;AAEA,uC;AACA,+E;AACA,4E;AACA,gF;AACA,+E;AACA,0E;AACA,a;AACA,K;;AAEA,oE;;AAEA,+E;AACA,mC;AACA,uC;;AAEA,4B;AACA,8E;AACA,gB;AACA,wC;AACA,iC;AACA,K;;AAEA,mC;AACA,oC;;AAEA,8E;AACA,gD;AACA,gF;AACA,qE;AACA,gC;AACA,oD;AACA,oB;AACA,0C;AACA,O;;AAEA,2E;AACA,uE;AACA,uC;AACA,M;AACA,wE;AACA,gF;AACA,4D;AACA,yC;AACA,4B;AACA,uD;AACA,kC;AACA,gF;AACA,0E;AACA,4E;AACA,0E;AACA,gF;AACA,yC;AACA,4E;AACA,8E;AACA,8D;AACA,Y;AACA,6E;AACA,uE;AACA,+E;AACA,2E;AACA,+B;AACA,mE;AACA,S;AACA,S;AACA,K;;AAEA,+C;;AAEA,+E;AACA,sC;AACA,wC;AACA,8B;AACA,2C;AACA,iC;AACA,wB;AACA,W;AACA,kC;AACA,O;AACA,sC;AACA,K;AACA,I;;;AAGA,mD;AACA,oB;AACA,6D;AACA,8C;AACA,I;;;AAGA,kC;AACA,oB;;AAEA,2C;AACA,qB;;AAEA,uC;AACA,sD;;AAEA,8B;AACA,8C;;AAEA,+C;AACA,6C;AACA,S;AACA,qD;AACA,yD;AACA,S;;AAEA,uC;AACA,e;;AAEA,oD;AACA,8E;AACA,oC;AACA,4E;AACA,0D;AACA,S;AACA,iD;AACA,Y;AACA,gD;AACA,K;;AAEA,mD;AACA,oD;AACA,oD;AACA,gF;AACA,yC;AACA,S;AACA,gC;;AAEA,4D;AACA,4C;AACA,oB;AACA,2D;AACA,wC;AACA,a;AACA,gB;AACA,gE;AACA,8B;AACA,oE;AACA,qE;AACA,gD;AACA,+D;AACA,0D;AACA,8E;AACA,qD;AACA,S;AACA,S;;AAEA,gC;AACA,4D;AACA,K;;AAEA,oC;AACA,I;;AAEA,2E;AACA,yE;AACA,+B;AACA,yC;AACA,oB;AACA,+C;AACA,oC;AACA,oC;AACA,U;AACA,O;AACA,I;;AAEA,oD;AACA,oB;AACA,sC;AACA,+B;AACA,K;AACA,kC;AACA,I;;AAEA,4C;AACA,oB;AACA,kD;AACA,kB;AACA,oE;AACA,mD;AACA,I;;AAEA,2C;AACA,oB;AACA,8C;AACA,2D;AACA,oB;AACA,0C;AACA,2C;AACA,sE;AACA,4C;AACA,kC;AACA,Y;AACA,qD;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,uC;AACA,wD;AACA,oB;AACA,2C;AACA,6E;AACA,oE;AACA,Y;AACA,qD;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,uC;AACA,wD;AACA,oB;AACA,0C;AACA,2C;AACA,4E;AACA,qC;AACA,Y;AACA,iD;AACA,uB;AACA,mC;AACA,kB;AACA,S;AACA,K;AACA,I;;AAEA,6C;AACA,oB;AACA,sC;AACA,6C;AACA,yE;AACA,2E;AACA,uB;AACA,2E;AACA,gD;AACA,4D;AACA,iE;AACA,kD;AACA,kD;AACA,6E;AACA,8E;AACA,+E;AACA,wC;;AAEA,yE;AACA,+E;AACA,uE;AACA,yD;AACA,2B;AACA,yD;AACA,uC;AACA,a;AACA,sC;AACA,yD;AACA,gB;AACA,a;;AAEA,2E;AACA,6E;AACA,gE;AACA,uE;AACA,S;AACA,S;AACA,oD;;AAEA,gF;AACA,iD;AACA,2D;AACA,2B;AACA,sE;AACA,2C;AACA,8D;AACA,O;AACA,I;;AAEA,2C;AACA,oB;AACA,2E;AACA,wE;AACA,4D;AACA,uC;AACA,wD;AACA,mD;AACA,sC;AACA,uB;AACA,iB;AACA,0D;AACA,4B;AACA,iB;AACA,6D;AACA,+B;AACA,sC;AACA,S;AACA,O;AACA,I;;AAEA,qE;AACA,gF;AACA,2C;AACA,iD;AACA,oB;AACA,wC;AACA,yC;AACA,M;AACA,oC;AACA,wC;AACA,gC;AACA,0C;AACA,6E;AACA,6B;AACA,2B;AACA,O;AACA,M;AACA,6D;AACA,mD;AACA,2D;AACA,gE;AACA,yD;AACA,kD;AACA,a;AACA,qD;AACA,oC;AACA,0D;AACA,S;AACA,S;AACA,O;AACA,wC;AACA,gF;AACA,qC;AACA,yB;AACA,K;AACA,I;;AAEA,mC;AACA,oB;;AAEA,2E;AACA,0B;AACA,6B;;AAEA,yD;AACA,kC;;AAEA,2D;AACA,4C;AACA,a;AACA,kE;AACA,yC;AACA,qC;AACA,qC;AACA,+D;AACA,K;AACA,I;;AAEA,+B;AACA,2E;AACA,4E;AACA,sE;AACA,yE;AACA,e;AACA,I;;AAEA,oC;AACA,mE;;AAEA,oB;;AAEA,mC;AACA,uD;AACA,mD;AACA,yE;AACA,a;AACA,K;AACA,sE;AACA,U;AACA,yD;AACA,gC;AACA,gC;AACA,c;AACA,K;;AAEA,a;AACA,gF;AACA,a;AACA,K;;AAEA,+E;AACA,gF;AACA,kC;AACA,oC;;AAEA,8B;AACA,uC;AACA,0C;AACA,4B;AACA,Y;AACA,kE;AACA,c;AACA,6C;AACA,K;AACA,I;;AAEA,+E;AACA,8E;AACA,mE;AACA,2C;AACA,oB;AACA,yC;AACA,a;;AAEA,2E;AACA,0E;AACA,kD;AACA,qD;AACA,6D;AACA,0C;AACA,uE;AACA,oD;;AAEA,6D;AACA,oD;AACA,uC;AACA,K;;AAEA,oC;AACA,yB;AACA,I;;AAEA,6D;AACA,8B;AACA,uC;AACA,oB;AACA,iD;AACA,a;AACA,mE;AACA,sB;AACA,O;AACA,I;;AAEA,mC;AACA,8D;AACA,6B;AACA,mD;AACA,I;;AAEA,oE;AACA,oB;AACA,mE;AACA,uC;;AAEA,uB;;AAEA,8C;AACA,a;;AAEA,yE;AACA,4E;AACA,+D;AACA,mD;AACA,iE;AACA,qC;AACA,a;AACA,K;;AAEA,gF;AACA,6E;AACA,yC;AACA,sD;AACA,8C;AACA,kE;AACA,8D;;AAEA,0E;AACA,uD;AACA,0B;AACA,S;;AAEA,yC;AACA,K;;AAEA,kD;AACA,yD;AACA,gD;AACA,O;AACA,I;;AAEA,qE;AACA,+B;AACA,oB;AACA,2C;AACA,I;;AAEA,2E;AACA,kE;AACA,8B;AACA,oB;AACA,uD;AACA,2B;AACA,gC;AACA,K;AACA,G;AACA,G;;AAEA,qC;;AAEA,yC;AACA,Y;AACA,8B;AACA,qC;AACA,W;AACA,qD;AACA,E;AACA,uC;AACA,yC;AACA,+C;AACA,a;AACA,E;;AAEA,kE;AACA,iC;AACA,E;AACA,oB;AACA,0C;AACA,gD;AACA,sD;AACA,uB;AACA,O;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC5gDA,sE;AACA,4C;AACA,E;AACA,qB;AACA,+C;AACA,0D;AACA,6C;AACA,G;;AAEA,6B;;AAEA,4C;AACA,uD;AACA,I;;AAEA,0D;AACA,kC;AACA,iE;AACA,0B;AACA,qE;AACA,Y;AACA,Q;AACA,wC;AACA,uB;AACA,4C;AACA,I;AACA,C;;AAEA,iE;AACA,gE;AACA,wB;AACA,sC","sourcesContent":["LivedataTest = {};\r\n","// @param endpoint {String} URL to Meteor app\r\n//   \"http://subdomain.meteor.com/\" or \"/\" or\r\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\r\n//\r\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\r\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\r\n// us should work.\r\n//\r\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\r\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\r\n// ping frames or with DDP-level messages.)\r\nLivedataTest.ClientStream = function (endpoint, options) {\r\n  var self = this;\r\n  options = options || {};\r\n\r\n  self.options = _.extend({\r\n    retry: true\r\n  }, options);\r\n\r\n  self.client = null;  // created in _launchConnection\r\n  self.endpoint = endpoint;\r\n\r\n  self.headers = self.options.headers || {};\r\n\r\n  self._initCommon();\r\n\r\n  //// Kickoff!\r\n  self._launchConnection();\r\n};\r\n\r\n_.extend(LivedataTest.ClientStream.prototype, {\r\n\r\n  // data is a utf8 string. Data sent while not connected is dropped on\r\n  // the floor, and it is up the user of this API to retransmit lost\r\n  // messages on 'reset'\r\n  send: function (data) {\r\n    var self = this;\r\n    if (self.currentStatus.connected) {\r\n      self.client.send(data);\r\n    }\r\n  },\r\n\r\n  // Changes where this connection points\r\n  _changeUrl: function (url) {\r\n    var self = this;\r\n    self.endpoint = url;\r\n  },\r\n\r\n  _onConnect: function (client) {\r\n    var self = this;\r\n\r\n    if (client !== self.client) {\r\n      // This connection is not from the last call to _launchConnection.\r\n      // But _launchConnection calls _cleanup which closes previous connections.\r\n      // It's our belief that this stifles future 'open' events, but maybe\r\n      // we are wrong?\r\n      throw new Error(\"Got open from inactive client\");\r\n    }\r\n\r\n    if (self._forcedToDisconnect) {\r\n      // We were asked to disconnect between trying to open the connection and\r\n      // actually opening it. Let's just pretend this never happened.\r\n      self.client.close();\r\n      self.client = null;\r\n      return;\r\n    }\r\n\r\n    if (self.currentStatus.connected) {\r\n      // We already have a connection. It must have been the case that we\r\n      // started two parallel connection attempts (because we wanted to\r\n      // 'reconnect now' on a hanging connection and we had no way to cancel the\r\n      // connection attempt.) But this shouldn't happen (similarly to the client\r\n      // !== self.client check above).\r\n      throw new Error(\"Two parallel connections?\");\r\n    }\r\n\r\n    self._clearConnectionTimer();\r\n\r\n    // update status\r\n    self.currentStatus.status = \"connected\";\r\n    self.currentStatus.connected = true;\r\n    self.currentStatus.retryCount = 0;\r\n    self.statusChanged();\r\n\r\n    // fire resets. This must come after status change so that clients\r\n    // can call send from within a reset callback.\r\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\r\n  },\r\n\r\n  _cleanup: function () {\r\n    var self = this;\r\n\r\n    self._clearConnectionTimer();\r\n    if (self.client) {\r\n      var client = self.client;\r\n      self.client = null;\r\n      client.close();\r\n    }\r\n\r\n    _.each(self.eventCallbacks.disconnect, function (callback) { callback(); });\r\n  },\r\n\r\n  _clearConnectionTimer: function () {\r\n    var self = this;\r\n\r\n    if (self.connectionTimer) {\r\n      clearTimeout(self.connectionTimer);\r\n      self.connectionTimer = null;\r\n    }\r\n  },\r\n\r\n  _launchConnection: function () {\r\n    var self = this;\r\n    self._cleanup(); // cleanup the old socket, if there was one.\r\n\r\n    // Since server-to-server DDP is still an experimental feature, we only\r\n    // require the module if we actually create a server-to-server\r\n    // connection.\r\n    var FayeWebSocket = Npm.require('faye-websocket');\r\n\r\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we\r\n    // used to use as a client would fail the handshake if we ask for a\r\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).\r\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\r\n    // Faye is erroneous or not.  So for now, we don't specify protocols.\r\n    var client = self.client = new FayeWebSocket.Client(\r\n      toWebsocketUrl(self.endpoint),\r\n      [/*no subprotocols*/],\r\n      {headers: self.headers}\r\n    );\r\n\r\n    self._clearConnectionTimer();\r\n    self.connectionTimer = Meteor.setTimeout(\r\n      _.bind(self._lostConnection, self),\r\n      self.CONNECT_TIMEOUT);\r\n\r\n    self.client.on('open', Meteor.bindEnvironment(function () {\r\n      return self._onConnect(client);\r\n    }, \"stream connect callback\"));\r\n\r\n    var clientOnIfCurrent = function (event, description, f) {\r\n      self.client.on(event, Meteor.bindEnvironment(function () {\r\n        // Ignore events from any connection we've already cleaned up.\r\n        if (client !== self.client)\r\n          return;\r\n        f.apply(this, arguments);\r\n      }, description));\r\n    };\r\n\r\n    clientOnIfCurrent('error', 'stream error callback', function (error) {\r\n      if (!self.options._dontPrintErrors)\r\n        Meteor._debug(\"stream error\", error.message);\r\n\r\n      // XXX: Make this do something better than make the tests hang if it does\r\n      // not work.\r\n      self._lostConnection();\r\n    });\r\n\r\n\r\n    clientOnIfCurrent('close', 'stream close callback', function () {\r\n      self._lostConnection();\r\n    });\r\n\r\n\r\n    clientOnIfCurrent('message', 'stream message callback', function (message) {\r\n      // Ignore binary frames, where message.data is a Buffer\r\n      if (typeof message.data !== \"string\")\r\n        return;\r\n\r\n      _.each(self.eventCallbacks.message, function (callback) {\r\n        callback(message.data);\r\n      });\r\n    });\r\n  }\r\n});\r\n","// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\r\nvar startsWith = function(str, starts) {\r\n  return str.length >= starts.length &&\r\n    str.substring(0, starts.length) === starts;\r\n};\r\nvar endsWith = function(str, ends) {\r\n  return str.length >= ends.length &&\r\n    str.substring(str.length - ends.length) === ends;\r\n};\r\n\r\n// @param url {String} URL to Meteor app, eg:\r\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"\r\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\r\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\r\n// for scheme \"http\" and subPath \"sockjs\"\r\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"\r\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"\r\nvar translateUrl =  function(url, newSchemeBase, subPath) {\r\n  if (! newSchemeBase) {\r\n    newSchemeBase = \"http\";\r\n  }\r\n\r\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);\r\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);\r\n  var newScheme;\r\n  if (ddpUrlMatch) {\r\n    // Remove scheme and split off the host.\r\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\r\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";\r\n    var slashPos = urlAfterDDP.indexOf('/');\r\n    var host =\r\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\r\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);\r\n\r\n    // In the host (ONLY!), change '*' characters into random digits. This\r\n    // allows different stream connections to connect to different hostnames\r\n    // and avoid browser per-hostname connection limits.\r\n    host = host.replace(/\\*/g, function () {\r\n      return Math.floor(Random.fraction()*10);\r\n    });\r\n\r\n    return newScheme + '://' + host + rest;\r\n  } else if (httpUrlMatch) {\r\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";\r\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);\r\n    url = newScheme + \"://\" + urlAfterHttp;\r\n  }\r\n\r\n  // Prefix FQDNs but not relative URLs\r\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {\r\n    url = newSchemeBase + \"://\" + url;\r\n  }\r\n\r\n  // XXX This is not what we should be doing: if I have a site\r\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect\r\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if\r\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")\r\n  // to connect to \"/foo/bar\").\r\n  //\r\n  // We should make this properly honor absolute paths rather than\r\n  // forcing the path to be relative to the site root. Simultaneously,\r\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site\r\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs\r\n  url = Meteor._relativeToSiteRootUrl(url);\r\n\r\n  if (endsWith(url, \"/\"))\r\n    return url + subPath;\r\n  else\r\n    return url + \"/\" + subPath;\r\n};\r\n\r\ntoSockjsUrl = function (url) {\r\n  return translateUrl(url, \"http\", \"sockjs\");\r\n};\r\n\r\ntoWebsocketUrl = function (url) {\r\n  var ret = translateUrl(url, \"ws\", \"websocket\");\r\n  return ret;\r\n};\r\n\r\nLivedataTest.toSockjsUrl = toSockjsUrl;\r\n\r\n\r\n_.extend(LivedataTest.ClientStream.prototype, {\r\n\r\n  // Register for callbacks.\r\n  on: function (name, callback) {\r\n    var self = this;\r\n\r\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')\r\n      throw new Error(\"unknown event type: \" + name);\r\n\r\n    if (!self.eventCallbacks[name])\r\n      self.eventCallbacks[name] = [];\r\n    self.eventCallbacks[name].push(callback);\r\n  },\r\n\r\n\r\n  _initCommon: function () {\r\n    var self = this;\r\n    //// Constants\r\n\r\n    // how long to wait until we declare the connection attempt\r\n    // failed.\r\n    self.CONNECT_TIMEOUT = 10000;\r\n\r\n    self.eventCallbacks = {}; // name -> [callback]\r\n\r\n    self._forcedToDisconnect = false;\r\n\r\n    //// Reactive status\r\n    self.currentStatus = {\r\n      status: \"connecting\",\r\n      connected: false,\r\n      retryCount: 0\r\n    };\r\n\r\n\r\n    self.statusListeners = typeof Deps !== 'undefined' && new Deps.Dependency;\r\n    self.statusChanged = function () {\r\n      if (self.statusListeners)\r\n        self.statusListeners.changed();\r\n    };\r\n\r\n    //// Retry logic\r\n    self._retry = new Retry;\r\n    self.connectionTimer = null;\r\n\r\n  },\r\n\r\n  // Trigger a reconnect.\r\n  reconnect: function (options) {\r\n    var self = this;\r\n    options = options || {};\r\n\r\n    if (options.url) {\r\n      self._changeUrl(options.url);\r\n    }\r\n\r\n    if (options._sockjsOptions) {\r\n      self.options._sockjsOptions = options._sockjsOptions;\r\n    }\r\n\r\n    if (self.currentStatus.connected) {\r\n      if (options._force || options.url) {\r\n        // force reconnect.\r\n        self._lostConnection();\r\n      } // else, noop.\r\n      return;\r\n    }\r\n\r\n    // if we're mid-connection, stop it.\r\n    if (self.currentStatus.status === \"connecting\") {\r\n      self._lostConnection();\r\n    }\r\n\r\n    self._retry.clear();\r\n    self.currentStatus.retryCount -= 1; // don't count manual retries\r\n    self._retryNow();\r\n  },\r\n\r\n  disconnect: function (options) {\r\n    var self = this;\r\n    options = options || {};\r\n\r\n    // Failed is permanent. If we're failed, don't let people go back\r\n    // online by calling 'disconnect' then 'reconnect'.\r\n    if (self._forcedToDisconnect)\r\n      return;\r\n\r\n    // If _permanent is set, permanently disconnect a stream. Once a stream\r\n    // is forced to disconnect, it can never reconnect. This is for\r\n    // error cases such as ddp version mismatch, where trying again\r\n    // won't fix the problem.\r\n    if (options._permanent) {\r\n      self._forcedToDisconnect = true;\r\n    }\r\n\r\n    self._cleanup();\r\n    self._retry.clear();\r\n\r\n    self.currentStatus = {\r\n      status: (options._permanent ? \"failed\" : \"offline\"),\r\n      connected: false,\r\n      retryCount: 0\r\n    };\r\n\r\n    if (options._permanent && options._error)\r\n      self.currentStatus.reason = options._error;\r\n\r\n    self.statusChanged();\r\n  },\r\n\r\n  _lostConnection: function () {\r\n    var self = this;\r\n\r\n    self._cleanup();\r\n    self._retryLater(); // sets status. no need to do it here.\r\n  },\r\n\r\n  // fired when we detect that we've gone online. try to reconnect\r\n  // immediately.\r\n  _online: function () {\r\n    // if we've requested to be offline by disconnecting, don't reconnect.\r\n    if (this.currentStatus.status != \"offline\")\r\n      this.reconnect();\r\n  },\r\n\r\n  _retryLater: function () {\r\n    var self = this;\r\n\r\n    var timeout = 0;\r\n    if (self.options.retry) {\r\n      timeout = self._retry.retryLater(\r\n        self.currentStatus.retryCount,\r\n        _.bind(self._retryNow, self)\r\n      );\r\n    }\r\n\r\n    self.currentStatus.status = \"waiting\";\r\n    self.currentStatus.connected = false;\r\n    self.currentStatus.retryTime = (new Date()).getTime() + timeout;\r\n    self.statusChanged();\r\n  },\r\n\r\n  _retryNow: function () {\r\n    var self = this;\r\n\r\n    if (self._forcedToDisconnect)\r\n      return;\r\n\r\n    self.currentStatus.retryCount += 1;\r\n    self.currentStatus.status = \"connecting\";\r\n    self.currentStatus.connected = false;\r\n    delete self.currentStatus.retryTime;\r\n    self.statusChanged();\r\n\r\n    self._launchConnection();\r\n  },\r\n\r\n\r\n  // Get current status. Reactive.\r\n  status: function () {\r\n    var self = this;\r\n    if (self.statusListeners)\r\n      self.statusListeners.depend();\r\n    return self.currentStatus;\r\n  }\r\n});\r\n","var url = Npm.require('url');\r\n\r\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX ||  \"\";\r\n\r\nStreamServer = function () {\r\n  var self = this;\r\n  self.registration_callbacks = [];\r\n  self.open_sockets = [];\r\n\r\n  // Because we are installing directly onto WebApp.httpServer instead of using\r\n  // WebApp.app, we have to process the path prefix ourselves.\r\n  self.prefix = pathPrefix + '/sockjs';\r\n  // routepolicy is only a weak dependency, because we don't need it if we're\r\n  // just doing server-to-server DDP as a client.\r\n  if (Package.routepolicy) {\r\n    Package.routepolicy.RoutePolicy.declare(self.prefix + '/', 'network');\r\n  }\r\n\r\n  // set up sockjs\r\n  var sockjs = Npm.require('sockjs');\r\n  var serverOptions = {\r\n    prefix: self.prefix,\r\n    log: function() {},\r\n    // this is the default, but we code it explicitly because we depend\r\n    // on it in stream_client:HEARTBEAT_TIMEOUT\r\n    heartbeat_delay: 45000,\r\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\r\n    // bound for that much time, SockJS might not notice that the user has\r\n    // reconnected because the timer (of disconnect_delay ms) can fire before\r\n    // SockJS processes the new connection. Eventually we'll fix this by not\r\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\r\n    // converts to Unix sockets) but for now, raise the delay.\r\n    disconnect_delay: 60 * 1000,\r\n    // Set the USE_JSESSIONID environment variable to enable setting the\r\n    // JSESSIONID cookie. This is useful for setting up proxies with\r\n    // session affinity.\r\n    jsessionid: !!process.env.USE_JSESSIONID\r\n  };\r\n\r\n  // If you know your server environment (eg, proxies) will prevent websockets\r\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\r\n  // browsers) will not waste time attempting to use them.\r\n  // (Your server will still have a /websocket endpoint.)\r\n  if (process.env.DISABLE_WEBSOCKETS)\r\n    serverOptions.websocket = false;\r\n\r\n  self.server = sockjs.createServer(serverOptions);\r\n  if (!Package.webapp) {\r\n    throw new Error(\"Cannot create a DDP server without the webapp package\");\r\n  }\r\n  // Install the sockjs handlers, but we want to keep around our own particular\r\n  // request handler that adjusts idle timeouts while we have an outstanding\r\n  // request.  This compensates for the fact that sockjs removes all listeners\r\n  // for \"request\" to add its own.\r\n  Package.webapp.WebApp.httpServer.removeListener('request', Package.webapp.WebApp._timeoutAdjustmentRequestCallback);\r\n  self.server.installHandlers(Package.webapp.WebApp.httpServer);\r\n  Package.webapp.WebApp.httpServer.addListener('request', Package.webapp.WebApp._timeoutAdjustmentRequestCallback);\r\n\r\n  Package.webapp.WebApp.httpServer.on('meteor-closing', function () {\r\n    _.each(self.open_sockets, function (socket) {\r\n      socket.end();\r\n    });\r\n  });\r\n\r\n  // Support the /websocket endpoint\r\n  self._redirectWebsocketEndpoint();\r\n\r\n  self.server.on('connection', function (socket) {\r\n\r\n    if (Package.webapp.WebAppInternals.usingDdpProxy) {\r\n      // If we are behind a DDP proxy, immediately close any sockjs connections\r\n      // that are not using websockets; the proxy will terminate sockjs for us,\r\n      // so we don't expect to be handling any other transports.\r\n      if (socket.protocol !== \"websocket\" &&\r\n          socket.protocol !== \"websocket-raw\") {\r\n        socket.close();\r\n        return;\r\n      }\r\n    }\r\n\r\n    socket.send = function (data) {\r\n      socket.write(data);\r\n    };\r\n    socket.on('close', function () {\r\n      self.open_sockets = _.without(self.open_sockets, socket);\r\n    });\r\n    self.open_sockets.push(socket);\r\n\r\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which\r\n    // will force old clients to reload. Remove this once we're not\r\n    // concerned about people upgrading from a pre-0.7.0 release. Also,\r\n    // remove the clause in the client that ignores the welcome message\r\n    // (livedata_connection.js)\r\n    socket.send(JSON.stringify({server_id: \"0\"}));\r\n\r\n    // call all our callbacks when we get a new socket. they will do the\r\n    // work of setting up handlers and such for specific messages.\r\n    _.each(self.registration_callbacks, function (callback) {\r\n      callback(socket);\r\n    });\r\n  });\r\n\r\n};\r\n\r\n_.extend(StreamServer.prototype, {\r\n  // call my callback when a new socket connects.\r\n  // also call it for all current connections.\r\n  register: function (callback) {\r\n    var self = this;\r\n    self.registration_callbacks.push(callback);\r\n    _.each(self.all_sockets(), function (socket) {\r\n      callback(socket);\r\n    });\r\n  },\r\n\r\n  // get a list of all sockets\r\n  all_sockets: function () {\r\n    var self = this;\r\n    return _.values(self.open_sockets);\r\n  },\r\n\r\n  // Redirect /websocket to /sockjs/websocket in order to not expose\r\n  // sockjs to clients that want to use raw websockets\r\n  _redirectWebsocketEndpoint: function() {\r\n    var self = this;\r\n    // Unfortunately we can't use a connect middleware here since\r\n    // sockjs installs itself prior to all existing listeners\r\n    // (meaning prior to any connect middlewares) so we need to take\r\n    // an approach similar to overshadowListeners in\r\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\r\n    _.each(['request', 'upgrade'], function(event) {\r\n      var httpServer = Package.webapp.WebApp.httpServer;\r\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);\r\n      httpServer.removeAllListeners(event);\r\n\r\n      // request and upgrade have different arguments passed but\r\n      // we only care about the first one which is always request\r\n      var newListener = function(request /*, moreArguments */) {\r\n        // Store arguments for use within the closure below\r\n        var args = arguments;\r\n\r\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\r\n        // preserving query string.\r\n        var parsedUrl = url.parse(request.url);\r\n        if (parsedUrl.pathname === pathPrefix + '/websocket' ||\r\n            parsedUrl.pathname === pathPrefix + '/websocket/') {\r\n          parsedUrl.pathname = self.prefix + '/websocket';\r\n          request.url = url.format(parsedUrl);\r\n        }\r\n        _.each(oldHttpServerListeners, function(oldListener) {\r\n          oldListener.apply(httpServer, args);\r\n        });\r\n      };\r\n      httpServer.addListener(event, newListener);\r\n    });\r\n  }\r\n});\r\n","// Heartbeat options:\r\n//   heartbeatInterval: interval to send pings, in milliseconds.\r\n//   heartbeatTimeout: timeout to close the connection if a reply isn't\r\n//     received, in milliseconds.\r\n//   sendPing: function to call to send a ping on the connection.\r\n//   onTimeout: function to call to close the connection.\r\n\r\nHeartbeat = function (options) {\r\n  var self = this;\r\n\r\n  self.heartbeatInterval = options.heartbeatInterval;\r\n  self.heartbeatTimeout = options.heartbeatTimeout;\r\n  self._sendPing = options.sendPing;\r\n  self._onTimeout = options.onTimeout;\r\n\r\n  self._heartbeatIntervalHandle = null;\r\n  self._heartbeatTimeoutHandle = null;\r\n};\r\n\r\n_.extend(Heartbeat.prototype, {\r\n  stop: function () {\r\n    var self = this;\r\n    self._clearHeartbeatIntervalTimer();\r\n    self._clearHeartbeatTimeoutTimer();\r\n  },\r\n\r\n  start: function () {\r\n    var self = this;\r\n    self.stop();\r\n    self._startHeartbeatIntervalTimer();\r\n  },\r\n\r\n  _startHeartbeatIntervalTimer: function () {\r\n    var self = this;\r\n    self._heartbeatIntervalHandle = Meteor.setTimeout(\r\n      _.bind(self._heartbeatIntervalFired, self),\r\n      self.heartbeatInterval\r\n    );\r\n  },\r\n\r\n  _startHeartbeatTimeoutTimer: function () {\r\n    var self = this;\r\n    self._heartbeatTimeoutHandle = Meteor.setTimeout(\r\n      _.bind(self._heartbeatTimeoutFired, self),\r\n      self.heartbeatTimeout\r\n    );\r\n  },\r\n\r\n  _clearHeartbeatIntervalTimer: function () {\r\n    var self = this;\r\n    if (self._heartbeatIntervalHandle) {\r\n      Meteor.clearTimeout(self._heartbeatIntervalHandle);\r\n      self._heartbeatIntervalHandle = null;\r\n    }\r\n  },\r\n\r\n  _clearHeartbeatTimeoutTimer: function () {\r\n    var self = this;\r\n    if (self._heartbeatTimeoutHandle) {\r\n      Meteor.clearTimeout(self._heartbeatTimeoutHandle);\r\n      self._heartbeatTimeoutHandle = null;\r\n    }\r\n  },\r\n\r\n  // The heartbeat interval timer is fired when we should send a ping.\r\n  _heartbeatIntervalFired: function () {\r\n    var self = this;\r\n    self._heartbeatIntervalHandle = null;\r\n    self._sendPing();\r\n    // Wait for a pong.\r\n    self._startHeartbeatTimeoutTimer();\r\n  },\r\n\r\n  // The heartbeat timeout timer is fired when we sent a ping, but we\r\n  // timed out waiting for the pong.\r\n  _heartbeatTimeoutFired: function () {\r\n    var self = this;\r\n    self._heartbeatTimeoutHandle = null;\r\n    self._onTimeout();\r\n  },\r\n\r\n  pingReceived: function () {\r\n    var self = this;\r\n    // We know the connection is alive if we receive a ping, so we\r\n    // don't need to send a ping ourselves.  Reset the interval timer.\r\n    if (self._heartbeatIntervalHandle) {\r\n      self._clearHeartbeatIntervalTimer();\r\n      self._startHeartbeatIntervalTimer();\r\n    }\r\n  },\r\n\r\n  pongReceived: function () {\r\n    var self = this;\r\n\r\n    // Receiving a pong means we won't timeout, so clear the timeout\r\n    // timer and start the interval again.\r\n    if (self._heartbeatTimeoutHandle) {\r\n      self._clearHeartbeatTimeoutTimer();\r\n      self._startHeartbeatIntervalTimer();\r\n    }\r\n  }\r\n});\r\n","DDPServer = {};\r\n\r\nvar Fiber = Npm.require('fibers');\r\n\r\n// This file contains classes:\r\n// * Session - The server's connection to a single DDP client\r\n// * Subscription - A single subscription for a single client\r\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\r\n//\r\n// Session and Subscription are file scope. For now, until we freeze\r\n// the interface, Server is package scope (in the future it should be\r\n// exported.)\r\n\r\n// Represents a single document in a SessionCollectionView\r\nvar SessionDocumentView = function () {\r\n  var self = this;\r\n  self.existsIn = {}; // set of subscriptionHandle\r\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]\r\n};\r\n\r\n_.extend(SessionDocumentView.prototype, {\r\n\r\n  getFields: function () {\r\n    var self = this;\r\n    var ret = {};\r\n    _.each(self.dataByKey, function (precedenceList, key) {\r\n      ret[key] = precedenceList[0].value;\r\n    });\r\n    return ret;\r\n  },\r\n\r\n  clearField: function (subscriptionHandle, key, changeCollector) {\r\n    var self = this;\r\n    // Publish API ignores _id if present in fields\r\n    if (key === \"_id\")\r\n      return;\r\n    var precedenceList = self.dataByKey[key];\r\n\r\n    // It's okay to clear fields that didn't exist. No need to throw\r\n    // an error.\r\n    if (!precedenceList)\r\n      return;\r\n\r\n    var removedValue = undefined;\r\n    for (var i = 0; i < precedenceList.length; i++) {\r\n      var precedence = precedenceList[i];\r\n      if (precedence.subscriptionHandle === subscriptionHandle) {\r\n        // The view's value can only change if this subscription is the one that\r\n        // used to have precedence.\r\n        if (i === 0)\r\n          removedValue = precedence.value;\r\n        precedenceList.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n    if (_.isEmpty(precedenceList)) {\r\n      delete self.dataByKey[key];\r\n      changeCollector[key] = undefined;\r\n    } else if (removedValue !== undefined &&\r\n               !EJSON.equals(removedValue, precedenceList[0].value)) {\r\n      changeCollector[key] = precedenceList[0].value;\r\n    }\r\n  },\r\n\r\n  changeField: function (subscriptionHandle, key, value,\r\n                         changeCollector, isAdd) {\r\n    var self = this;\r\n    // Publish API ignores _id if present in fields\r\n    if (key === \"_id\")\r\n      return;\r\n\r\n    // Don't share state with the data passed in by the user.\r\n    value = EJSON.clone(value);\r\n\r\n    if (!_.has(self.dataByKey, key)) {\r\n      self.dataByKey[key] = [{subscriptionHandle: subscriptionHandle,\r\n                              value: value}];\r\n      changeCollector[key] = value;\r\n      return;\r\n    }\r\n    var precedenceList = self.dataByKey[key];\r\n    var elt;\r\n    if (!isAdd) {\r\n      elt = _.find(precedenceList, function (precedence) {\r\n        return precedence.subscriptionHandle === subscriptionHandle;\r\n      });\r\n    }\r\n\r\n    if (elt) {\r\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\r\n        // this subscription is changing the value of this field.\r\n        changeCollector[key] = value;\r\n      }\r\n      elt.value = value;\r\n    } else {\r\n      // this subscription is newly caring about this field\r\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});\r\n    }\r\n\r\n  }\r\n});\r\n\r\n// Represents a client's view of a single collection\r\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\r\n  var self = this;\r\n  self.collectionName = collectionName;\r\n  self.documents = {};\r\n  self.callbacks = sessionCallbacks;\r\n};\r\n\r\nLivedataTest.SessionCollectionView = SessionCollectionView;\r\n\r\n\r\n_.extend(SessionCollectionView.prototype, {\r\n\r\n  isEmpty: function () {\r\n    var self = this;\r\n    return _.isEmpty(self.documents);\r\n  },\r\n\r\n  diff: function (previous) {\r\n    var self = this;\r\n    LocalCollection._diffObjects(previous.documents, self.documents, {\r\n      both: _.bind(self.diffDocument, self),\r\n\r\n      rightOnly: function (id, nowDV) {\r\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\r\n      },\r\n\r\n      leftOnly: function (id, prevDV) {\r\n        self.callbacks.removed(self.collectionName, id);\r\n      }\r\n    });\r\n  },\r\n\r\n  diffDocument: function (id, prevDV, nowDV) {\r\n    var self = this;\r\n    var fields = {};\r\n    LocalCollection._diffObjects(prevDV.getFields(), nowDV.getFields(), {\r\n      both: function (key, prev, now) {\r\n        if (!EJSON.equals(prev, now))\r\n          fields[key] = now;\r\n      },\r\n      rightOnly: function (key, now) {\r\n        fields[key] = now;\r\n      },\r\n      leftOnly: function(key, prev) {\r\n        fields[key] = undefined;\r\n      }\r\n    });\r\n    self.callbacks.changed(self.collectionName, id, fields);\r\n  },\r\n\r\n  added: function (subscriptionHandle, id, fields) {\r\n    var self = this;\r\n    var docView = self.documents[id];\r\n    var added = false;\r\n    if (!docView) {\r\n      added = true;\r\n      docView = new SessionDocumentView();\r\n      self.documents[id] = docView;\r\n    }\r\n    docView.existsIn[subscriptionHandle] = true;\r\n    var changeCollector = {};\r\n    _.each(fields, function (value, key) {\r\n      docView.changeField(\r\n        subscriptionHandle, key, value, changeCollector, true);\r\n    });\r\n    if (added)\r\n      self.callbacks.added(self.collectionName, id, changeCollector);\r\n    else\r\n      self.callbacks.changed(self.collectionName, id, changeCollector);\r\n  },\r\n\r\n  changed: function (subscriptionHandle, id, changed) {\r\n    var self = this;\r\n    var changedResult = {};\r\n    var docView = self.documents[id];\r\n    if (!docView)\r\n      throw new Error(\"Could not find element with id \" + id + \" to change\");\r\n    _.each(changed, function (value, key) {\r\n      if (value === undefined)\r\n        docView.clearField(subscriptionHandle, key, changedResult);\r\n      else\r\n        docView.changeField(subscriptionHandle, key, value, changedResult);\r\n    });\r\n    self.callbacks.changed(self.collectionName, id, changedResult);\r\n  },\r\n\r\n  removed: function (subscriptionHandle, id) {\r\n    var self = this;\r\n    var docView = self.documents[id];\r\n    if (!docView) {\r\n      var err = new Error(\"Removed nonexistent document \" + id);\r\n      throw err;\r\n    }\r\n    delete docView.existsIn[subscriptionHandle];\r\n    if (_.isEmpty(docView.existsIn)) {\r\n      // it is gone from everyone\r\n      self.callbacks.removed(self.collectionName, id);\r\n      delete self.documents[id];\r\n    } else {\r\n      var changed = {};\r\n      // remove this subscription from every precedence list\r\n      // and record the changes\r\n      _.each(docView.dataByKey, function (precedenceList, key) {\r\n        docView.clearField(subscriptionHandle, key, changed);\r\n      });\r\n\r\n      self.callbacks.changed(self.collectionName, id, changed);\r\n    }\r\n  }\r\n});\r\n\r\n/******************************************************************************/\r\n/* Session                                                                    */\r\n/******************************************************************************/\r\n\r\nvar Session = function (server, version, socket, options) {\r\n  var self = this;\r\n  self.id = Random.id();\r\n\r\n  self.server = server;\r\n  self.version = version;\r\n\r\n  self.initialized = false;\r\n  self.socket = socket;\r\n\r\n  // set to null when the session is destroyed. multiple places below\r\n  // use this to determine if the session is alive or not.\r\n  self.inQueue = [];\r\n\r\n  self.blocked = false;\r\n  self.workerRunning = false;\r\n\r\n  // Sub objects for active subscriptions\r\n  self._namedSubs = {};\r\n  self._universalSubs = [];\r\n\r\n  self.userId = null;\r\n\r\n  self.collectionViews = {};\r\n\r\n  // Set this to false to not send messages when collectionViews are\r\n  // modified. This is done when rerunning subs in _setUserId and those messages\r\n  // are calculated via a diff instead.\r\n  self._isSending = true;\r\n\r\n  // If this is true, don't start a newly-created universal publisher on this\r\n  // session. The session will take care of starting it when appropriate.\r\n  self._dontStartNewUniversalSubs = false;\r\n\r\n  // when we are rerunning subscriptions, any ready messages\r\n  // we want to buffer up for when we are done rerunning subscriptions\r\n  self._pendingReady = [];\r\n\r\n  // List of callbacks to call when this connection is closed.\r\n  self._closeCallbacks = [];\r\n\r\n\r\n  // XXX HACK: If a sockjs connection, save off the URL. This is\r\n  // temporary and will go away in the near future.\r\n  self._socketUrl = socket.url;\r\n\r\n  // Allow tests to disable responding to pings.\r\n  self._respondToPings = options.respondToPings;\r\n\r\n  // This object is the public interface to the session. In the public\r\n  // API, it is called the `connection` object.  Internally we call it\r\n  // a `connectionHandle` to avoid ambiguity.\r\n  self.connectionHandle = {\r\n    id: self.id,\r\n    close: function () {\r\n      self.close();\r\n    },\r\n    onClose: function (fn) {\r\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\r\n      if (self.inQueue) {\r\n        self._closeCallbacks.push(cb);\r\n      } else {\r\n        // if we're already closed, call the callback.\r\n        Meteor.defer(cb);\r\n      }\r\n    },\r\n    clientAddress: self._clientAddress(),\r\n    httpHeaders: self.socket.headers\r\n  };\r\n\r\n  socket.send(stringifyDDP({msg: 'connected',\r\n                            session: self.id}));\r\n  // On initial connect, spin up all the universal publishers.\r\n  Fiber(function () {\r\n    self.startUniversalSubs();\r\n  }).run();\r\n\r\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\r\n    self.heartbeat = new Heartbeat({\r\n      heartbeatInterval: options.heartbeatInterval,\r\n      heartbeatTimeout: options.heartbeatTimeout,\r\n      onTimeout: function () {\r\n        self.close();\r\n      },\r\n      sendPing: function () {\r\n        self.send({msg: 'ping'});\r\n      }\r\n    });\r\n    self.heartbeat.start();\r\n  }\r\n\r\n  Package.facts && Package.facts.Facts.incrementServerFact(\r\n    \"livedata\", \"sessions\", 1);\r\n};\r\n\r\n_.extend(Session.prototype, {\r\n\r\n  sendReady: function (subscriptionIds) {\r\n    var self = this;\r\n    if (self._isSending)\r\n      self.send({msg: \"ready\", subs: subscriptionIds});\r\n    else {\r\n      _.each(subscriptionIds, function (subscriptionId) {\r\n        self._pendingReady.push(subscriptionId);\r\n      });\r\n    }\r\n  },\r\n\r\n  sendAdded: function (collectionName, id, fields) {\r\n    var self = this;\r\n    if (self._isSending)\r\n      self.send({msg: \"added\", collection: collectionName, id: id, fields: fields});\r\n  },\r\n\r\n  sendChanged: function (collectionName, id, fields) {\r\n    var self = this;\r\n    if (_.isEmpty(fields))\r\n      return;\r\n\r\n    if (self._isSending) {\r\n      self.send({\r\n        msg: \"changed\",\r\n        collection: collectionName,\r\n        id: id,\r\n        fields: fields\r\n      });\r\n    }\r\n  },\r\n\r\n  sendRemoved: function (collectionName, id) {\r\n    var self = this;\r\n    if (self._isSending)\r\n      self.send({msg: \"removed\", collection: collectionName, id: id});\r\n  },\r\n\r\n  getSendCallbacks: function () {\r\n    var self = this;\r\n    return {\r\n      added: _.bind(self.sendAdded, self),\r\n      changed: _.bind(self.sendChanged, self),\r\n      removed: _.bind(self.sendRemoved, self)\r\n    };\r\n  },\r\n\r\n  getCollectionView: function (collectionName) {\r\n    var self = this;\r\n    if (_.has(self.collectionViews, collectionName)) {\r\n      return self.collectionViews[collectionName];\r\n    }\r\n    var ret = new SessionCollectionView(collectionName,\r\n                                        self.getSendCallbacks());\r\n    self.collectionViews[collectionName] = ret;\r\n    return ret;\r\n  },\r\n\r\n  added: function (subscriptionHandle, collectionName, id, fields) {\r\n    var self = this;\r\n    var view = self.getCollectionView(collectionName);\r\n    view.added(subscriptionHandle, id, fields);\r\n  },\r\n\r\n  removed: function (subscriptionHandle, collectionName, id) {\r\n    var self = this;\r\n    var view = self.getCollectionView(collectionName);\r\n    view.removed(subscriptionHandle, id);\r\n    if (view.isEmpty()) {\r\n      delete self.collectionViews[collectionName];\r\n    }\r\n  },\r\n\r\n  changed: function (subscriptionHandle, collectionName, id, fields) {\r\n    var self = this;\r\n    var view = self.getCollectionView(collectionName);\r\n    view.changed(subscriptionHandle, id, fields);\r\n  },\r\n\r\n  startUniversalSubs: function () {\r\n    var self = this;\r\n    // Make a shallow copy of the set of universal handlers and start them. If\r\n    // additional universal publishers start while we're running them (due to\r\n    // yielding), they will run separately as part of Server.publish.\r\n    var handlers = _.clone(self.server.universal_publish_handlers);\r\n    _.each(handlers, function (handler) {\r\n      self._startSubscription(handler);\r\n    });\r\n  },\r\n\r\n  // Destroy this session and unregister it at the server.\r\n  close: function () {\r\n    var self = this;\r\n\r\n    // Destroy this session, even if it's not registered at the\r\n    // server. Stop all processing and tear everything down. If a socket\r\n    // was attached, close it.\r\n\r\n    // Already destroyed.\r\n    if (! self.inQueue)\r\n      return;\r\n\r\n    if (self.heartbeat) {\r\n      self.heartbeat.stop();\r\n      self.heartbeat = null;\r\n    }\r\n\r\n    if (self.socket) {\r\n      self.socket.close();\r\n      self.socket._meteorSession = null;\r\n    }\r\n\r\n    // Drop the merge box data immediately.\r\n    self.collectionViews = {};\r\n    self.inQueue = null;\r\n\r\n    Package.facts && Package.facts.Facts.incrementServerFact(\r\n      \"livedata\", \"sessions\", -1);\r\n\r\n    Meteor.defer(function () {\r\n      // stop callbacks can yield, so we defer this on close.\r\n      // sub._isDeactivated() detects that we set inQueue to null and\r\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\r\n      self._deactivateAllSubscriptions();\r\n\r\n      // Defer calling the close callbacks, so that the caller closing\r\n      // the session isn't waiting for all the callbacks to complete.\r\n      _.each(self._closeCallbacks, function (callback) {\r\n        callback();\r\n      });\r\n    });\r\n\r\n    // Unregister the session.\r\n    self.server._removeSession(self);\r\n  },\r\n\r\n  // Send a message (doing nothing if no socket is connected right now.)\r\n  // It should be a JSON object (it will be stringified.)\r\n  send: function (msg) {\r\n    var self = this;\r\n    if (self.socket) {\r\n      if (Meteor._printSentDDP)\r\n        Meteor._debug(\"Sent DDP\", stringifyDDP(msg));\r\n      self.socket.send(stringifyDDP(msg));\r\n    }\r\n  },\r\n\r\n  // Send a connection error.\r\n  sendError: function (reason, offendingMessage) {\r\n    var self = this;\r\n    var msg = {msg: 'error', reason: reason};\r\n    if (offendingMessage)\r\n      msg.offendingMessage = offendingMessage;\r\n    self.send(msg);\r\n  },\r\n\r\n  // Process 'msg' as an incoming message. (But as a guard against\r\n  // race conditions during reconnection, ignore the message if\r\n  // 'socket' is not the currently connected socket.)\r\n  //\r\n  // We run the messages from the client one at a time, in the order\r\n  // given by the client. The message handler is passed an idempotent\r\n  // function 'unblock' which it may call to allow other messages to\r\n  // begin running in parallel in another fiber (for example, a method\r\n  // that wants to yield.) Otherwise, it is automatically unblocked\r\n  // when it returns.\r\n  //\r\n  // Actually, we don't have to 'totally order' the messages in this\r\n  // way, but it's the easiest thing that's correct. (unsub needs to\r\n  // be ordered against sub, methods need to be ordered against each\r\n  // other.)\r\n  processMessage: function (msg_in) {\r\n    var self = this;\r\n    if (!self.inQueue) // we have been destroyed.\r\n      return;\r\n\r\n    // Respond to ping and pong messages immediately without queuing.\r\n    // If the negotiated DDP version is \"pre1\" which didn't support\r\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\r\n    // request\" for the unknown messages.\r\n    //\r\n    // Fibers are needed because heartbeat uses Meteor.setTimeout, which\r\n    // needs a Fiber. We could actually use regular setTimeout and avoid\r\n    // these new fibers, but it is easier to just make everything use\r\n    // Meteor.setTimeout and not think too hard.\r\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\r\n      if (self._respondToPings)\r\n        self.send({msg: \"pong\", id: msg_in.id});\r\n      if (self.heartbeat)\r\n        Fiber(function () {\r\n          self.heartbeat.pingReceived();\r\n        }).run();\r\n      return;\r\n    }\r\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\r\n      if (self.heartbeat)\r\n        Fiber(function () {\r\n          self.heartbeat.pongReceived();\r\n        }).run();\r\n      return;\r\n    }\r\n\r\n    self.inQueue.push(msg_in);\r\n    if (self.workerRunning)\r\n      return;\r\n    self.workerRunning = true;\r\n\r\n    var processNext = function () {\r\n      var msg = self.inQueue && self.inQueue.shift();\r\n      if (!msg) {\r\n        self.workerRunning = false;\r\n        return;\r\n      }\r\n\r\n      Fiber(function () {\r\n        var blocked = true;\r\n\r\n        var unblock = function () {\r\n          if (!blocked)\r\n            return; // idempotent\r\n          blocked = false;\r\n          processNext();\r\n        };\r\n\r\n        if (_.has(self.protocol_handlers, msg.msg))\r\n          self.protocol_handlers[msg.msg].call(self, msg, unblock);\r\n        else\r\n          self.sendError('Bad request', msg);\r\n        unblock(); // in case the handler didn't already do it\r\n      }).run();\r\n    };\r\n\r\n    processNext();\r\n  },\r\n\r\n  protocol_handlers: {\r\n    sub: function (msg) {\r\n      var self = this;\r\n\r\n      // reject malformed messages\r\n      if (typeof (msg.id) !== \"string\" ||\r\n          typeof (msg.name) !== \"string\" ||\r\n          (('params' in msg) && !(msg.params instanceof Array))) {\r\n        self.sendError(\"Malformed subscription\", msg);\r\n        return;\r\n      }\r\n\r\n      if (!self.server.publish_handlers[msg.name]) {\r\n        self.send({\r\n          msg: 'nosub', id: msg.id,\r\n          error: new Meteor.Error(404, \"Subscription not found\")});\r\n        return;\r\n      }\r\n\r\n      if (_.has(self._namedSubs, msg.id))\r\n        // subs are idempotent, or rather, they are ignored if a sub\r\n        // with that id already exists. this is important during\r\n        // reconnect.\r\n        return;\r\n\r\n      var handler = self.server.publish_handlers[msg.name];\r\n      self._startSubscription(handler, msg.id, msg.params, msg.name);\r\n\r\n    },\r\n\r\n    unsub: function (msg) {\r\n      var self = this;\r\n\r\n      self._stopSubscription(msg.id);\r\n    },\r\n\r\n    method: function (msg, unblock) {\r\n      var self = this;\r\n\r\n      // reject malformed messages\r\n      // For now, we silently ignore unknown attributes,\r\n      // for forwards compatibility.\r\n      if (typeof (msg.id) !== \"string\" ||\r\n          typeof (msg.method) !== \"string\" ||\r\n          (('params' in msg) && !(msg.params instanceof Array)) ||\r\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {\r\n        self.sendError(\"Malformed method invocation\", msg);\r\n        return;\r\n      }\r\n\r\n      var randomSeed = msg.randomSeed || null;\r\n\r\n      // set up to mark the method as satisfied once all observers\r\n      // (and subscriptions) have reacted to any writes that were\r\n      // done.\r\n      var fence = new DDPServer._WriteFence;\r\n      fence.onAllCommitted(function () {\r\n        // Retire the fence so that future writes are allowed.\r\n        // This means that callbacks like timers are free to use\r\n        // the fence, and if they fire before it's armed (for\r\n        // example, because the method waits for them) their\r\n        // writes will be included in the fence.\r\n        fence.retire();\r\n        self.send({\r\n          msg: 'updated', methods: [msg.id]});\r\n      });\r\n\r\n      // find the handler\r\n      var handler = self.server.method_handlers[msg.method];\r\n      if (!handler) {\r\n        self.send({\r\n          msg: 'result', id: msg.id,\r\n          error: new Meteor.Error(404, \"Method not found\")});\r\n        fence.arm();\r\n        return;\r\n      }\r\n\r\n      var setUserId = function(userId) {\r\n        self._setUserId(userId);\r\n      };\r\n\r\n      var invocation = new MethodInvocation({\r\n        isSimulation: false,\r\n        userId: self.userId,\r\n        setUserId: setUserId,\r\n        unblock: unblock,\r\n        connection: self.connectionHandle,\r\n        randomSeed: randomSeed\r\n      });\r\n      try {\r\n        var result = DDPServer._CurrentWriteFence.withValue(fence, function () {\r\n          return DDP._CurrentInvocation.withValue(invocation, function () {\r\n            return maybeAuditArgumentChecks(\r\n              handler, invocation, msg.params, \"call to '\" + msg.method + \"'\");\r\n          });\r\n        });\r\n      } catch (e) {\r\n        var exception = e;\r\n      }\r\n\r\n      fence.arm(); // we're done adding writes to the fence\r\n      unblock(); // unblock, if the method hasn't done it already\r\n\r\n      exception = wrapInternalException(\r\n        exception, \"while invoking method '\" + msg.method + \"'\");\r\n\r\n      // send response and add to cache\r\n      var payload =\r\n        exception ? {error: exception} : (result !== undefined ?\r\n                                          {result: result} : {});\r\n      self.send(_.extend({msg: 'result', id: msg.id}, payload));\r\n    }\r\n  },\r\n\r\n  _eachSub: function (f) {\r\n    var self = this;\r\n    _.each(self._namedSubs, f);\r\n    _.each(self._universalSubs, f);\r\n  },\r\n\r\n  _diffCollectionViews: function (beforeCVs) {\r\n    var self = this;\r\n    LocalCollection._diffObjects(beforeCVs, self.collectionViews, {\r\n      both: function (collectionName, leftValue, rightValue) {\r\n        rightValue.diff(leftValue);\r\n      },\r\n      rightOnly: function (collectionName, rightValue) {\r\n        _.each(rightValue.documents, function (docView, id) {\r\n          self.sendAdded(collectionName, id, docView.getFields());\r\n        });\r\n      },\r\n      leftOnly: function (collectionName, leftValue) {\r\n        _.each(leftValue.documents, function (doc, id) {\r\n          self.sendRemoved(collectionName, id);\r\n        });\r\n      }\r\n    });\r\n  },\r\n\r\n  // Sets the current user id in all appropriate contexts and reruns\r\n  // all subscriptions\r\n  _setUserId: function(userId) {\r\n    var self = this;\r\n\r\n    if (userId !== null && typeof userId !== \"string\")\r\n      throw new Error(\"setUserId must be called on string or null, not \" +\r\n                      typeof userId);\r\n\r\n    // Prevent newly-created universal subscriptions from being added to our\r\n    // session; they will be found below when we call startUniversalSubs.\r\n    //\r\n    // (We don't have to worry about named subscriptions, because we only add\r\n    // them when we process a 'sub' message. We are currently processing a\r\n    // 'method' message, and the method did not unblock, because it is illegal\r\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\r\n    // new named subscription.)\r\n    self._dontStartNewUniversalSubs = true;\r\n\r\n    // Prevent current subs from updating our collectionViews and call their\r\n    // stop callbacks. This may yield.\r\n    self._eachSub(function (sub) {\r\n      sub._deactivate();\r\n    });\r\n\r\n    // All subs should now be deactivated. Stop sending messages to the client,\r\n    // save the state of the published collections, reset to an empty view, and\r\n    // update the userId.\r\n    self._isSending = false;\r\n    var beforeCVs = self.collectionViews;\r\n    self.collectionViews = {};\r\n    self.userId = userId;\r\n\r\n    // Save the old named subs, and reset to having no subscriptions.\r\n    var oldNamedSubs = self._namedSubs;\r\n    self._namedSubs = {};\r\n    self._universalSubs = [];\r\n\r\n    _.each(oldNamedSubs, function (sub, subscriptionId) {\r\n      self._namedSubs[subscriptionId] = sub._recreate();\r\n      // nb: if the handler throws or calls this.error(), it will in fact\r\n      // immediately send its 'nosub'. This is OK, though.\r\n      self._namedSubs[subscriptionId]._runHandler();\r\n    });\r\n\r\n    // Allow newly-created universal subs to be started on our connection in\r\n    // parallel with the ones we're spinning up here, and spin up universal\r\n    // subs.\r\n    self._dontStartNewUniversalSubs = false;\r\n    self.startUniversalSubs();\r\n\r\n    // Start sending messages again, beginning with the diff from the previous\r\n    // state of the world to the current state. No yields are allowed during\r\n    // this diff, so that other changes cannot interleave.\r\n    Meteor._noYieldsAllowed(function () {\r\n      self._isSending = true;\r\n      self._diffCollectionViews(beforeCVs);\r\n      if (!_.isEmpty(self._pendingReady)) {\r\n        self.sendReady(self._pendingReady);\r\n        self._pendingReady = [];\r\n      }\r\n    });\r\n  },\r\n\r\n  _startSubscription: function (handler, subId, params, name) {\r\n    var self = this;\r\n\r\n    var sub = new Subscription(\r\n      self, handler, subId, params, name);\r\n    if (subId)\r\n      self._namedSubs[subId] = sub;\r\n    else\r\n      self._universalSubs.push(sub);\r\n\r\n    sub._runHandler();\r\n  },\r\n\r\n  // tear down specified subscription\r\n  _stopSubscription: function (subId, error) {\r\n    var self = this;\r\n\r\n    if (subId && self._namedSubs[subId]) {\r\n      self._namedSubs[subId]._removeAllDocuments();\r\n      self._namedSubs[subId]._deactivate();\r\n      delete self._namedSubs[subId];\r\n    }\r\n\r\n    var response = {msg: 'nosub', id: subId};\r\n\r\n    if (error)\r\n      response.error = wrapInternalException(error, \"from sub \" + subId);\r\n\r\n    self.send(response);\r\n  },\r\n\r\n  // tear down all subscriptions. Note that this does NOT send removed or nosub\r\n  // messages, since we assume the client is gone.\r\n  _deactivateAllSubscriptions: function () {\r\n    var self = this;\r\n\r\n    _.each(self._namedSubs, function (sub, id) {\r\n      sub._deactivate();\r\n    });\r\n    self._namedSubs = {};\r\n\r\n    _.each(self._universalSubs, function (sub) {\r\n      sub._deactivate();\r\n    });\r\n    self._universalSubs = [];\r\n  },\r\n\r\n  // Determine the remote client's IP address, based on the\r\n  // HTTP_FORWARDED_COUNT environment variable representing how many\r\n  // proxies the server is behind.\r\n  _clientAddress: function () {\r\n    var self = this;\r\n\r\n    // For the reported client address for a connection to be correct,\r\n    // the developer must set the HTTP_FORWARDED_COUNT environment\r\n    // variable to an integer representing the number of hops they\r\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\r\n    // server is behind one proxy.\r\n    //\r\n    // This could be computed once at startup instead of every time.\r\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\r\n\r\n    if (httpForwardedCount === 0)\r\n      return self.socket.remoteAddress;\r\n\r\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\r\n    if (! _.isString(forwardedFor))\r\n      return null;\r\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\r\n\r\n    // Typically the first value in the `x-forwarded-for` header is\r\n    // the original IP address of the client connecting to the first\r\n    // proxy.  However, the end user can easily spoof the header, in\r\n    // which case the first value(s) will be the fake IP address from\r\n    // the user pretending to be a proxy reporting the original IP\r\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\r\n    // end of the list, we ensure that we get the IP address being\r\n    // reported by *our* first proxy.\r\n\r\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)\r\n      return null;\r\n\r\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\r\n  }\r\n});\r\n\r\n/******************************************************************************/\r\n/* Subscription                                                               */\r\n/******************************************************************************/\r\n\r\n// ctor for a sub handle: the input to each publish function\r\nvar Subscription = function (\r\n    session, handler, subscriptionId, params, name) {\r\n  var self = this;\r\n  self._session = session; // type is Session\r\n  self.connection = session.connectionHandle; // public API object\r\n\r\n  self._handler = handler;\r\n\r\n  // my subscription ID (generated by client, undefined for universal subs).\r\n  self._subscriptionId = subscriptionId;\r\n  // undefined for universal subs\r\n  self._name = name;\r\n\r\n  self._params = params || [];\r\n\r\n  // Only named subscriptions have IDs, but we need some sort of string\r\n  // internally to keep track of all subscriptions inside\r\n  // SessionDocumentViews. We use this subscriptionHandle for that.\r\n  if (self._subscriptionId) {\r\n    self._subscriptionHandle = 'N' + self._subscriptionId;\r\n  } else {\r\n    self._subscriptionHandle = 'U' + Random.id();\r\n  }\r\n\r\n  // has _deactivate been called?\r\n  self._deactivated = false;\r\n\r\n  // stop callbacks to g/c this sub.  called w/ zero arguments.\r\n  self._stopCallbacks = [];\r\n\r\n  // the set of (collection, documentid) that this subscription has\r\n  // an opinion about\r\n  self._documents = {};\r\n\r\n  // remember if we are ready.\r\n  self._ready = false;\r\n\r\n  // Part of the public API: the user of this sub.\r\n  self.userId = session.userId;\r\n\r\n  // For now, the id filter is going to default to\r\n  // the to/from DDP methods on LocalCollection, to\r\n  // specifically deal with mongo/minimongo ObjectIds.\r\n\r\n  // Later, you will be able to make this be \"raw\"\r\n  // if you want to publish a collection that you know\r\n  // just has strings for keys and no funny business, to\r\n  // a ddp consumer that isn't minimongo\r\n\r\n  self._idFilter = {\r\n    idStringify: LocalCollection._idStringify,\r\n    idParse: LocalCollection._idParse\r\n  };\r\n\r\n  Package.facts && Package.facts.Facts.incrementServerFact(\r\n    \"livedata\", \"subscriptions\", 1);\r\n};\r\n\r\n_.extend(Subscription.prototype, {\r\n  _runHandler: function () {\r\n    // XXX should we unblock() here? Either before running the publish\r\n    // function, or before running _publishCursor.\r\n    //\r\n    // Right now, each publish function blocks all future publishes and\r\n    // methods waiting on data from Mongo (or whatever else the function\r\n    // blocks on). This probably slows page load in common cases.\r\n\r\n    var self = this;\r\n    try {\r\n      var res = maybeAuditArgumentChecks(\r\n        self._handler, self, EJSON.clone(self._params),\r\n        // It's OK that this would look weird for universal subscriptions,\r\n        // because they have no arguments so there can never be an\r\n        // audit-argument-checks failure.\r\n        \"publisher '\" + self._name + \"'\");\r\n    } catch (e) {\r\n      self.error(e);\r\n      return;\r\n    }\r\n\r\n    // Did the handler call this.error or this.stop?\r\n    if (self._isDeactivated())\r\n      return;\r\n\r\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\r\n    // this.added/changed/ready/etc, the user can just return a collection\r\n    // cursor or array of cursors from the publish function; we call their\r\n    // _publishCursor method which starts observing the cursor and publishes the\r\n    // results. Note that _publishCursor does NOT call ready().\r\n    //\r\n    // XXX This uses an undocumented interface which only the Mongo cursor\r\n    // interface publishes. Should we make this interface public and encourage\r\n    // users to implement it themselves? Arguably, it's unnecessary; users can\r\n    // already write their own functions like\r\n    //   var publishMyReactiveThingy = function (name, handler) {\r\n    //     Meteor.publish(name, function () {\r\n    //       var reactiveThingy = handler();\r\n    //       reactiveThingy.publishMe();\r\n    //     });\r\n    //   };\r\n    var isCursor = function (c) {\r\n      return c && c._publishCursor;\r\n    };\r\n    if (isCursor(res)) {\r\n      res._publishCursor(self);\r\n      // _publishCursor only returns after the initial added callbacks have run.\r\n      // mark subscription as ready.\r\n      self.ready();\r\n    } else if (_.isArray(res)) {\r\n      // check all the elements are cursors\r\n      if (! _.all(res, isCursor)) {\r\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\r\n        return;\r\n      }\r\n      // find duplicate collection names\r\n      // XXX we should support overlapping cursors, but that would require the\r\n      // merge box to allow overlap within a subscription\r\n      var collectionNames = {};\r\n      for (var i = 0; i < res.length; ++i) {\r\n        var collectionName = res[i]._getCollectionName();\r\n        if (_.has(collectionNames, collectionName)) {\r\n          self.error(new Error(\r\n            \"Publish function returned multiple cursors for collection \" +\r\n              collectionName));\r\n          return;\r\n        }\r\n        collectionNames[collectionName] = true;\r\n      };\r\n\r\n      _.each(res, function (cur) {\r\n        cur._publishCursor(self);\r\n      });\r\n      self.ready();\r\n    } else if (res) {\r\n      // truthy values other than cursors or arrays are probably a\r\n      // user mistake (possible returning a Mongo document via, say,\r\n      // `coll.findOne()`).\r\n      self.error(new Error(\"Publish function can only return a Cursor or \"\r\n                           + \"an array of Cursors\"));\r\n    }\r\n  },\r\n\r\n  // This calls all stop callbacks and prevents the handler from updating any\r\n  // SessionCollectionViews further. It's used when the user unsubscribes or\r\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\r\n  // removed messages for the published objects; if that is necessary, call\r\n  // _removeAllDocuments first.\r\n  _deactivate: function() {\r\n    var self = this;\r\n    if (self._deactivated)\r\n      return;\r\n    self._deactivated = true;\r\n    self._callStopCallbacks();\r\n    Package.facts && Package.facts.Facts.incrementServerFact(\r\n      \"livedata\", \"subscriptions\", -1);\r\n  },\r\n\r\n  _callStopCallbacks: function () {\r\n    var self = this;\r\n    // tell listeners, so they can clean up\r\n    var callbacks = self._stopCallbacks;\r\n    self._stopCallbacks = [];\r\n    _.each(callbacks, function (callback) {\r\n      callback();\r\n    });\r\n  },\r\n\r\n  // Send remove messages for every document.\r\n  _removeAllDocuments: function () {\r\n    var self = this;\r\n    Meteor._noYieldsAllowed(function () {\r\n      _.each(self._documents, function(collectionDocs, collectionName) {\r\n        // Iterate over _.keys instead of the dictionary itself, since we'll be\r\n        // mutating it.\r\n        _.each(_.keys(collectionDocs), function (strId) {\r\n          self.removed(collectionName, self._idFilter.idParse(strId));\r\n        });\r\n      });\r\n    });\r\n  },\r\n\r\n  // Returns a new Subscription for the same session with the same\r\n  // initial creation parameters. This isn't a clone: it doesn't have\r\n  // the same _documents cache, stopped state or callbacks; may have a\r\n  // different _subscriptionHandle, and gets its userId from the\r\n  // session, not from this object.\r\n  _recreate: function () {\r\n    var self = this;\r\n    return new Subscription(\r\n      self._session, self._handler, self._subscriptionId, self._params,\r\n      self._name);\r\n  },\r\n\r\n  error: function (error) {\r\n    var self = this;\r\n    if (self._isDeactivated())\r\n      return;\r\n    self._session._stopSubscription(self._subscriptionId, error);\r\n  },\r\n\r\n  // Note that while our DDP client will notice that you've called stop() on the\r\n  // server (and clean up its _subscriptions table) we don't actually provide a\r\n  // mechanism for an app to notice this (the subscribe onError callback only\r\n  // triggers if there is an error).\r\n  stop: function () {\r\n    var self = this;\r\n    if (self._isDeactivated())\r\n      return;\r\n    self._session._stopSubscription(self._subscriptionId);\r\n  },\r\n\r\n  onStop: function (callback) {\r\n    var self = this;\r\n    if (self._isDeactivated())\r\n      callback();\r\n    else\r\n      self._stopCallbacks.push(callback);\r\n  },\r\n\r\n  // This returns true if the sub has been deactivated, *OR* if the session was\r\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\r\n  // happened yet.\r\n  _isDeactivated: function () {\r\n    var self = this;\r\n    return self._deactivated || self._session.inQueue === null;\r\n  },\r\n\r\n  added: function (collectionName, id, fields) {\r\n    var self = this;\r\n    if (self._isDeactivated())\r\n      return;\r\n    id = self._idFilter.idStringify(id);\r\n    Meteor._ensure(self._documents, collectionName)[id] = true;\r\n    self._session.added(self._subscriptionHandle, collectionName, id, fields);\r\n  },\r\n\r\n  changed: function (collectionName, id, fields) {\r\n    var self = this;\r\n    if (self._isDeactivated())\r\n      return;\r\n    id = self._idFilter.idStringify(id);\r\n    self._session.changed(self._subscriptionHandle, collectionName, id, fields);\r\n  },\r\n\r\n  removed: function (collectionName, id) {\r\n    var self = this;\r\n    if (self._isDeactivated())\r\n      return;\r\n    id = self._idFilter.idStringify(id);\r\n    // We don't bother to delete sets of things in a collection if the\r\n    // collection is empty.  It could break _removeAllDocuments.\r\n    delete self._documents[collectionName][id];\r\n    self._session.removed(self._subscriptionHandle, collectionName, id);\r\n  },\r\n\r\n  ready: function () {\r\n    var self = this;\r\n    if (self._isDeactivated())\r\n      return;\r\n    if (!self._subscriptionId)\r\n      return;  // unnecessary but ignored for universal sub\r\n    if (!self._ready) {\r\n      self._session.sendReady([self._subscriptionId]);\r\n      self._ready = true;\r\n    }\r\n  }\r\n});\r\n\r\n/******************************************************************************/\r\n/* Server                                                                     */\r\n/******************************************************************************/\r\n\r\nServer = function (options) {\r\n  var self = this;\r\n\r\n  // The default heartbeat interval is 30 seconds on the server and 35\r\n  // seconds on the client.  Since the client doesn't need to send a\r\n  // ping as long as it is receiving pings, this means that pings\r\n  // normally go from the server to the client.\r\n  self.options = _.defaults(options || {}, {\r\n    heartbeatInterval: 30000,\r\n    heartbeatTimeout: 15000,\r\n    // For testing, allow responding to pings to be disabled.\r\n    respondToPings: true\r\n  });\r\n\r\n  // Map of callbacks to call when a new connection comes in to the\r\n  // server and completes DDP version negotiation. Use an object instead\r\n  // of an array so we can safely remove one from the list while\r\n  // iterating over it.\r\n  self.onConnectionHook = new Hook({\r\n    debugPrintExceptions: \"onConnection callback\"\r\n  });\r\n\r\n  self.publish_handlers = {};\r\n  self.universal_publish_handlers = [];\r\n\r\n  self.method_handlers = {};\r\n\r\n  self.sessions = {}; // map from id to session\r\n\r\n  self.stream_server = new StreamServer;\r\n\r\n  self.stream_server.register(function (socket) {\r\n    // socket implements the SockJSConnection interface\r\n    socket._meteorSession = null;\r\n\r\n    var sendError = function (reason, offendingMessage) {\r\n      var msg = {msg: 'error', reason: reason};\r\n      if (offendingMessage)\r\n        msg.offendingMessage = offendingMessage;\r\n      socket.send(stringifyDDP(msg));\r\n    };\r\n\r\n    socket.on('data', function (raw_msg) {\r\n      if (Meteor._printReceivedDDP) {\r\n        Meteor._debug(\"Received DDP\", raw_msg);\r\n      }\r\n      try {\r\n        try {\r\n          var msg = parseDDP(raw_msg);\r\n        } catch (err) {\r\n          sendError('Parse error');\r\n          return;\r\n        }\r\n        if (msg === null || !msg.msg) {\r\n          sendError('Bad request', msg);\r\n          return;\r\n        }\r\n\r\n        if (msg.msg === 'connect') {\r\n          if (socket._meteorSession) {\r\n            sendError(\"Already connected\", msg);\r\n            return;\r\n          }\r\n          Fiber(function () {\r\n            self._handleConnect(socket, msg);\r\n          }).run();\r\n          return;\r\n        }\r\n\r\n        if (!socket._meteorSession) {\r\n          sendError('Must connect first', msg);\r\n          return;\r\n        }\r\n        socket._meteorSession.processMessage(msg);\r\n      } catch (e) {\r\n        // XXX print stack nicely\r\n        Meteor._debug(\"Internal exception while processing message\", msg,\r\n                      e.message, e.stack);\r\n      }\r\n    });\r\n\r\n    socket.on('close', function () {\r\n      if (socket._meteorSession) {\r\n        Fiber(function () {\r\n          socket._meteorSession.close();\r\n        }).run();\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\n_.extend(Server.prototype, {\r\n\r\n  onConnection: function (fn) {\r\n    var self = this;\r\n    return self.onConnectionHook.register(fn);\r\n  },\r\n\r\n  _handleConnect: function (socket, msg) {\r\n    var self = this;\r\n\r\n    // The connect message must specify a version and an array of supported\r\n    // versions, and it must claim to support what it is proposing.\r\n    if (!(typeof (msg.version) === 'string' &&\r\n          _.isArray(msg.support) &&\r\n          _.all(msg.support, _.isString) &&\r\n          _.contains(msg.support, msg.version))) {\r\n      socket.send(stringifyDDP({msg: 'failed',\r\n                                version: SUPPORTED_DDP_VERSIONS[0]}));\r\n      socket.close();\r\n      return;\r\n    }\r\n\r\n    // In the future, handle session resumption: something like:\r\n    //  socket._meteorSession = self.sessions[msg.session]\r\n    var version = calculateVersion(msg.support, SUPPORTED_DDP_VERSIONS);\r\n\r\n    if (msg.version !== version) {\r\n      // The best version to use (according to the client's stated preferences)\r\n      // is not the one the client is trying to use. Inform them about the best\r\n      // version to use.\r\n      socket.send(stringifyDDP({msg: 'failed', version: version}));\r\n      socket.close();\r\n      return;\r\n    }\r\n\r\n    // Yay, version matches! Create a new session.\r\n    socket._meteorSession = new Session(self, version, socket, self.options);\r\n    self.sessions[socket._meteorSession.id] = socket._meteorSession;\r\n    self.onConnectionHook.each(function (callback) {\r\n      if (socket._meteorSession)\r\n        callback(socket._meteorSession.connectionHandle);\r\n      return true;\r\n    });\r\n  },\r\n  /**\r\n   * Register a publish handler function.\r\n   *\r\n   * @param name {String} identifier for query\r\n   * @param handler {Function} publish handler\r\n   * @param options {Object}\r\n   *\r\n   * Server will call handler function on each new subscription,\r\n   * either when receiving DDP sub message for a named subscription, or on\r\n   * DDP connect for a universal subscription.\r\n   *\r\n   * If name is null, this will be a subscription that is\r\n   * automatically established and permanently on for all connected\r\n   * client, instead of a subscription that can be turned on and off\r\n   * with subscribe().\r\n   *\r\n   * options to contain:\r\n   *  - (mostly internal) is_auto: true if generated automatically\r\n   *    from an autopublish hook. this is for cosmetic purposes only\r\n   *    (it lets us determine whether to print a warning suggesting\r\n   *    that you turn off autopublish.)\r\n   */\r\n  publish: function (name, handler, options) {\r\n    var self = this;\r\n\r\n    options = options || {};\r\n\r\n    if (name && name in self.publish_handlers) {\r\n      Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\r\n      return;\r\n    }\r\n\r\n    if (Package.autopublish && !options.is_auto) {\r\n      // They have autopublish on, yet they're trying to manually\r\n      // picking stuff to publish. They probably should turn off\r\n      // autopublish. (This check isn't perfect -- if you create a\r\n      // publish before you turn on autopublish, it won't catch\r\n      // it. But this will definitely handle the simple case where\r\n      // you've added the autopublish package to your app, and are\r\n      // calling publish from your app code.)\r\n      if (!self.warned_about_autopublish) {\r\n        self.warned_about_autopublish = true;\r\n        Meteor._debug(\r\n\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +\r\n\"** you still have autopublish turned on. Because autopublish is still\\n\" +\r\n\"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +\r\n\"** will still be sent to all clients.\\n\" +\r\n\"**\\n\" +\r\n\"** Turn off autopublish by removing the autopublish package:\\n\" +\r\n\"**\\n\" +\r\n\"**   $ meteor remove autopublish\\n\" +\r\n\"**\\n\" +\r\n\"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +\r\n\"** for each collection that you want clients to see.\\n\");\r\n      }\r\n    }\r\n\r\n    if (name)\r\n      self.publish_handlers[name] = handler;\r\n    else {\r\n      self.universal_publish_handlers.push(handler);\r\n      // Spin up the new publisher on any existing session too. Run each\r\n      // session's subscription in a new Fiber, so that there's no change for\r\n      // self.sessions to change while we're running this loop.\r\n      _.each(self.sessions, function (session) {\r\n        if (!session._dontStartNewUniversalSubs) {\r\n          Fiber(function() {\r\n            session._startSubscription(handler);\r\n          }).run();\r\n        }\r\n      });\r\n    }\r\n  },\r\n\r\n  _removeSession: function (session) {\r\n    var self = this;\r\n    if (self.sessions[session.id]) {\r\n      delete self.sessions[session.id];\r\n    }\r\n  },\r\n\r\n  methods: function (methods) {\r\n    var self = this;\r\n    _.each(methods, function (func, name) {\r\n      if (self.method_handlers[name])\r\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\r\n      self.method_handlers[name] = func;\r\n    });\r\n  },\r\n\r\n  call: function (name /*, arguments */) {\r\n    // if it's a function, the last argument is the result callback,\r\n    // not a parameter to the remote method.\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    if (args.length && typeof args[args.length - 1] === \"function\")\r\n      var callback = args.pop();\r\n    return this.apply(name, args, callback);\r\n  },\r\n\r\n  // @param options {Optional Object}\r\n  // @param callback {Optional Function}\r\n  apply: function (name, args, options, callback) {\r\n    var self = this;\r\n\r\n    // We were passed 3 arguments. They may be either (name, args, options)\r\n    // or (name, args, callback)\r\n    if (!callback && typeof options === 'function') {\r\n      callback = options;\r\n      options = {};\r\n    }\r\n    options = options || {};\r\n\r\n    if (callback)\r\n      // It's not really necessary to do this, since we immediately\r\n      // run the callback in this fiber before returning, but we do it\r\n      // anyway for regularity.\r\n      // XXX improve error message (and how we report it)\r\n      callback = Meteor.bindEnvironment(\r\n        callback,\r\n        \"delivering result of invoking '\" + name + \"'\"\r\n      );\r\n\r\n    // Run the handler\r\n    var handler = self.method_handlers[name];\r\n    var exception;\r\n    if (!handler) {\r\n      exception = new Meteor.Error(404, \"Method not found\");\r\n    } else {\r\n      // If this is a method call from within another method, get the\r\n      // user state from the outer method, otherwise don't allow\r\n      // setUserId to be called\r\n      var userId = null;\r\n      var setUserId = function() {\r\n        throw new Error(\"Can't call setUserId on a server initiated method call\");\r\n      };\r\n      var connection = null;\r\n      var currentInvocation = DDP._CurrentInvocation.get();\r\n      if (currentInvocation) {\r\n        userId = currentInvocation.userId;\r\n        setUserId = function(userId) {\r\n          currentInvocation.setUserId(userId);\r\n        };\r\n        connection = currentInvocation.connection;\r\n      }\r\n\r\n      var invocation = new MethodInvocation({\r\n        isSimulation: false,\r\n        userId: userId,\r\n        setUserId: setUserId,\r\n        connection: connection,\r\n        randomSeed: makeRpcSeed(currentInvocation, name)\r\n      });\r\n      try {\r\n        var result = DDP._CurrentInvocation.withValue(invocation, function () {\r\n          return maybeAuditArgumentChecks(\r\n            handler, invocation, EJSON.clone(args), \"internal call to '\" +\r\n              name + \"'\");\r\n        });\r\n      } catch (e) {\r\n        exception = e;\r\n      }\r\n    }\r\n\r\n    // Return the result in whichever way the caller asked for it. Note that we\r\n    // do NOT block on the write fence in an analogous way to how the client\r\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\r\n    // cursor observe callbacks have fired when your callback is invoked. (We\r\n    // can change this if there's a real use case.)\r\n    if (callback) {\r\n      callback(exception, result);\r\n      return undefined;\r\n    }\r\n    if (exception)\r\n      throw exception;\r\n    return result;\r\n  },\r\n\r\n  _urlForSession: function (sessionId) {\r\n    var self = this;\r\n    var session = self.sessions[sessionId];\r\n    if (session)\r\n      return session._socketUrl;\r\n    else\r\n      return null;\r\n  }\r\n});\r\n\r\nvar calculateVersion = function (clientSupportedVersions,\r\n                                 serverSupportedVersions) {\r\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\r\n    return _.contains(serverSupportedVersions, version);\r\n  });\r\n  if (!correctVersion) {\r\n    correctVersion = serverSupportedVersions[0];\r\n  }\r\n  return correctVersion;\r\n};\r\n\r\nLivedataTest.calculateVersion = calculateVersion;\r\n\r\n\r\n// \"blind\" exceptions other than those that were deliberately thrown to signal\r\n// errors to the client\r\nvar wrapInternalException = function (exception, context) {\r\n  if (!exception || exception instanceof Meteor.Error)\r\n    return exception;\r\n\r\n  // Did the error contain more details that could have been useful if caught in\r\n  // server code (or if thrown from non-client-originated code), but also\r\n  // provided a \"sanitized\" version with more context than 500 Internal server\r\n  // error? Use that.\r\n  if (exception.sanitizedError) {\r\n    if (exception.sanitizedError instanceof Meteor.Error)\r\n      return exception.sanitizedError;\r\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +\r\n                  \"is not a Meteor.Error; ignoring\");\r\n  }\r\n\r\n  // tests can set the 'expected' flag on an exception so it won't go to the\r\n  // server log\r\n  if (!exception.expected)\r\n    Meteor._debug(\"Exception \" + context, exception.stack);\r\n\r\n  return new Meteor.Error(500, \"Internal server error\");\r\n};\r\n\r\n\r\n// Audit argument checks, if the audit-argument-checks package exists (it is a\r\n// weak dependency of this package).\r\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\r\n  args = args || [];\r\n  if (Package['audit-argument-checks']) {\r\n    return Match._failIfArgumentsAreNotAllChecked(\r\n      f, context, args, description);\r\n  }\r\n  return f.apply(context, args);\r\n};\r\n","var path = Npm.require('path');\r\nvar Future = Npm.require(path.join('fibers', 'future'));\r\n\r\n// A write fence collects a group of writes, and provides a callback\r\n// when all of the writes are fully committed and propagated (all\r\n// observers have been notified of the write and acknowledged it.)\r\n//\r\nDDPServer._WriteFence = function () {\r\n  var self = this;\r\n\r\n  self.armed = false;\r\n  self.fired = false;\r\n  self.retired = false;\r\n  self.outstanding_writes = 0;\r\n  self.completion_callbacks = [];\r\n};\r\n\r\n// The current write fence. When there is a current write fence, code\r\n// that writes to databases should register their writes with it using\r\n// beginWrite().\r\n//\r\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\r\n\r\n_.extend(DDPServer._WriteFence.prototype, {\r\n  // Start tracking a write, and return an object to represent it. The\r\n  // object has a single method, committed(). This method should be\r\n  // called when the write is fully committed and propagated. You can\r\n  // continue to add writes to the WriteFence up until it is triggered\r\n  // (calls its callbacks because all writes have committed.)\r\n  beginWrite: function () {\r\n    var self = this;\r\n\r\n    if (self.retired)\r\n      return { committed: function () {} };\r\n\r\n    if (self.fired)\r\n      throw new Error(\"fence has already activated -- too late to add writes\");\r\n\r\n    self.outstanding_writes++;\r\n    var committed = false;\r\n    return {\r\n      committed: function () {\r\n        if (committed)\r\n          throw new Error(\"committed called twice on the same write\");\r\n        committed = true;\r\n        self.outstanding_writes--;\r\n        self._maybeFire();\r\n      }\r\n    };\r\n  },\r\n\r\n  // Arm the fence. Once the fence is armed, and there are no more\r\n  // uncommitted writes, it will activate.\r\n  arm: function () {\r\n    var self = this;\r\n    if (self === DDPServer._CurrentWriteFence.get())\r\n      throw Error(\"Can't arm the current fence\");\r\n    self.armed = true;\r\n    self._maybeFire();\r\n  },\r\n\r\n  // Register a function to be called when the fence fires.\r\n  onAllCommitted: function (func) {\r\n    var self = this;\r\n    if (self.fired)\r\n      throw new Error(\"fence has already activated -- too late to \" +\r\n                      \"add a callback\");\r\n    self.completion_callbacks.push(func);\r\n  },\r\n\r\n  // Convenience function. Arms the fence, then blocks until it fires.\r\n  armAndWait: function () {\r\n    var self = this;\r\n    var future = new Future;\r\n    self.onAllCommitted(function () {\r\n      future['return']();\r\n    });\r\n    self.arm();\r\n    future.wait();\r\n  },\r\n\r\n  _maybeFire: function () {\r\n    var self = this;\r\n    if (self.fired)\r\n      throw new Error(\"write fence already activated?\");\r\n    if (self.armed && !self.outstanding_writes) {\r\n      self.fired = true;\r\n      _.each(self.completion_callbacks, function (f) {f(self);});\r\n      self.completion_callbacks = [];\r\n    }\r\n  },\r\n\r\n  // Deactivate this fence so that adding more writes has no effect.\r\n  // The fence must have already fired.\r\n  retire: function () {\r\n    var self = this;\r\n    if (! self.fired)\r\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\r\n    self.retired = true;\r\n  }\r\n});\r\n","// A \"crossbar\" is a class that provides structured notification registration.\r\n\r\nDDPServer._Crossbar = function (options) {\r\n  var self = this;\r\n  options = options || {};\r\n\r\n  self.nextId = 1;\r\n  // map from listener id to object. each object has keys 'trigger',\r\n  // 'callback'.\r\n  self.listeners = {};\r\n  self.factPackage = options.factPackage || \"livedata\";\r\n  self.factName = options.factName || null;\r\n};\r\n\r\n_.extend(DDPServer._Crossbar.prototype, {\r\n  // Listen for notification that match 'trigger'. A notification\r\n  // matches if it has the key-value pairs in trigger as a\r\n  // subset. When a notification matches, call 'callback', passing\r\n  // the actual notification.\r\n  //\r\n  // Returns a listen handle, which is an object with a method\r\n  // stop(). Call stop() to stop listening.\r\n  //\r\n  // XXX It should be legal to call fire() from inside a listen()\r\n  // callback?\r\n  listen: function (trigger, callback) {\r\n    var self = this;\r\n    var id = self.nextId++;\r\n    self.listeners[id] = {trigger: EJSON.clone(trigger), callback: callback};\r\n    if (self.factName && Package.facts) {\r\n      Package.facts.Facts.incrementServerFact(\r\n        self.factPackage, self.factName, 1);\r\n    }\r\n    return {\r\n      stop: function () {\r\n        if (self.factName && Package.facts) {\r\n          Package.facts.Facts.incrementServerFact(\r\n            self.factPackage, self.factName, -1);\r\n        }\r\n        delete self.listeners[id];\r\n      }\r\n    };\r\n  },\r\n\r\n  // Fire the provided 'notification' (an object whose attribute\r\n  // values are all JSON-compatibile) -- inform all matching listeners\r\n  // (registered with listen()).\r\n  //\r\n  // If fire() is called inside a write fence, then each of the\r\n  // listener callbacks will be called inside the write fence as well.\r\n  //\r\n  // The listeners may be invoked in parallel, rather than serially.\r\n  fire: function (notification) {\r\n    var self = this;\r\n    // Listener callbacks can yield, so we need to first find all the ones that\r\n    // match in a single iteration over self.listeners (which can't be mutated\r\n    // during this iteration), and then invoke the matching callbacks, checking\r\n    // before each call to ensure they are still in self.listeners.\r\n    var matchingCallbacks = {};\r\n    // XXX consider refactoring to \"index\" on \"collection\"\r\n    _.each(self.listeners, function (l, id) {\r\n      if (self._matches(notification, l.trigger))\r\n        matchingCallbacks[id] = l.callback;\r\n    });\r\n\r\n    _.each(matchingCallbacks, function (c, id) {\r\n      if (_.has(self.listeners, id))\r\n        c(notification);\r\n    });\r\n  },\r\n\r\n  // A notification matches a trigger if all keys that exist in both are equal.\r\n  //\r\n  // Examples:\r\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\r\n  //    (a non-targeted write to a collection matches a\r\n  //     non-targeted query)\r\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\r\n  //    (a targeted write to a collection matches a non-targeted query)\r\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\r\n  //    (a non-targeted write to a collection matches a\r\n  //     targeted query)\r\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\r\n  //    (a targeted write to a collection matches a targeted query targeted\r\n  //     at the same document)\r\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\r\n  //    (a targeted write to a collection does not match a targeted query\r\n  //     targeted at a different document)\r\n  _matches: function (notification, trigger) {\r\n    return _.all(trigger, function (triggerValue, key) {\r\n      return !_.has(notification, key) ||\r\n        EJSON.equals(triggerValue, notification[key]);\r\n    });\r\n  }\r\n});\r\n\r\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\r\n// implement write fence notifications. Listener callbacks on this crossbar\r\n// should call beginWrite on the current write fence before they return, if they\r\n// want to delay the write fence from firing (ie, the DDP method-data-updated\r\n// message from being sent).\r\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\r\n  factName: \"invalidation-crossbar-listeners\"\r\n});\r\n","DDP = {};\r\n\r\nSUPPORTED_DDP_VERSIONS = [ 'pre2', 'pre1' ];\r\n\r\nLivedataTest.SUPPORTED_DDP_VERSIONS = SUPPORTED_DDP_VERSIONS;\r\n\r\nMethodInvocation = function (options) {\r\n  var self = this;\r\n\r\n  // true if we're running not the actual method, but a stub (that is,\r\n  // if we're on a client (which may be a browser, or in the future a\r\n  // server connecting to another server) and presently running a\r\n  // simulation of a server-side method for latency compensation\r\n  // purposes). not currently true except in a client such as a browser,\r\n  // since there's usually no point in running stubs unless you have a\r\n  // zero-latency connection to the user.\r\n  this.isSimulation = options.isSimulation;\r\n\r\n  // call this function to allow other method invocations (from the\r\n  // same client) to continue running without waiting for this one to\r\n  // complete.\r\n  this._unblock = options.unblock || function () {};\r\n  this._calledUnblock = false;\r\n\r\n  // current user id\r\n  this.userId = options.userId;\r\n\r\n  // sets current user id in all appropriate server contexts and\r\n  // reruns subscriptions\r\n  this._setUserId = options.setUserId || function () {};\r\n\r\n  // On the server, the connection this method call came in on.\r\n  this.connection = options.connection;\r\n\r\n  // The seed for randomStream value generation\r\n  this.randomSeed = options.randomSeed;\r\n\r\n  // This is set by RandomStream.get; and holds the random stream state\r\n  this.randomStream = null;\r\n};\r\n\r\n_.extend(MethodInvocation.prototype, {\r\n  unblock: function () {\r\n    var self = this;\r\n    self._calledUnblock = true;\r\n    self._unblock();\r\n  },\r\n  setUserId: function(userId) {\r\n    var self = this;\r\n    if (self._calledUnblock)\r\n      throw new Error(\"Can't call setUserId in a method after calling unblock\");\r\n    self.userId = userId;\r\n    self._setUserId(userId);\r\n  }\r\n});\r\n\r\nparseDDP = function (stringMessage) {\r\n  try {\r\n    var msg = JSON.parse(stringMessage);\r\n  } catch (e) {\r\n    Meteor._debug(\"Discarding message with invalid JSON\", stringMessage);\r\n    return null;\r\n  }\r\n  // DDP messages must be objects.\r\n  if (msg === null || typeof msg !== 'object') {\r\n    Meteor._debug(\"Discarding non-object DDP message\", stringMessage);\r\n    return null;\r\n  }\r\n\r\n  // massage msg to get it into \"abstract ddp\" rather than \"wire ddp\" format.\r\n\r\n  // switch between \"cleared\" rep of unsetting fields and \"undefined\"\r\n  // rep of same\r\n  if (_.has(msg, 'cleared')) {\r\n    if (!_.has(msg, 'fields'))\r\n      msg.fields = {};\r\n    _.each(msg.cleared, function (clearKey) {\r\n      msg.fields[clearKey] = undefined;\r\n    });\r\n    delete msg.cleared;\r\n  }\r\n\r\n  _.each(['fields', 'params', 'result'], function (field) {\r\n    if (_.has(msg, field))\r\n      msg[field] = EJSON._adjustTypesFromJSONValue(msg[field]);\r\n  });\r\n\r\n  return msg;\r\n};\r\n\r\nstringifyDDP = function (msg) {\r\n  var copy = EJSON.clone(msg);\r\n  // swizzle 'changed' messages from 'fields undefined' rep to 'fields\r\n  // and cleared' rep\r\n  if (_.has(msg, 'fields')) {\r\n    var cleared = [];\r\n    _.each(msg.fields, function (value, key) {\r\n      if (value === undefined) {\r\n        cleared.push(key);\r\n        delete copy.fields[key];\r\n      }\r\n    });\r\n    if (!_.isEmpty(cleared))\r\n      copy.cleared = cleared;\r\n    if (_.isEmpty(copy.fields))\r\n      delete copy.fields;\r\n  }\r\n  // adjust types to basic\r\n  _.each(['fields', 'params', 'result'], function (field) {\r\n    if (_.has(copy, field))\r\n      copy[field] = EJSON._adjustTypesToJSONValue(copy[field]);\r\n  });\r\n  if (msg.id && typeof msg.id !== 'string') {\r\n    throw new Error(\"Message id is not a string\");\r\n  }\r\n  return JSON.stringify(copy);\r\n};\r\n\r\n// This is private but it's used in a few places. accounts-base uses\r\n// it to get the current user. accounts-password uses it to stash SRP\r\n// state in the DDP session. Meteor.setTimeout and friends clear\r\n// it. We can probably find a better way to factor this.\r\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;\r\n","// RandomStream allows for generation of pseudo-random values, from a seed.\r\n//\r\n// We use this for consistent 'random' numbers across the client and server.\r\n// We want to generate probably-unique IDs on the client, and we ideally want\r\n// the server to generate the same IDs when it executes the method.\r\n//\r\n// For generated values to be the same, we must seed ourselves the same way,\r\n// and we must keep track of the current state of our pseudo-random generators.\r\n// We call this state the scope. By default, we use the current DDP method\r\n// invocation as our scope.  DDP now allows the client to specify a randomSeed.\r\n// If a randomSeed is provided it will be used to seed our random sequences.\r\n// In this way, client and server method calls will generate the same values.\r\n//\r\n// We expose multiple named streams; each stream is independent\r\n// and is seeded differently (but predictably from the name).\r\n// By using multiple streams, we support reordering of requests,\r\n// as long as they occur on different streams.\r\n//\r\n// @param options {Optional Object}\r\n//   seed: Array or value - Seed value(s) for the generator.\r\n//                          If an array, will be used as-is\r\n//                          If a value, will be converted to a single-value array\r\n//                          If omitted, a random array will be used as the seed.\r\nRandomStream = function (options) {\r\n  var self = this;\r\n\r\n  this.seed = [].concat(options.seed || randomToken());\r\n\r\n  this.sequences = {};\r\n};\r\n\r\n// Returns a random string of sufficient length for a random seed.\r\n// This is a placeholder function; a similar function is planned\r\n// for Random itself; when that is added we should remove this function,\r\n// and call Random's randomToken instead.\r\nfunction randomToken() {\r\n  return Random.hexString(20);\r\n};\r\n\r\n// Returns the random stream with the specified name, in the specified scope.\r\n// If scope is null (or otherwise falsey) then we will use Random, which will\r\n// give us as random numbers as possible, but won't produce the same\r\n// values across client and server.\r\n// However, scope will normally be the current DDP method invocation, so\r\n// we'll use the stream with the specified name, and we should get consistent\r\n// values on the client and server sides of a method call.\r\nRandomStream.get = function (scope, name) {\r\n  if (!name) {\r\n    name = \"default\";\r\n  }\r\n  if (!scope) {\r\n    // There was no scope passed in;\r\n    // the sequence won't actually be reproducible.\r\n    return Random;\r\n  }\r\n  var randomStream = scope.randomStream;\r\n  if (!randomStream) {\r\n    scope.randomStream = randomStream = new RandomStream({\r\n      seed: scope.randomSeed\r\n    });\r\n  }\r\n  return randomStream._sequence(name);\r\n};\r\n\r\n// Returns the named sequence of pseudo-random values.\r\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce\r\n// consistent values for method calls on the client and server.\r\nDDP.randomStream = function (name) {\r\n  var scope = DDP._CurrentInvocation.get();\r\n  return RandomStream.get(scope, name);\r\n};\r\n\r\n// Creates a randomSeed for passing to a method call.\r\n// Note that we take enclosing as an argument,\r\n// though we expect it to be DDP._CurrentInvocation.get()\r\n// However, we often evaluate makeRpcSeed lazily, and thus the relevant\r\n// invocation may not be the one currently in scope.\r\n// If enclosing is null, we'll use Random and values won't be repeatable.\r\nmakeRpcSeed = function (enclosing, methodName) {\r\n  var stream = RandomStream.get(enclosing, '/rpc/' + methodName);\r\n  return stream.hexString(20);\r\n};\r\n\r\n_.extend(RandomStream.prototype, {\r\n  // Get a random sequence with the specified name, creating it if does not exist.\r\n  // New sequences are seeded with the seed concatenated with the name.\r\n  // By passing a seed into Random.create, we use the Alea generator.\r\n  _sequence: function (name) {\r\n    var self = this;\r\n\r\n    var sequence = self.sequences[name] || null;\r\n    if (sequence === null) {\r\n      var sequenceSeed = self.seed.concat(name);\r\n      for (var i = 0; i < sequenceSeed.length; i++) {\r\n        if (_.isFunction(sequenceSeed[i])) {\r\n          sequenceSeed[i] = sequenceSeed[i]();\r\n        }\r\n      }\r\n      self.sequences[name] = sequence = Random.createWithSeeds.apply(null, sequenceSeed);\r\n    }\r\n    return sequence;\r\n  }\r\n});\r\n","if (Meteor.isServer) {\r\n  var path = Npm.require('path');\r\n  var Fiber = Npm.require('fibers');\r\n  var Future = Npm.require(path.join('fibers', 'future'));\r\n}\r\n\r\n// @param url {String|Object} URL to Meteor app,\r\n//   or an object as a test hook (see code)\r\n// Options:\r\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\r\n//   headers: extra headers to send on the websockets connection, for\r\n//     server-to-server DDP only\r\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\r\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\r\n//\r\n// XXX There should be a way to destroy a DDP connection, causing all\r\n// outstanding method calls to fail.\r\n//\r\n// XXX Our current way of handling failure and reconnection is great\r\n// for an app (where we want to tolerate being disconnected as an\r\n// expect state, and keep trying forever to reconnect) but cumbersome\r\n// for something like a command line tool that wants to make a\r\n// connection, call a method, and print an error if connection\r\n// fails. We should have better usability in the latter case (while\r\n// still transparently reconnecting if it's just a transient failure\r\n// or the server migrating us).\r\nvar Connection = function (url, options) {\r\n  var self = this;\r\n  options = _.extend({\r\n    onConnected: function () {},\r\n    onDDPVersionNegotiationFailure: function (description) {\r\n      Meteor._debug(description);\r\n    },\r\n    heartbeatInterval: 35000,\r\n    heartbeatTimeout: 15000,\r\n    // These options are only for testing.\r\n    reloadWithOutstanding: false,\r\n    supportedDDPVersions: SUPPORTED_DDP_VERSIONS,\r\n    retry: true,\r\n    respondToPings: true\r\n  }, options);\r\n\r\n  // If set, called when we reconnect, queuing method calls _before_ the\r\n  // existing outstanding ones. This is the only data member that is part of the\r\n  // public API!\r\n  self.onReconnect = null;\r\n\r\n  // as a test hook, allow passing a stream instead of a url.\r\n  if (typeof url === \"object\") {\r\n    self._stream = url;\r\n  } else {\r\n    self._stream = new LivedataTest.ClientStream(url, {\r\n      retry: options.retry,\r\n      headers: options.headers,\r\n      _sockjsOptions: options._sockjsOptions,\r\n      // To keep some tests quiet (because we don't have a real API for handling\r\n      // client-stream-level errors).\r\n      _dontPrintErrors: options._dontPrintErrors\r\n    });\r\n  }\r\n\r\n  self._lastSessionId = null;\r\n  self._versionSuggestion = null;  // The last proposed DDP version.\r\n  self._version = null;   // The DDP version agreed on by client and server.\r\n  self._stores = {}; // name -> object with methods\r\n  self._methodHandlers = {}; // name -> func\r\n  self._nextMethodId = 1;\r\n  self._supportedDDPVersions = options.supportedDDPVersions;\r\n\r\n  self._heartbeatInterval = options.heartbeatInterval;\r\n  self._heartbeatTimeout = options.heartbeatTimeout;\r\n\r\n  // Tracks methods which the user has tried to call but which have not yet\r\n  // called their user callback (ie, they are waiting on their result or for all\r\n  // of their writes to be written to the local cache). Map from method ID to\r\n  // MethodInvoker object.\r\n  self._methodInvokers = {};\r\n\r\n  // Tracks methods which the user has called but whose result messages have not\r\n  // arrived yet.\r\n  //\r\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\r\n  // represents a set of methods that can run at the same time. The first block\r\n  // represents the methods which are currently in flight; subsequent blocks\r\n  // must wait for previous blocks to be fully finished before they can be sent\r\n  // to the server.\r\n  //\r\n  // Each block is an object with the following fields:\r\n  // - methods: a list of MethodInvoker objects\r\n  // - wait: a boolean; if true, this block had a single method invoked with\r\n  //         the \"wait\" option\r\n  //\r\n  // There will never be adjacent blocks with wait=false, because the only thing\r\n  // that makes methods need to be serialized is a wait method.\r\n  //\r\n  // Methods are removed from the first block when their \"result\" is\r\n  // received. The entire first block is only removed when all of the in-flight\r\n  // methods have received their results (so the \"methods\" list is empty) *AND*\r\n  // all of the data written by those methods are visible in the local cache. So\r\n  // it is possible for the first block's methods list to be empty, if we are\r\n  // still waiting for some objects to quiesce.\r\n  //\r\n  // Example:\r\n  //  _outstandingMethodBlocks = [\r\n  //    {wait: false, methods: []},\r\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\r\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\r\n  //                            <MethodInvoker for 'bar'>]}]\r\n  // This means that there were some methods which were sent to the server and\r\n  // which have returned their results, but some of the data written by\r\n  // the methods may not be visible in the local cache. Once all that data is\r\n  // visible, we will send a 'login' method. Once the login method has returned\r\n  // and all the data is visible (including re-running subs if userId changes),\r\n  // we will send the 'foo' and 'bar' methods in parallel.\r\n  self._outstandingMethodBlocks = [];\r\n\r\n  // method ID -> array of objects with keys 'collection' and 'id', listing\r\n  // documents written by a given method's stub. keys are associated with\r\n  // methods whose stub wrote at least one document, and whose data-done message\r\n  // has not yet been received.\r\n  self._documentsWrittenByStub = {};\r\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:\r\n  // - \"document\": the version of the document according the\r\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\r\n  //   received from the server)\r\n  //   It is undefined if we think the document does not exist\r\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\r\n  //   whose \"data done\" messages have not yet been processed\r\n  self._serverDocuments = {};\r\n\r\n  // Array of callbacks to be called after the next update of the local\r\n  // cache. Used for:\r\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\r\n  //    the relevant data is flushed.\r\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect\r\n  //    quiescence. Specifically, methods whose result was received over the old\r\n  //    connection (so we don't re-send it) but whose data had not been made\r\n  //    visible.\r\n  self._afterUpdateCallbacks = [];\r\n\r\n  // In two contexts, we buffer all incoming data messages and then process them\r\n  // all at once in a single update:\r\n  //   - During reconnect, we buffer all data messages until all subs that had\r\n  //     been ready before reconnect are ready again, and all methods that are\r\n  //     active have returned their \"data done message\"; then\r\n  //   - During the execution of a \"wait\" method, we buffer all data messages\r\n  //     until the wait method gets its \"data done\" message. (If the wait method\r\n  //     occurs during reconnect, it doesn't get any special handling.)\r\n  // all data messages are processed in one update.\r\n  //\r\n  // The following fields are used for this \"quiescence\" process.\r\n\r\n  // This buffers the messages that aren't being processed yet.\r\n  self._messagesBufferedUntilQuiescence = [];\r\n  // Map from method ID -> true. Methods are removed from this when their\r\n  // \"data done\" message is received, and we will not quiesce until it is\r\n  // empty.\r\n  self._methodsBlockingQuiescence = {};\r\n  // map from sub ID -> true for subs that were ready (ie, called the sub\r\n  // ready callback) before reconnect but haven't become ready again yet\r\n  self._subsBeingRevived = {}; // map from sub._id -> true\r\n  // if true, the next data update should reset all stores. (set during\r\n  // reconnect.)\r\n  self._resetStores = false;\r\n\r\n  // name -> array of updates for (yet to be created) collections\r\n  self._updatesForUnknownStores = {};\r\n  // if we're blocking a migration, the retry func\r\n  self._retryMigrate = null;\r\n\r\n  // metadata for subscriptions.  Map from sub ID to object with keys:\r\n  //   - id\r\n  //   - name\r\n  //   - params\r\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\r\n  //   - ready (has the 'ready' message been received?)\r\n  //   - readyCallback (an optional callback to call when ready)\r\n  //   - errorCallback (an optional callback to call if the sub terminates with\r\n  //                    an error)\r\n  self._subscriptions = {};\r\n\r\n  // Reactive userId.\r\n  self._userId = null;\r\n  self._userIdDeps = new Deps.Dependency;\r\n\r\n  // Block auto-reload while we're waiting for method responses.\r\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\r\n    Package.reload.Reload._onMigrate(function (retry) {\r\n      if (!self._readyToMigrate()) {\r\n        if (self._retryMigrate)\r\n          throw new Error(\"Two migrations in progress?\");\r\n        self._retryMigrate = retry;\r\n        return false;\r\n      } else {\r\n        return [true];\r\n      }\r\n    });\r\n  }\r\n\r\n  var onMessage = function (raw_msg) {\r\n    try {\r\n      var msg = parseDDP(raw_msg);\r\n    } catch (e) {\r\n      Meteor._debug(\"Exception while parsing DDP\", e);\r\n      return;\r\n    }\r\n\r\n    if (msg === null || !msg.msg) {\r\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\r\n      // compat.  Remove this 'if' once the server stops sending welcome\r\n      // messages (stream_server.js).\r\n      if (! (msg && msg.server_id))\r\n        Meteor._debug(\"discarding invalid livedata message\", msg);\r\n      return;\r\n    }\r\n\r\n    if (msg.msg === 'connected') {\r\n      self._version = self._versionSuggestion;\r\n      self._livedata_connected(msg);\r\n      options.onConnected();\r\n    }\r\n    else if (msg.msg == 'failed') {\r\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\r\n        self._versionSuggestion = msg.version;\r\n        self._stream.reconnect({_force: true});\r\n      } else {\r\n        var description =\r\n              \"DDP version negotiation failed; server requested version \" + msg.version;\r\n        self._stream.disconnect({_permanent: true, _error: description});\r\n        options.onDDPVersionNegotiationFailure(description);\r\n      }\r\n    }\r\n    else if (msg.msg === 'ping') {\r\n      if (options.respondToPings)\r\n        self._send({msg: \"pong\", id: msg.id});\r\n      if (self._heartbeat)\r\n        self._heartbeat.pingReceived();\r\n    }\r\n    else if (msg.msg === 'pong') {\r\n      if (self._heartbeat) {\r\n        self._heartbeat.pongReceived();\r\n      }\r\n    }\r\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))\r\n      self._livedata_data(msg);\r\n    else if (msg.msg === 'nosub')\r\n      self._livedata_nosub(msg);\r\n    else if (msg.msg === 'result')\r\n      self._livedata_result(msg);\r\n    else if (msg.msg === 'error')\r\n      self._livedata_error(msg);\r\n    else\r\n      Meteor._debug(\"discarding unknown livedata message type\", msg);\r\n  };\r\n\r\n  var onReset = function () {\r\n    // Send a connect message at the beginning of the stream.\r\n    // NOTE: reset is called even on the first connection, so this is\r\n    // the only place we send this message.\r\n    var msg = {msg: 'connect'};\r\n    if (self._lastSessionId)\r\n      msg.session = self._lastSessionId;\r\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\r\n    self._versionSuggestion = msg.version;\r\n    msg.support = self._supportedDDPVersions;\r\n    self._send(msg);\r\n\r\n    // Now, to minimize setup latency, go ahead and blast out all of\r\n    // our pending methods ands subscriptions before we've even taken\r\n    // the necessary RTT to know if we successfully reconnected. (1)\r\n    // They're supposed to be idempotent; (2) even if we did\r\n    // reconnect, we're not sure what messages might have gotten lost\r\n    // (in either direction) since we were disconnected (TCP being\r\n    // sloppy about that.)\r\n\r\n    // If the current block of methods all got their results (but didn't all get\r\n    // their data visible), discard the empty block now.\r\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&\r\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\r\n      self._outstandingMethodBlocks.shift();\r\n    }\r\n\r\n    // Mark all messages as unsent, they have not yet been sent on this\r\n    // connection.\r\n    _.each(self._methodInvokers, function (m) {\r\n      m.sentMessage = false;\r\n    });\r\n\r\n    // If an `onReconnect` handler is set, call it first. Go through\r\n    // some hoops to ensure that methods that are called from within\r\n    // `onReconnect` get executed _before_ ones that were originally\r\n    // outstanding (since `onReconnect` is used to re-establish auth\r\n    // certificates)\r\n    if (self.onReconnect)\r\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();\r\n    else\r\n      self._sendOutstandingMethods();\r\n\r\n    // add new subscriptions at the end. this way they take effect after\r\n    // the handlers and we don't see flicker.\r\n    _.each(self._subscriptions, function (sub, id) {\r\n      self._send({\r\n        msg: 'sub',\r\n        id: id,\r\n        name: sub.name,\r\n        params: sub.params\r\n      });\r\n    });\r\n  };\r\n\r\n  var onDisconnect = function () {\r\n    if (self._heartbeat) {\r\n      self._heartbeat.stop();\r\n      self._heartbeat = null;\r\n    }\r\n  };\r\n\r\n  if (Meteor.isServer) {\r\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, Meteor._debug));\r\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, Meteor._debug));\r\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, Meteor._debug));\r\n  } else {\r\n    self._stream.on('message', onMessage);\r\n    self._stream.on('reset', onReset);\r\n    self._stream.on('disconnect', onDisconnect);\r\n  }\r\n};\r\n\r\n// A MethodInvoker manages sending a method to the server and calling the user's\r\n// callbacks. On construction, it registers itself in the connection's\r\n// _methodInvokers map; it removes itself once the method is fully finished and\r\n// the callback is invoked. This occurs when it has both received a result,\r\n// and the data written by it is fully visible.\r\nvar MethodInvoker = function (options) {\r\n  var self = this;\r\n\r\n  // Public (within this file) fields.\r\n  self.methodId = options.methodId;\r\n  self.sentMessage = false;\r\n\r\n  self._callback = options.callback;\r\n  self._connection = options.connection;\r\n  self._message = options.message;\r\n  self._onResultReceived = options.onResultReceived || function () {};\r\n  self._wait = options.wait;\r\n  self._methodResult = null;\r\n  self._dataVisible = false;\r\n\r\n  // Register with the connection.\r\n  self._connection._methodInvokers[self.methodId] = self;\r\n};\r\n_.extend(MethodInvoker.prototype, {\r\n  // Sends the method message to the server. May be called additional times if\r\n  // we lose the connection and reconnect before receiving a result.\r\n  sendMessage: function () {\r\n    var self = this;\r\n    // This function is called before sending a method (including resending on\r\n    // reconnect). We should only (re)send methods where we don't already have a\r\n    // result!\r\n    if (self.gotResult())\r\n      throw new Error(\"sendingMethod is called on method with result\");\r\n\r\n    // If we're re-sending it, it doesn't matter if data was written the first\r\n    // time.\r\n    self._dataVisible = false;\r\n\r\n    self.sentMessage = true;\r\n\r\n    // If this is a wait method, make all data messages be buffered until it is\r\n    // done.\r\n    if (self._wait)\r\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;\r\n\r\n    // Actually send the message.\r\n    self._connection._send(self._message);\r\n  },\r\n  // Invoke the callback, if we have both a result and know that all data has\r\n  // been written to the local cache.\r\n  _maybeInvokeCallback: function () {\r\n    var self = this;\r\n    if (self._methodResult && self._dataVisible) {\r\n      // Call the callback. (This won't throw: the callback was wrapped with\r\n      // bindEnvironment.)\r\n      self._callback(self._methodResult[0], self._methodResult[1]);\r\n\r\n      // Forget about this method.\r\n      delete self._connection._methodInvokers[self.methodId];\r\n\r\n      // Let the connection know that this method is finished, so it can try to\r\n      // move on to the next block of methods.\r\n      self._connection._outstandingMethodFinished();\r\n    }\r\n  },\r\n  // Call with the result of the method from the server. Only may be called\r\n  // once; once it is called, you should not call sendMessage again.\r\n  // If the user provided an onResultReceived callback, call it immediately.\r\n  // Then invoke the main callback if data is also visible.\r\n  receiveResult: function (err, result) {\r\n    var self = this;\r\n    if (self.gotResult())\r\n      throw new Error(\"Methods should only receive results once\");\r\n    self._methodResult = [err, result];\r\n    self._onResultReceived(err, result);\r\n    self._maybeInvokeCallback();\r\n  },\r\n  // Call this when all data written by the method is visible. This means that\r\n  // the method has returns its \"data is done\" message *AND* all server\r\n  // documents that are buffered at that time have been written to the local\r\n  // cache. Invokes the main callback if the result has been received.\r\n  dataVisible: function () {\r\n    var self = this;\r\n    self._dataVisible = true;\r\n    self._maybeInvokeCallback();\r\n  },\r\n  // True if receiveResult has been called.\r\n  gotResult: function () {\r\n    var self = this;\r\n    return !!self._methodResult;\r\n  }\r\n});\r\n\r\n_.extend(Connection.prototype, {\r\n  // 'name' is the name of the data on the wire that should go in the\r\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\r\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\r\n  registerStore: function (name, wrappedStore) {\r\n    var self = this;\r\n\r\n    if (name in self._stores)\r\n      return false;\r\n\r\n    // Wrap the input object in an object which makes any store method not\r\n    // implemented by 'store' into a no-op.\r\n    var store = {};\r\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',\r\n            'retrieveOriginals'], function (method) {\r\n              store[method] = function () {\r\n                return (wrappedStore[method]\r\n                        ? wrappedStore[method].apply(wrappedStore, arguments)\r\n                        : undefined);\r\n              };\r\n            });\r\n\r\n    self._stores[name] = store;\r\n\r\n    var queued = self._updatesForUnknownStores[name];\r\n    if (queued) {\r\n      store.beginUpdate(queued.length, false);\r\n      _.each(queued, function (msg) {\r\n        store.update(msg);\r\n      });\r\n      store.endUpdate();\r\n      delete self._updatesForUnknownStores[name];\r\n    }\r\n\r\n    return true;\r\n  },\r\n\r\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\r\n    var self = this;\r\n\r\n    var params = Array.prototype.slice.call(arguments, 1);\r\n    var callbacks = {};\r\n    if (params.length) {\r\n      var lastParam = params[params.length - 1];\r\n      if (typeof lastParam === \"function\") {\r\n        callbacks.onReady = params.pop();\r\n      } else if (lastParam && (typeof lastParam.onReady === \"function\" ||\r\n                               typeof lastParam.onError === \"function\")) {\r\n        callbacks = params.pop();\r\n      }\r\n    }\r\n\r\n    // Is there an existing sub with the same name and param, run in an\r\n    // invalidated Computation? This will happen if we are rerunning an\r\n    // existing computation.\r\n    //\r\n    // For example, consider a rerun of:\r\n    //\r\n    //     Deps.autorun(function () {\r\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\r\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\r\n    //     });\r\n    //\r\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\r\n    // subcribe to an existing inactive subscription in order to not\r\n    // unsub and resub the subscription unnecessarily.\r\n    //\r\n    // We only look for one such sub; if there are N apparently-identical subs\r\n    // being invalidated, we will require N matching subscribe calls to keep\r\n    // them all active.\r\n    var existing = _.find(self._subscriptions, function (sub) {\r\n      return sub.inactive && sub.name === name &&\r\n        EJSON.equals(sub.params, params);\r\n    });\r\n\r\n    var id;\r\n    if (existing) {\r\n      id = existing.id;\r\n      existing.inactive = false; // reactivate\r\n\r\n      if (callbacks.onReady) {\r\n        // If the sub is not already ready, replace any ready callback with the\r\n        // one provided now. (It's not really clear what users would expect for\r\n        // an onReady callback inside an autorun; the semantics we provide is\r\n        // that at the time the sub first becomes ready, we call the last\r\n        // onReady callback provided, if any.)\r\n        if (!existing.ready)\r\n          existing.readyCallback = callbacks.onReady;\r\n      }\r\n      if (callbacks.onError) {\r\n        // Replace existing callback if any, so that errors aren't\r\n        // double-reported.\r\n        existing.errorCallback = callbacks.onError;\r\n      }\r\n    } else {\r\n      // New sub! Generate an id, save it locally, and send message.\r\n      id = Random.id();\r\n      self._subscriptions[id] = {\r\n        id: id,\r\n        name: name,\r\n        params: EJSON.clone(params),\r\n        inactive: false,\r\n        ready: false,\r\n        readyDeps: new Deps.Dependency,\r\n        readyCallback: callbacks.onReady,\r\n        errorCallback: callbacks.onError,\r\n        connection: self,\r\n        remove: function() {\r\n          delete this.connection._subscriptions[this.id];\r\n          this.ready && this.readyDeps.changed();\r\n        },\r\n        stop: function() {\r\n          this.connection._send({msg: 'unsub', id: id});\r\n          this.remove();\r\n        }\r\n      };\r\n      self._send({msg: 'sub', id: id, name: name, params: params});\r\n    }\r\n\r\n    // return a handle to the application.\r\n    var handle = {\r\n      stop: function () {\r\n        if (!_.has(self._subscriptions, id))\r\n          return;\r\n\r\n        self._subscriptions[id].stop();\r\n      },\r\n      ready: function () {\r\n        // return false if we've unsubscribed.\r\n        if (!_.has(self._subscriptions, id))\r\n          return false;\r\n        var record = self._subscriptions[id];\r\n        record.readyDeps.depend();\r\n        return record.ready;\r\n      }\r\n    };\r\n\r\n    if (Deps.active) {\r\n      // We're in a reactive computation, so we'd like to unsubscribe when the\r\n      // computation is invalidated... but not if the rerun just re-subscribes\r\n      // to the same subscription!  When a rerun happens, we use onInvalidate\r\n      // as a change to mark the subscription \"inactive\" so that it can\r\n      // be reused from the rerun.  If it isn't reused, it's killed from\r\n      // an afterFlush.\r\n      Deps.onInvalidate(function (c) {\r\n        if (_.has(self._subscriptions, id))\r\n          self._subscriptions[id].inactive = true;\r\n\r\n        Deps.afterFlush(function () {\r\n          if (_.has(self._subscriptions, id) &&\r\n              self._subscriptions[id].inactive)\r\n            handle.stop();\r\n        });\r\n      });\r\n    }\r\n\r\n    return handle;\r\n  },\r\n\r\n  // options:\r\n  // - onLateError {Function(error)} called if an error was received after the ready event.\r\n  //     (errors received before ready cause an error to be thrown)\r\n  _subscribeAndWait: function (name, args, options) {\r\n    var self = this;\r\n    var f = new Future();\r\n    var ready = false;\r\n    var handle;\r\n    args = args || [];\r\n    args.push({\r\n      onReady: function () {\r\n        ready = true;\r\n        f['return']();\r\n      },\r\n      onError: function (e) {\r\n        if (!ready)\r\n          f['throw'](e);\r\n        else\r\n          options && options.onLateError && options.onLateError(e);\r\n      }\r\n    });\r\n\r\n    handle = self.subscribe.apply(self, [name].concat(args));\r\n    f.wait();\r\n    return handle;\r\n  },\r\n\r\n  methods: function (methods) {\r\n    var self = this;\r\n    _.each(methods, function (func, name) {\r\n      if (self._methodHandlers[name])\r\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\r\n      self._methodHandlers[name] = func;\r\n    });\r\n  },\r\n\r\n  call: function (name /* .. [arguments] .. callback */) {\r\n    // if it's a function, the last argument is the result callback,\r\n    // not a parameter to the remote method.\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    if (args.length && typeof args[args.length - 1] === \"function\")\r\n      var callback = args.pop();\r\n    return this.apply(name, args, callback);\r\n  },\r\n\r\n  // @param options {Optional Object}\r\n  //   wait: Boolean - Should we wait to call this until all current methods\r\n  //                   are fully finished, and block subsequent method calls\r\n  //                   until this method is fully finished?\r\n  //                   (does not affect methods called from within this method)\r\n  //   onResultReceived: Function - a callback to call as soon as the method\r\n  //                                result is received. the data written by\r\n  //                                the method may not yet be in the cache!\r\n  //   returnStubValue: Boolean - If true then in cases where we would have\r\n  //                              otherwise discarded the stub's return value\r\n  //                              and returned undefined, instead we go ahead\r\n  //                              and return it.  Specifically, this is any\r\n  //                              time other than when (a) we are already\r\n  //                              inside a stub or (b) we are in Node and no\r\n  //                              callback was provided.  Currently we require\r\n  //                              this flag to be explicitly passed to reduce\r\n  //                              the likelihood that stub return values will\r\n  //                              be confused with server return values; we\r\n  //                              may improve this in future.\r\n  // @param callback {Optional Function}\r\n  apply: function (name, args, options, callback) {\r\n    var self = this;\r\n\r\n    // We were passed 3 arguments. They may be either (name, args, options)\r\n    // or (name, args, callback)\r\n    if (!callback && typeof options === 'function') {\r\n      callback = options;\r\n      options = {};\r\n    }\r\n    options = options || {};\r\n\r\n    if (callback) {\r\n      // XXX would it be better form to do the binding in stream.on,\r\n      // or caller, instead of here?\r\n      // XXX improve error message (and how we report it)\r\n      callback = Meteor.bindEnvironment(\r\n        callback,\r\n        \"delivering result of invoking '\" + name + \"'\"\r\n      );\r\n    }\r\n\r\n    // Keep our args safe from mutation (eg if we don't send the message for a\r\n    // while because of a wait method).\r\n    args = EJSON.clone(args);\r\n\r\n    // Lazily allocate method ID once we know that it'll be needed.\r\n    var methodId = (function () {\r\n      var id;\r\n      return function () {\r\n        if (id === undefined)\r\n          id = '' + (self._nextMethodId++);\r\n        return id;\r\n      };\r\n    })();\r\n\r\n    var enclosing = DDP._CurrentInvocation.get();\r\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;\r\n\r\n    // Lazily generate a randomSeed, only if it is requested by the stub.\r\n    // The random streams only have utility if they're used on both the client\r\n    // and the server; if the client doesn't generate any 'random' values\r\n    // then we don't expect the server to generate any either.\r\n    // Less commonly, the server may perform different actions from the client,\r\n    // and may in fact generate values where the client did not, but we don't\r\n    // have any client-side values to match, so even here we may as well just\r\n    // use a random seed on the server.  In that case, we don't pass the\r\n    // randomSeed to save bandwidth, and we don't even generate it to save a\r\n    // bit of CPU and to avoid consuming entropy.\r\n    var randomSeed = null;\r\n    var randomSeedGenerator = function () {\r\n      if (randomSeed === null) {\r\n        randomSeed = makeRpcSeed(enclosing, name);\r\n      }\r\n      return randomSeed;\r\n    };\r\n\r\n    // Run the stub, if we have one. The stub is supposed to make some\r\n    // temporary writes to the database to give the user a smooth experience\r\n    // until the actual result of executing the method comes back from the\r\n    // server (whereupon the temporary writes to the database will be reversed\r\n    // during the beginUpdate/endUpdate process.)\r\n    //\r\n    // Normally, we ignore the return value of the stub (even if it is an\r\n    // exception), in favor of the real return value from the server. The\r\n    // exception is if the *caller* is a stub. In that case, we're not going\r\n    // to do a RPC, so we use the return value of the stub as our return\r\n    // value.\r\n\r\n    var stub = self._methodHandlers[name];\r\n    if (stub) {\r\n      var setUserId = function(userId) {\r\n        self.setUserId(userId);\r\n      };\r\n\r\n      var invocation = new MethodInvocation({\r\n        isSimulation: true,\r\n        userId: self.userId(),\r\n        setUserId: setUserId,\r\n        randomSeed: function () { return randomSeedGenerator(); }\r\n      });\r\n\r\n      if (!alreadyInSimulation)\r\n        self._saveOriginals();\r\n\r\n      try {\r\n        // Note that unlike in the corresponding server code, we never audit\r\n        // that stubs check() their arguments.\r\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {\r\n          if (Meteor.isServer) {\r\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\r\n            // don't allow stubs to yield.\r\n            return Meteor._noYieldsAllowed(function () {\r\n              // re-clone, so that the stub can't affect our caller's values\r\n              return stub.apply(invocation, EJSON.clone(args));\r\n            });\r\n          } else {\r\n            return stub.apply(invocation, EJSON.clone(args));\r\n          }\r\n        });\r\n      }\r\n      catch (e) {\r\n        var exception = e;\r\n      }\r\n\r\n      if (!alreadyInSimulation)\r\n        self._retrieveAndStoreOriginals(methodId());\r\n    }\r\n\r\n    // If we're in a simulation, stop and return the result we have,\r\n    // rather than going on to do an RPC. If there was no stub,\r\n    // we'll end up returning undefined.\r\n    if (alreadyInSimulation) {\r\n      if (callback) {\r\n        callback(exception, stubReturnValue);\r\n        return undefined;\r\n      }\r\n      if (exception)\r\n        throw exception;\r\n      return stubReturnValue;\r\n    }\r\n\r\n    // If an exception occurred in a stub, and we're ignoring it\r\n    // because we're doing an RPC and want to use what the server\r\n    // returns instead, log it so the developer knows.\r\n    //\r\n    // Tests can set the 'expected' flag on an exception so it won't\r\n    // go to log.\r\n    if (exception && !exception.expected) {\r\n      Meteor._debug(\"Exception while simulating the effect of invoking '\" +\r\n                    name + \"'\", exception, exception.stack);\r\n    }\r\n\r\n\r\n    // At this point we're definitely doing an RPC, and we're going to\r\n    // return the value of the RPC to the caller.\r\n\r\n    // If the caller didn't give a callback, decide what to do.\r\n    if (!callback) {\r\n      if (Meteor.isClient) {\r\n        // On the client, we don't have fibers, so we can't block. The\r\n        // only thing we can do is to return undefined and discard the\r\n        // result of the RPC. If an error occurred then print the error\r\n        // to the console.\r\n        callback = function (err) {\r\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",\r\n                               err.message);\r\n        };\r\n      } else {\r\n        // On the server, make the function synchronous. Throw on\r\n        // errors, return on success.\r\n        var future = new Future;\r\n        callback = future.resolver();\r\n      }\r\n    }\r\n    // Send the RPC. Note that on the client, it is important that the\r\n    // stub have finished before we send the RPC, so that we know we have\r\n    // a complete list of which local documents the stub wrote.\r\n    var message = {\r\n      msg: 'method',\r\n      method: name,\r\n      params: args,\r\n      id: methodId()\r\n    };\r\n\r\n    // Send the randomSeed only if we used it\r\n    if (randomSeed !== null) {\r\n      message.randomSeed = randomSeed;\r\n    }\r\n\r\n    var methodInvoker = new MethodInvoker({\r\n      methodId: methodId(),\r\n      callback: callback,\r\n      connection: self,\r\n      onResultReceived: options.onResultReceived,\r\n      wait: !!options.wait,\r\n      message: message\r\n    });\r\n\r\n    if (options.wait) {\r\n      // It's a wait method! Wait methods go in their own block.\r\n      self._outstandingMethodBlocks.push(\r\n        {wait: true, methods: [methodInvoker]});\r\n    } else {\r\n      // Not a wait method. Start a new block if the previous block was a wait\r\n      // block, and add it to the last block of methods.\r\n      if (_.isEmpty(self._outstandingMethodBlocks) ||\r\n          _.last(self._outstandingMethodBlocks).wait)\r\n        self._outstandingMethodBlocks.push({wait: false, methods: []});\r\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\r\n    }\r\n\r\n    // If we added it to the first block, send it out now.\r\n    if (self._outstandingMethodBlocks.length === 1)\r\n      methodInvoker.sendMessage();\r\n\r\n    // If we're using the default callback on the server,\r\n    // block waiting for the result.\r\n    if (future) {\r\n      return future.wait();\r\n    }\r\n    return options.returnStubValue ? stubReturnValue : undefined;\r\n  },\r\n\r\n  // Before calling a method stub, prepare all stores to track changes and allow\r\n  // _retrieveAndStoreOriginals to get the original versions of changed\r\n  // documents.\r\n  _saveOriginals: function () {\r\n    var self = this;\r\n    _.each(self._stores, function (s) {\r\n      s.saveOriginals();\r\n    });\r\n  },\r\n  // Retrieves the original versions of all documents modified by the stub for\r\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\r\n  // by document) and _documentsWrittenByStub (keyed by method ID).\r\n  _retrieveAndStoreOriginals: function (methodId) {\r\n    var self = this;\r\n    if (self._documentsWrittenByStub[methodId])\r\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");\r\n\r\n    var docsWritten = [];\r\n    _.each(self._stores, function (s, collection) {\r\n      var originals = s.retrieveOriginals();\r\n      // not all stores define retrieveOriginals\r\n      if (!originals)\r\n        return;\r\n      originals.forEach(function (doc, id) {\r\n        docsWritten.push({collection: collection, id: id});\r\n        if (!_.has(self._serverDocuments, collection))\r\n          self._serverDocuments[collection] = new LocalCollection._IdMap;\r\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\r\n        if (serverDoc.writtenByStubs) {\r\n          // We're not the first stub to write this doc. Just add our method ID\r\n          // to the record.\r\n          serverDoc.writtenByStubs[methodId] = true;\r\n        } else {\r\n          // First stub! Save the original value and our method ID.\r\n          serverDoc.document = doc;\r\n          serverDoc.flushCallbacks = [];\r\n          serverDoc.writtenByStubs = {};\r\n          serverDoc.writtenByStubs[methodId] = true;\r\n        }\r\n      });\r\n    });\r\n    if (!_.isEmpty(docsWritten)) {\r\n      self._documentsWrittenByStub[methodId] = docsWritten;\r\n    }\r\n  },\r\n\r\n  // This is very much a private function we use to make the tests\r\n  // take up fewer server resources after they complete.\r\n  _unsubscribeAll: function () {\r\n    var self = this;\r\n    _.each(_.clone(self._subscriptions), function (sub, id) {\r\n      // Avoid killing the autoupdate subscription so that developers\r\n      // still get hot code pushes when writing tests.\r\n      //\r\n      // XXX it's a hack to encode knowledge about autoupdate here,\r\n      // but it doesn't seem worth it yet to have a special API for\r\n      // subscriptions to preserve after unit tests.\r\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\r\n        self._subscriptions[id].stop();\r\n      }\r\n    });\r\n  },\r\n\r\n  // Sends the DDP stringification of the given message object\r\n  _send: function (obj) {\r\n    var self = this;\r\n    self._stream.send(stringifyDDP(obj));\r\n  },\r\n\r\n  // We detected via DDP-level heartbeats that we've lost the\r\n  // connection.  Unlike `disconnect` or `close`, a lost connection\r\n  // will be automatically retried.\r\n  _lostConnection: function () {\r\n    var self = this;\r\n    self._stream._lostConnection();\r\n  },\r\n\r\n  status: function (/*passthrough args*/) {\r\n    var self = this;\r\n    return self._stream.status.apply(self._stream, arguments);\r\n  },\r\n\r\n  reconnect: function (/*passthrough args*/) {\r\n    var self = this;\r\n    return self._stream.reconnect.apply(self._stream, arguments);\r\n  },\r\n\r\n  disconnect: function (/*passthrough args*/) {\r\n    var self = this;\r\n    return self._stream.disconnect.apply(self._stream, arguments);\r\n  },\r\n\r\n  close: function () {\r\n    var self = this;\r\n    return self._stream.disconnect({_permanent: true});\r\n  },\r\n\r\n  ///\r\n  /// Reactive user system\r\n  ///\r\n  userId: function () {\r\n    var self = this;\r\n    if (self._userIdDeps)\r\n      self._userIdDeps.depend();\r\n    return self._userId;\r\n  },\r\n\r\n  setUserId: function (userId) {\r\n    var self = this;\r\n    // Avoid invalidating dependents if setUserId is called with current value.\r\n    if (self._userId === userId)\r\n      return;\r\n    self._userId = userId;\r\n    if (self._userIdDeps)\r\n      self._userIdDeps.changed();\r\n  },\r\n\r\n  // Returns true if we are in a state after reconnect of waiting for subs to be\r\n  // revived or early methods to finish their data, or we are waiting for a\r\n  // \"wait\" method to finish.\r\n  _waitingForQuiescence: function () {\r\n    var self = this;\r\n    return (! _.isEmpty(self._subsBeingRevived) ||\r\n            ! _.isEmpty(self._methodsBlockingQuiescence));\r\n  },\r\n\r\n  // Returns true if any method whose message has been sent to the server has\r\n  // not yet invoked its user callback.\r\n  _anyMethodsAreOutstanding: function () {\r\n    var self = this;\r\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\r\n  },\r\n\r\n  _livedata_connected: function (msg) {\r\n    var self = this;\r\n\r\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\r\n      self._heartbeat = new Heartbeat({\r\n        heartbeatInterval: self._heartbeatInterval,\r\n        heartbeatTimeout: self._heartbeatTimeout,\r\n        onTimeout: function () {\r\n          if (Meteor.isClient && ! self._stream._isStub) {\r\n            // only print on the client. this message is useful on the\r\n            // browser console to see that we've lost connection. on the\r\n            // server (eg when doing server-to-server DDP), it gets\r\n            // kinda annoying. also this matches the behavior with\r\n            // sockjs timeouts.\r\n            Meteor._debug(\"Connection timeout. No DDP heartbeat received.\");\r\n          }\r\n          self._lostConnection();\r\n        },\r\n        sendPing: function () {\r\n          self._send({msg: 'ping'});\r\n        }\r\n      });\r\n      self._heartbeat.start();\r\n    }\r\n\r\n    // If this is a reconnect, we'll have to reset all stores.\r\n    if (self._lastSessionId)\r\n      self._resetStores = true;\r\n\r\n    if (typeof (msg.session) === \"string\") {\r\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);\r\n      self._lastSessionId = msg.session;\r\n    }\r\n\r\n    if (reconnectedToPreviousSession) {\r\n      // Successful reconnection -- pick up where we left off.  Note that right\r\n      // now, this never happens: the server never connects us to a previous\r\n      // session, because DDP doesn't provide enough data for the server to know\r\n      // what messages the client has processed. We need to improve DDP to make\r\n      // this possible, at which point we'll probably need more code here.\r\n      return;\r\n    }\r\n\r\n    // Server doesn't have our data any more. Re-sync a new session.\r\n\r\n    // Forget about messages we were buffering for unknown collections. They'll\r\n    // be resent if still relevant.\r\n    self._updatesForUnknownStores = {};\r\n\r\n    if (self._resetStores) {\r\n      // Forget about the effects of stubs. We'll be resetting all collections\r\n      // anyway.\r\n      self._documentsWrittenByStub = {};\r\n      self._serverDocuments = {};\r\n    }\r\n\r\n    // Clear _afterUpdateCallbacks.\r\n    self._afterUpdateCallbacks = [];\r\n\r\n    // Mark all named subscriptions which are ready (ie, we already called the\r\n    // ready callback) as needing to be revived.\r\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\r\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\r\n    self._subsBeingRevived = {};\r\n    _.each(self._subscriptions, function (sub, id) {\r\n      if (sub.ready)\r\n        self._subsBeingRevived[id] = true;\r\n    });\r\n\r\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\r\n    // track methods that were sent on this connection so that we don't\r\n    // quiesce until they are all done.\r\n    //\r\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\r\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\r\n    // that we drop here will be restored by the loop below.\r\n    self._methodsBlockingQuiescence = {};\r\n    if (self._resetStores) {\r\n      _.each(self._methodInvokers, function (invoker) {\r\n        if (invoker.gotResult()) {\r\n          // This method already got its result, but it didn't call its callback\r\n          // because its data didn't become visible. We did not resend the\r\n          // method RPC. We'll call its callback when we get a full quiesce,\r\n          // since that's as close as we'll get to \"data must be visible\".\r\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\r\n        } else if (invoker.sentMessage) {\r\n          // This method has been sent on this connection (maybe as a resend\r\n          // from the last connection, maybe from onReconnect, maybe just very\r\n          // quickly before processing the connected message).\r\n          //\r\n          // We don't need to do anything special to ensure its callbacks get\r\n          // called, but we'll count it as a method which is preventing\r\n          // reconnect quiescence. (eg, it might be a login method that was run\r\n          // from onReconnect, and we don't want to see flicker by seeing a\r\n          // logged-out state.)\r\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\r\n        }\r\n      });\r\n    }\r\n\r\n    self._messagesBufferedUntilQuiescence = [];\r\n\r\n    // If we're not waiting on any methods or subs, we can reset the stores and\r\n    // call the callbacks immediately.\r\n    if (!self._waitingForQuiescence()) {\r\n      if (self._resetStores) {\r\n        _.each(self._stores, function (s) {\r\n          s.beginUpdate(0, true);\r\n          s.endUpdate();\r\n        });\r\n        self._resetStores = false;\r\n      }\r\n      self._runAfterUpdateCallbacks();\r\n    }\r\n  },\r\n\r\n\r\n  _processOneDataMessage: function (msg, updates) {\r\n    var self = this;\r\n    // Using underscore here so as not to need to capitalize.\r\n    self['_process_' + msg.msg](msg, updates);\r\n  },\r\n\r\n\r\n  _livedata_data: function (msg) {\r\n    var self = this;\r\n\r\n    // collection name -> array of messages\r\n    var updates = {};\r\n\r\n    if (self._waitingForQuiescence()) {\r\n      self._messagesBufferedUntilQuiescence.push(msg);\r\n\r\n      if (msg.msg === \"nosub\")\r\n        delete self._subsBeingRevived[msg.id];\r\n\r\n      _.each(msg.subs || [], function (subId) {\r\n        delete self._subsBeingRevived[subId];\r\n      });\r\n      _.each(msg.methods || [], function (methodId) {\r\n        delete self._methodsBlockingQuiescence[methodId];\r\n      });\r\n\r\n      if (self._waitingForQuiescence())\r\n        return;\r\n\r\n      // No methods or subs are blocking quiescence!\r\n      // We'll now process and all of our buffered messages, reset all stores,\r\n      // and apply them all at once.\r\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\r\n        self._processOneDataMessage(bufferedMsg, updates);\r\n      });\r\n      self._messagesBufferedUntilQuiescence = [];\r\n    } else {\r\n      self._processOneDataMessage(msg, updates);\r\n    }\r\n\r\n    if (self._resetStores || !_.isEmpty(updates)) {\r\n      // Begin a transactional update of each store.\r\n      _.each(self._stores, function (s, storeName) {\r\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,\r\n                      self._resetStores);\r\n      });\r\n      self._resetStores = false;\r\n\r\n      _.each(updates, function (updateMessages, storeName) {\r\n        var store = self._stores[storeName];\r\n        if (store) {\r\n          _.each(updateMessages, function (updateMessage) {\r\n            store.update(updateMessage);\r\n          });\r\n        } else {\r\n          // Nobody's listening for this data. Queue it up until\r\n          // someone wants it.\r\n          // XXX memory use will grow without bound if you forget to\r\n          // create a collection or just don't care about it... going\r\n          // to have to do something about that.\r\n          if (!_.has(self._updatesForUnknownStores, storeName))\r\n            self._updatesForUnknownStores[storeName] = [];\r\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],\r\n                                     updateMessages);\r\n        }\r\n      });\r\n\r\n      // End update transaction.\r\n      _.each(self._stores, function (s) { s.endUpdate(); });\r\n    }\r\n\r\n    self._runAfterUpdateCallbacks();\r\n  },\r\n\r\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\r\n  // relevant docs have been flushed, as well as dataVisible callbacks at\r\n  // reconnect-quiescence time.\r\n  _runAfterUpdateCallbacks: function () {\r\n    var self = this;\r\n    var callbacks = self._afterUpdateCallbacks;\r\n    self._afterUpdateCallbacks = [];\r\n    _.each(callbacks, function (c) {\r\n      c();\r\n    });\r\n  },\r\n\r\n  _pushUpdate: function (updates, collection, msg) {\r\n    var self = this;\r\n    if (!_.has(updates, collection)) {\r\n      updates[collection] = [];\r\n    }\r\n    updates[collection].push(msg);\r\n  },\r\n\r\n  _getServerDoc: function (collection, id) {\r\n    var self = this;\r\n    if (!_.has(self._serverDocuments, collection))\r\n      return null;\r\n    var serverDocsForCollection = self._serverDocuments[collection];\r\n    return serverDocsForCollection.get(id) || null;\r\n  },\r\n\r\n  _process_added: function (msg, updates) {\r\n    var self = this;\r\n    var id = LocalCollection._idParse(msg.id);\r\n    var serverDoc = self._getServerDoc(msg.collection, id);\r\n    if (serverDoc) {\r\n      // Some outstanding stub wrote here.\r\n      if (serverDoc.document !== undefined)\r\n        throw new Error(\"Server sent add for existing id: \" + msg.id);\r\n      serverDoc.document = msg.fields || {};\r\n      serverDoc.document._id = id;\r\n    } else {\r\n      self._pushUpdate(updates, msg.collection, msg);\r\n    }\r\n  },\r\n\r\n  _process_changed: function (msg, updates) {\r\n    var self = this;\r\n    var serverDoc = self._getServerDoc(\r\n      msg.collection, LocalCollection._idParse(msg.id));\r\n    if (serverDoc) {\r\n      if (serverDoc.document === undefined)\r\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);\r\n      LocalCollection._applyChanges(serverDoc.document, msg.fields);\r\n    } else {\r\n      self._pushUpdate(updates, msg.collection, msg);\r\n    }\r\n  },\r\n\r\n  _process_removed: function (msg, updates) {\r\n    var self = this;\r\n    var serverDoc = self._getServerDoc(\r\n      msg.collection, LocalCollection._idParse(msg.id));\r\n    if (serverDoc) {\r\n      // Some outstanding stub wrote here.\r\n      if (serverDoc.document === undefined)\r\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);\r\n      serverDoc.document = undefined;\r\n    } else {\r\n      self._pushUpdate(updates, msg.collection, {\r\n        msg: 'removed',\r\n        collection: msg.collection,\r\n        id: msg.id\r\n      });\r\n    }\r\n  },\r\n\r\n  _process_updated: function (msg, updates) {\r\n    var self = this;\r\n    // Process \"method done\" messages.\r\n    _.each(msg.methods, function (methodId) {\r\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\r\n        var serverDoc = self._getServerDoc(written.collection, written.id);\r\n        if (!serverDoc)\r\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));\r\n        if (!serverDoc.writtenByStubs[methodId])\r\n          throw new Error(\"Doc \" + JSON.stringify(written) +\r\n                          \" not written by  method \" + methodId);\r\n        delete serverDoc.writtenByStubs[methodId];\r\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\r\n          // All methods whose stubs wrote this method have completed! We can\r\n          // now copy the saved document to the database (reverting the stub's\r\n          // change if the server did not write to this object, or applying the\r\n          // server's writes if it did).\r\n\r\n          // This is a fake ddp 'replace' message.  It's just for talking\r\n          // between livedata connections and minimongo.  (We have to stringify\r\n          // the ID because it's supposed to look like a wire message.)\r\n          self._pushUpdate(updates, written.collection, {\r\n            msg: 'replace',\r\n            id: LocalCollection._idStringify(written.id),\r\n            replace: serverDoc.document\r\n          });\r\n          // Call all flush callbacks.\r\n          _.each(serverDoc.flushCallbacks, function (c) {\r\n            c();\r\n          });\r\n\r\n          // Delete this completed serverDocument. Don't bother to GC empty\r\n          // IdMaps inside self._serverDocuments, since there probably aren't\r\n          // many collections and they'll be written repeatedly.\r\n          self._serverDocuments[written.collection].remove(written.id);\r\n        }\r\n      });\r\n      delete self._documentsWrittenByStub[methodId];\r\n\r\n      // We want to call the data-written callback, but we can't do so until all\r\n      // currently buffered messages are flushed.\r\n      var callbackInvoker = self._methodInvokers[methodId];\r\n      if (!callbackInvoker)\r\n        throw new Error(\"No callback invoker for method \" + methodId);\r\n      self._runWhenAllServerDocsAreFlushed(\r\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));\r\n    });\r\n  },\r\n\r\n  _process_ready: function (msg, updates) {\r\n    var self = this;\r\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\r\n    // until all current server documents have been flushed to the local\r\n    // database. We can use a write fence to implement this.\r\n    _.each(msg.subs, function (subId) {\r\n      self._runWhenAllServerDocsAreFlushed(function () {\r\n        var subRecord = self._subscriptions[subId];\r\n        // Did we already unsubscribe?\r\n        if (!subRecord)\r\n          return;\r\n        // Did we already receive a ready message? (Oops!)\r\n        if (subRecord.ready)\r\n          return;\r\n        subRecord.readyCallback && subRecord.readyCallback();\r\n        subRecord.ready = true;\r\n        subRecord.readyDeps.changed();\r\n      });\r\n    });\r\n  },\r\n\r\n  // Ensures that \"f\" will be called after all documents currently in\r\n  // _serverDocuments have been written to the local cache. f will not be called\r\n  // if the connection is lost before then!\r\n  _runWhenAllServerDocsAreFlushed: function (f) {\r\n    var self = this;\r\n    var runFAfterUpdates = function () {\r\n      self._afterUpdateCallbacks.push(f);\r\n    };\r\n    var unflushedServerDocCount = 0;\r\n    var onServerDocFlush = function () {\r\n      --unflushedServerDocCount;\r\n      if (unflushedServerDocCount === 0) {\r\n        // This was the last doc to flush! Arrange to run f after the updates\r\n        // have been applied.\r\n        runFAfterUpdates();\r\n      }\r\n    };\r\n    _.each(self._serverDocuments, function (collectionDocs) {\r\n      collectionDocs.forEach(function (serverDoc) {\r\n        var writtenByStubForAMethodWithSentMessage = _.any(\r\n          serverDoc.writtenByStubs, function (dummy, methodId) {\r\n            var invoker = self._methodInvokers[methodId];\r\n            return invoker && invoker.sentMessage;\r\n          });\r\n        if (writtenByStubForAMethodWithSentMessage) {\r\n          ++unflushedServerDocCount;\r\n          serverDoc.flushCallbacks.push(onServerDocFlush);\r\n        }\r\n      });\r\n    });\r\n    if (unflushedServerDocCount === 0) {\r\n      // There aren't any buffered docs --- we can call f as soon as the current\r\n      // round of updates is applied!\r\n      runFAfterUpdates();\r\n    }\r\n  },\r\n\r\n  _livedata_nosub: function (msg) {\r\n    var self = this;\r\n\r\n    // First pass it through _livedata_data, which only uses it to help get\r\n    // towards quiescence.\r\n    self._livedata_data(msg);\r\n\r\n    // Do the rest of our processing immediately, with no\r\n    // buffering-until-quiescence.\r\n\r\n    // we weren't subbed anyway, or we initiated the unsub.\r\n    if (!_.has(self._subscriptions, msg.id))\r\n      return;\r\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\r\n    self._subscriptions[msg.id].remove();\r\n    if (errorCallback && msg.error) {\r\n      errorCallback(new Meteor.Error(\r\n        msg.error.error, msg.error.reason, msg.error.details));\r\n    }\r\n  },\r\n\r\n  _process_nosub: function () {\r\n    // This is called as part of the \"buffer until quiescence\" process, but\r\n    // nosub's effect is always immediate. It only goes in the buffer at all\r\n    // because it's possible for a nosub to be the thing that triggers\r\n    // quiescence, if we were waiting for a sub to be revived and it dies\r\n    // instead.\r\n  },\r\n\r\n  _livedata_result: function (msg) {\r\n    // id, result or error. error has error (code), reason, details\r\n\r\n    var self = this;\r\n\r\n    // find the outstanding request\r\n    // should be O(1) in nearly all realistic use cases\r\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\r\n      Meteor._debug(\"Received method result but no methods outstanding\");\r\n      return;\r\n    }\r\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\r\n    var m;\r\n    for (var i = 0; i < currentMethodBlock.length; i++) {\r\n      m = currentMethodBlock[i];\r\n      if (m.methodId === msg.id)\r\n        break;\r\n    }\r\n\r\n    if (!m) {\r\n      Meteor._debug(\"Can't match method response to original method call\", msg);\r\n      return;\r\n    }\r\n\r\n    // Remove from current method block. This may leave the block empty, but we\r\n    // don't move on to the next block until the callback has been delivered, in\r\n    // _outstandingMethodFinished.\r\n    currentMethodBlock.splice(i, 1);\r\n\r\n    if (_.has(msg, 'error')) {\r\n      m.receiveResult(new Meteor.Error(\r\n        msg.error.error, msg.error.reason,\r\n        msg.error.details));\r\n    } else {\r\n      // msg.result may be undefined if the method didn't return a\r\n      // value\r\n      m.receiveResult(undefined, msg.result);\r\n    }\r\n  },\r\n\r\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\r\n  // the last outstanding method in the current block, runs the next block. If\r\n  // there are no more methods, consider accepting a hot code push.\r\n  _outstandingMethodFinished: function () {\r\n    var self = this;\r\n    if (self._anyMethodsAreOutstanding())\r\n      return;\r\n\r\n    // No methods are outstanding. This should mean that the first block of\r\n    // methods is empty. (Or it might not exist, if this was a method that\r\n    // half-finished before disconnect/reconnect.)\r\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {\r\n      var firstBlock = self._outstandingMethodBlocks.shift();\r\n      if (! _.isEmpty(firstBlock.methods))\r\n        throw new Error(\"No methods outstanding but nonempty block: \" +\r\n                        JSON.stringify(firstBlock));\r\n\r\n      // Send the outstanding methods now in the first block.\r\n      if (!_.isEmpty(self._outstandingMethodBlocks))\r\n        self._sendOutstandingMethods();\r\n    }\r\n\r\n    // Maybe accept a hot code push.\r\n    self._maybeMigrate();\r\n  },\r\n\r\n  // Sends messages for all the methods in the first block in\r\n  // _outstandingMethodBlocks.\r\n  _sendOutstandingMethods: function() {\r\n    var self = this;\r\n    if (_.isEmpty(self._outstandingMethodBlocks))\r\n      return;\r\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\r\n      m.sendMessage();\r\n    });\r\n  },\r\n\r\n  _livedata_error: function (msg) {\r\n    Meteor._debug(\"Received error from server: \", msg.reason);\r\n    if (msg.offendingMessage)\r\n      Meteor._debug(\"For: \", msg.offendingMessage);\r\n  },\r\n\r\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {\r\n    var self = this;\r\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\r\n    self._outstandingMethodBlocks = [];\r\n\r\n    self.onReconnect();\r\n\r\n    if (_.isEmpty(oldOutstandingMethodBlocks))\r\n      return;\r\n\r\n    // We have at least one block worth of old outstanding methods to try\r\n    // again. First: did onReconnect actually send anything? If not, we just\r\n    // restore all outstanding methods and run the first block.\r\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\r\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\r\n      self._sendOutstandingMethods();\r\n      return;\r\n    }\r\n\r\n    // OK, there are blocks on both sides. Special case: merge the last block of\r\n    // the reconnect methods with the first block of the original methods, if\r\n    // neither of them are \"wait\" blocks.\r\n    if (!_.last(self._outstandingMethodBlocks).wait &&\r\n        !oldOutstandingMethodBlocks[0].wait) {\r\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\r\n        _.last(self._outstandingMethodBlocks).methods.push(m);\r\n\r\n        // If this \"last block\" is also the first block, send the message.\r\n        if (self._outstandingMethodBlocks.length === 1)\r\n          m.sendMessage();\r\n      });\r\n\r\n      oldOutstandingMethodBlocks.shift();\r\n    }\r\n\r\n    // Now add the rest of the original blocks on.\r\n    _.each(oldOutstandingMethodBlocks, function (block) {\r\n      self._outstandingMethodBlocks.push(block);\r\n    });\r\n  },\r\n\r\n  // We can accept a hot code push if there are no methods in flight.\r\n  _readyToMigrate: function() {\r\n    var self = this;\r\n    return _.isEmpty(self._methodInvokers);\r\n  },\r\n\r\n  // If we were blocking a migration, see if it's now possible to continue.\r\n  // Call whenever the set of outstanding/blocked methods shrinks.\r\n  _maybeMigrate: function () {\r\n    var self = this;\r\n    if (self._retryMigrate && self._readyToMigrate()) {\r\n      self._retryMigrate();\r\n      self._retryMigrate = null;\r\n    }\r\n  }\r\n});\r\n\r\nLivedataTest.Connection = Connection;\r\n\r\n// @param url {String} URL to Meteor app,\r\n//     e.g.:\r\n//     \"subdomain.meteor.com\",\r\n//     \"http://subdomain.meteor.com\",\r\n//     \"/\",\r\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\r\n//\r\nDDP.connect = function (url, options) {\r\n  var ret = new Connection(url, options);\r\n  allConnections.push(ret); // hack. see below.\r\n  return ret;\r\n};\r\n\r\n// Hack for `spiderable` package: a way to see if the page is done\r\n// loading all the data it needs.\r\n//\r\nallConnections = [];\r\nDDP._allSubscriptionsReady = function () {\r\n  return _.all(allConnections, function (conn) {\r\n    return _.all(conn._subscriptions, function (sub) {\r\n      return sub.ready;\r\n    });\r\n  });\r\n};\r\n","// Only create a server if we are in an environment with a HTTP server\r\n// (as opposed to, eg, a command-line tool).\r\n//\r\nif (Package.webapp) {\r\n  if (process.env.DDP_DEFAULT_CONNECTION_URL) {\r\n    __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL =\r\n      process.env.DDP_DEFAULT_CONNECTION_URL;\r\n  }\r\n\r\n  Meteor.server = new Server;\r\n\r\n  Meteor.refresh = function (notification) {\r\n    DDPServer._InvalidationCrossbar.fire(notification);\r\n  };\r\n\r\n  // Proxy the public methods of Meteor.server so they can\r\n  // be called directly on Meteor.\r\n  _.each(['publish', 'methods', 'call', 'apply', 'onConnection'],\r\n         function (name) {\r\n           Meteor[name] = _.bind(Meteor.server[name], Meteor.server);\r\n         });\r\n} else {\r\n  // No server? Make these empty/no-ops.\r\n  Meteor.server = null;\r\n  Meteor.refresh = function (notification) {\r\n  };\r\n}\r\n\r\n// Meteor.server used to be called Meteor.default_server. Provide\r\n// backcompat as a courtesy even though it was never documented.\r\n// XXX COMPAT WITH 0.6.4\r\nMeteor.default_server = Meteor.server;\r\n"]}