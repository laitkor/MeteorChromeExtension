)]}'
{"version":3,"file":"\\packages\\id-map.js","sources":["id-map/id-map.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yC;AACA,kB;AACA,iB;AACA,oD;AACA,wC;AACA,E;;AAEA,4E;AACA,6E;AACA,6E;AACA,gD;;AAEA,2B;AACA,sB;AACA,oB;AACA,oC;AACA,0B;AACA,I;AACA,6B;AACA,oB;AACA,oC;AACA,2B;AACA,I;AACA,yB;AACA,oB;AACA,oC;AACA,0B;AACA,I;AACA,sB;AACA,oB;AACA,oC;AACA,iC;AACA,I;AACA,sB;AACA,oB;AACA,gC;AACA,I;AACA,sB;AACA,oB;AACA,mB;AACA,I;AACA,0E;AACA,gC;AACA,oB;AACA,0D;AACA,iC;AACA,2C;AACA,gE;AACA,+D;AACA,iC;AACA,e;AACA,K;AACA,I;AACA,qB;AACA,oB;AACA,6B;AACA,I;AACA,kC;AACA,oB;AACA,oC;AACA,8B;AACA,4B;AACA,yB;AACA,e;AACA,I;AACA,6E;AACA,0D;AACA,sB;AACA,oB;AACA,4D;AACA,uC;AACA,wC;AACA,O;AACA,iB;AACA,G;AACA,G","sourcesContent":["IdMap = function (idStringify, idParse) {\r\n  var self = this;\r\n  self._map = {};\r\n  self._idStringify = idStringify || JSON.stringify;\r\n  self._idParse = idParse || JSON.parse;\r\n};\r\n\r\n// Some of these methods are designed to match methods on OrderedDict, since\r\n// (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably.\r\n// (Conceivably, this should be replaced with \"UnorderedDict\" with a specific\r\n// set of methods that overlap between the two.)\r\n\r\n_.extend(IdMap.prototype, {\r\n  get: function (id) {\r\n    var self = this;\r\n    var key = self._idStringify(id);\r\n    return self._map[key];\r\n  },\r\n  set: function (id, value) {\r\n    var self = this;\r\n    var key = self._idStringify(id);\r\n    self._map[key] = value;\r\n  },\r\n  remove: function (id) {\r\n    var self = this;\r\n    var key = self._idStringify(id);\r\n    delete self._map[key];\r\n  },\r\n  has: function (id) {\r\n    var self = this;\r\n    var key = self._idStringify(id);\r\n    return _.has(self._map, key);\r\n  },\r\n  empty: function () {\r\n    var self = this;\r\n    return _.isEmpty(self._map);\r\n  },\r\n  clear: function () {\r\n    var self = this;\r\n    self._map = {};\r\n  },\r\n  // Iterates over the items in the map. Return `false` to break the loop.\r\n  forEach: function (iterator) {\r\n    var self = this;\r\n    // don't use _.each, because we can't break out of it.\r\n    var keys = _.keys(self._map);\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var breakIfFalse = iterator.call(null, self._map[keys[i]],\r\n                                       self._idParse(keys[i]));\r\n      if (breakIfFalse === false)\r\n        return;\r\n    }\r\n  },\r\n  size: function () {\r\n    var self = this;\r\n    return _.size(self._map);\r\n  },\r\n  setDefault: function (id, def) {\r\n    var self = this;\r\n    var key = self._idStringify(id);\r\n    if (_.has(self._map, key))\r\n      return self._map[key];\r\n    self._map[key] = def;\r\n    return def;\r\n  },\r\n  // Assumes that values are EJSON-cloneable, and that we don't need to clone\r\n  // IDs (ie, that nobody is going to mutate an ObjectId).\r\n  clone: function () {\r\n    var self = this;\r\n    var clone = new IdMap(self._idStringify, self._idParse);\r\n    self.forEach(function (value, id) {\r\n      clone.set(id, EJSON.clone(value));\r\n    });\r\n    return clone;\r\n  }\r\n});\r\n\r\n"]}