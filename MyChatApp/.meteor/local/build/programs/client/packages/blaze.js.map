)]}'
{"version":3,"file":"\\packages\\blaze.js","sources":["blaze/preamble.js","blaze/dombackend.js","blaze/domrange.js","blaze/events.js","blaze/attrs.js","blaze/materializer.js","blaze/exceptions.js","blaze/reactivevar.js","blaze/view.js","blaze/builtins.js","blaze/lookup.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,W;;;;;;;;;;;;;;;;;;;ACAA,oB;AACA,8B;;AAEA,mD;AACA,4C;AACA,6D;AACA,U;AACA,sC;;AAEA,sB;;AAEA,wC;AACA,8B;AACA,I;AACA,yD;AACA,2D;AACA,yC;AACA,mC;AACA,E;;AAEA,qB;AACA,qD;AACA,4D;AACA,qC;AACA,4D;AACA,0C;AACA,I;;AAEA,oD;AACA,uC;AACA,I;;AAEA,+D;AACA,0B;;AAEA,oC;AACA,mC;AACA,yC;;AAEA,uE;AACA,wE;AACA,yE;AACA,mE;AACA,2E;AACA,4B;AACA,6C;AACA,2C;AACA,kC;AACA,M;;AAEA,wC;;AAEA,kD;AACA,qC;AACA,+C;AACA,I;;AAEA,uD;AACA,kD;AACA,oE;AACA,I;;AAEA,mC;AACA,2B;AACA,mC;AACA,oB;AACA,mC;AACA,gB;AACA,G;AACA,E;;;AAGA,6C;;AAEA,6C;AACA,mD;AACA,E;AACA,2D;AACA,mD;AACA,2D;AACA,Q;;AAEA,0B;;AAEA,8B;AACA,wC;AACA,mB;AACA,mB;AACA,mB;AACA,E;;AAEA,mD;AACA,0D;AACA,0B;AACA,qB;AACA,0B;AACA,qB;AACA,E;;AAEA,iD;AACA,6B;AACA,6B;AACA,E;;AAEA,6C;AACA,uB;AACA,iB;AACA,E;;AAEA,oE;;AAEA,uB;AACA,+C;AACA,wC;AACA,yE;AACA,0E;AACA,8E;AACA,gC;AACA,4C;AACA,yC;;AAEA,gD;AACA,2B;AACA,oD;AACA,4C;;AAEA,+C;AACA,iE;AACA,K;;AAEA,mC;;AAEA,4C;AACA,I;AACA,uE;AACA,0C;AACA,oC;AACA,mB;AACA,uE;AACA,uC;AACA,kD;AACA,+C;AACA,8B;AACA,K;AACA,qB;AACA,yB;AACA,G;AACA,E;;AAEA,6D;AACA,sB;AACA,kE;AACA,gE;AACA,kE;AACA,uB;AACA,I;AACA,wB;AACA,oB;AACA,uD;AACA,oB;AACA,+B;AACA,iC;AACA,iB;AACA,uB;AACA,O;AACA,qB;;AAEA,gD;AACA,K;AACA,G;AACA,E;;;AAGA,+C;AACA,qD;AACA,+C;AACA,0D;AACA,gC;AACA,E;;;;;;;;;;;;;;;;;;;;ACjLA,gE;AACA,yD;;AAEA,8C;AACA,E;AACA,sE;AACA,uE;AACA,+D;AACA,+D;AACA,+C;AACA,mC;AACA,2B;AACA,2C;;AAEA,mD;AACA,0D;AACA,sC;;AAEA,0C;AACA,+B;;AAEA,yB;AACA,oC;AACA,wB;AACA,4B;AACA,0B;AACA,uC;AACA,E;AACA,8B;;AAEA,sD;AACA,wD;AACA,uD;AACA,2D;AACA,uD;AACA,wD;AACA,sD;AACA,yD;AACA,qD;AACA,uB;AACA,mD;AACA,qB;AACA,6C;AACA,O;AACA,6B;AACA,e;AACA,W;AACA,kB;AACA,G;AACA,gB;AACA,K;;AAEA,iB;AACA,6E;AACA,sB;AACA,8B;AACA,+C;AACA,U;AACA,gB;AACA,8D;AACA,Q;AACA,gE;AACA,G;AACA,E;;AAEA,2C;AACA,sB;AACA,8B;AACA,e;AACA,U;AACA,qC;AACA,G;AACA,E;;AAEA,8C;AACA,qB;AACA,W;AACA,yB;AACA,qE;AACA,2C;AACA,U;AACA,gC;AACA,G;AACA,E;;AAEA,4D;AACA,gE;AACA,sB;AACA,yB;AACA,yD;AACA,2C;AACA,U;AACA,iC;AACA,G;AACA,E;;AAEA,0D;AACA,8B;AACA,W;AACA,gE;AACA,sB;AACA,yB;AACA,uD;AACA,yC;AACA,U;AACA,iC;AACA,G;AACA,E;;AAEA,uC;AACA,0B;AACA,wD;AACA,mB;AACA,2B;AACA,wC;AACA,gB;AACA,6B;AACA,G;AACA,e;AACA,E;;AAEA,yE;AACA,kE;AACA,uD;AACA,sB;AACA,I;AACA,gE;AACA,2C;AACA,gB;AACA,kD;AACA,0B;AACA,oG;AACA,G;;AAEA,6B;AACA,uB;AACA,sC;AACA,8C;AACA,qE;AACA,K;AACA,U;AACA,uB;AACA,0C;AACA,oC;AACA,qC;AACA,6C;AACA,8D;AACA,G;AACA,uB;AACA,qC;;AAEA,kB;AACA,4D;AACA,0C;AACA,wD;AACA,K;AACA,G;AACA,E;;AAEA,iE;AACA,wC;AACA,gE;AACA,sC;;AAEA,gC;;AAEA,6C;AACA,mC;AACA,6C;AACA,kC;;AAEA,wB;AACA,8B;AACA,U;AACA,2D;AACA,iD;AACA,0D;AACA,iD;AACA,6C;AACA,oB;AACA,gC;AACA,2C;AACA,K;AACA,G;AACA,E;;AAEA,4C;AACA,sB;AACA,wC;;AAEA,4B;AACA,sC;;AAEA,0B;AACA,qD;AACA,E;;AAEA,2C;AACA,sB;AACA,wC;;AAEA,4B;AACA,sC;;AAEA,gD;AACA,oD;AACA,E;;AAEA,yC;AACA,sB;AACA,wC;;AAEA,4C;AACA,6B;AACA,uB;AACA,8C;AACA,mC;AACA,K;AACA,U;AACA,iD;AACA,gD;AACA,sC;AACA,G;AACA,wB;AACA,4B;;AAEA,0D;AACA,wC;AACA,yD;AACA,G;AACA,E;;AAEA,uE;AACA,6B;AACA,oD;AACA,gE;;AAEA,gB;AACA,8B;;AAEA,wB;AACA,+C;AACA,0C;AACA,oC;AACA,8D;AACA,iC;AACA,U;AACA,iB;AACA,qC;AACA,sB;AACA,6C;AACA,Y;AACA,+B;AACA,6D;AACA,K;AACA,0C;AACA,uE;AACA,G;AACA,E;;AAEA,+D;AACA,6B;AACA,mD;AACA,mE;;AAEA,gB;AACA,+B;AACA,U;AACA,qC;AACA,+B;;AAEA,+B;AACA,oD;AACA,mC;AACA,Y;AACA,iC;AACA,wB;AACA,oC;AACA,K;AACA,G;AACA,E;;AAEA,+D;AACA,sC;AACA,gD;AACA,qD;AACA,E;;AAEA,mD;AACA,6B;AACA,mD;AACA,gE;AACA,+B;AACA,E;;AAEA,6C;AACA,4B;AACA,yB;AACA,2C;AACA,0B;AACA,E;;AAEA,8C;AACA,8B;AACA,e;AACA,4C;AACA,yB;AACA,kD;AACA,kB;AACA,yB;AACA,2B;AACA,4B;AACA,K;AACA,G;AACA,E;;AAEA,kD;;AAEA,8D;AACA,0C;AACA,2D;AACA,6B;AACA,0C;AACA,4C;AACA,E;;AAEA,oD;AACA,sC;AACA,E;;AAEA,sD;AACA,sB;AACA,wC;;AAEA,iE;AACA,mE;AACA,oE;AACA,8D;AACA,8D;AACA,uC;;AAEA,iE;AACA,0B;AACA,yD;AACA,iB;;AAEA,6D;AACA,qC;AACA,gD;AACA,2B;;AAEA,gC;AACA,iC;AACA,8B;;AAEA,wB;AACA,E;;AAEA,qD;AACA,sB;AACA,wC;;AAEA,uB;AACA,iB;;AAEA,8D;AACA,8D;AACA,2D;AACA,+D;AACA,+B;;AAEA,iD;AACA,qD;;AAEA,qB;AACA,uC;;AAEA,iC;AACA,8B;;AAEA,wB;AACA,E;;AAEA,qD;AACA,kD;AACA,E;;AAEA,+C;AACA,2C;AACA,2C;AACA,2C;AACA,oD;AACA,8D;AACA,6C;AACA,gC;AACA,yC;AACA,E;;AAEA,4C;AACA,kB;;AAEA,sC;AACA,mB;AACA,wD;;AAEA,0D;AACA,0D;AACA,+C;AACA,wD;AACA,2D;AACA,0D;AACA,4B;;AAEA,4D;AACA,4C;AACA,wD;AACA,yD;;AAEA,sE;;AAEA,4D;AACA,6D;AACA,sD;AACA,e;;AAEA,0D;AACA,yD;AACA,kB;AACA,oC;AACA,0D;AACA,wD;AACA,iC;AACA,kB;;AAEA,sC;AACA,I;;AAEA,yB;AACA,iD;AACA,0C;AACA,wB;AACA,8C;AACA,yB;AACA,wB;AACA,2B;AACA,K;AACA,yB;AACA,U;AACA,mE;AACA,yC;AACA,G;;AAEA,iB;AACA,E;;AAEA,+D;AACA,E;AACA,mE;AACA,2D;AACA,0C;AACA,kC;AACA,iB;AACA,c;AACA,iB;;AAEA,kC;AACA,+C;AACA,U;AACA,+D;AACA,0E;AACA,gE;AACA,yC;AACA,qB;AACA,6C;AACA,mB;AACA,gB;AACA,kB;;AAEA,yB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACjeA,2C;;AAEA,kC;;AAEA,oD;AACA,oD;AACA,qD;AACA,kB;AACA,E;AACA,mC;AACA,sD;AACA,kD;AACA,wD;AACA,qD;AACA,kC;AACA,E;;AAEA,4C;AACA,S;AACA,c;AACA,c;AACA,E;;AAEA,2B;;AAEA,sE;AACA,mB;AACA,mB;AACA,2B;AACA,yB;AACA,6B;AACA,mC;;AAEA,6B;;AAEA,wD;AACA,0D;AACA,0B;AACA,I;AACA,wD;AACA,8C;AACA,yC;AACA,2B;AACA,6D;AACA,gD;AACA,e;AACA,qD;AACA,M;AACA,W;;AAEA,oD;AACA,iC;AACA,wD;AACA,qD;AACA,qD;AACA,sD;AACA,8C;;AAEA,6C;AACA,kC;AACA,0D;;AAEA,qB;AACA,2C;AACA,6B;AACA,wC;AACA,6C;AACA,4B;AACA,mD;AACA,gC;AACA,yC;AACA,kD;AACA,kD;AACA,mB;AACA,kB;AACA,iD;AACA,mD;AACA,mC;AACA,0C;AACA,+C;AACA,kD;AACA,W;AACA,S;;AAEA,gC;AACA,Q;AACA,a;;AAEA,U;AACA,oC;AACA,G;AACA,E;AACA,qC;;AAEA,yC;AACA,sE;AACA,gE;AACA,4D;AACA,0C;AACA,wC;AACA,iD;AACA,6B;AACA,G;;AAEA,yC;AACA,qC;AACA,2B;AACA,mD;AACA,E;;AAEA,2C;AACA,wC;AACA,+D;AACA,iE;;AAEA,yC;AACA,4D;AACA,8D;AACA,E;;AAEA,oG;;AAEA,sB;AACA,0C;AACA,uB;AACA,K;;AAEA,0B;AACA,sD;AACA,6B;;AAEA,0C;AACA,oB;AACA,+C;;AAEA,+B;AACA,iB;AACA,kC;AACA,yB;AACA,K;AACA,oC;AACA,oC;AACA,mD;AACA,oC;AACA,sB;AACA,iC;AACA,2E;AACA,sE;AACA,wD;AACA,6B;AACA,oD;AACA,uC;AACA,8C;AACA,gD;AACA,2B;AACA,iC;AACA,kC;AACA,uB;AACA,qB;AACA,8D;AACA,gC;AACA,+C;AACA,kD;AACA,W;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,U;AACA,sD;AACA,uB;AACA,4C;AACA,sB;AACA,e;AACA,qE;AACA,oE;AACA,qE;AACA,kE;AACA,oB;AACA,uD;AACA,gD;AACA,mD;AACA,mB;AACA,mB;AACA,wC;AACA,2D;AACA,mD;AACA,qC;AACA,8D;AACA,W;AACA,S;AACA,O;AACA,gC;AACA,K;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;;ACnMA,gF;AACA,kE;AACA,uE;AACA,sB;AACA,E;AACA,gD;AACA,uE;AACA,4E;AACA,yE;AACA,uE;AACA,0E;AACA,yE;AACA,wE;AACA,sE;AACA,0E;AACA,+B;AACA,E;AACA,2E;AACA,kE;AACA,E;AACA,4E;AACA,0D;;AAEA,2C;AACA,mB;AACA,qB;AACA,E;;AAEA,yE;AACA,uB;AACA,0B;AACA,yC;AACA,U;AACA,2C;AACA,G;AACA,E;;AAEA,8C;AACA,qB;AACA,iE;AACA,4C;AACA,I;AACA,kC;AACA,kC;AACA,c;AACA,yC;AACA,iB;AACA,E;;AAEA,iF;AACA,E;AACA,wE;AACA,qE;AACA,6E;AACA,2E;AACA,E;AACA,8D;;AAEA,uD;AACA,+C;AACA,oE;AACA,kF;;AAEA,gE;AACA,0D;;AAEA,mE;;AAEA,mD;AACA,iE;;AAEA,8C;AACA,+B;AACA,2B;AACA,O;;AAEA,8C;AACA,mC;AACA,O;;AAEA,yD;AACA,G;AACA,G;;AAEA,mD;AACA,6B;AACA,uC;AACA,6B;AACA,I;AACA,2C;AACA,kC;AACA,I;AACA,qC;AACA,oB;;AAEA,mD;AACA,gB;AACA,8B;AACA,O;AACA,kB;AACA,G;AACA,G;;AAEA,2C;AACA,uC;AACA,qC;AACA,I;AACA,2C;AACA,6C;AACA,G;AACA,G;;AAEA,mD;AACA,uC;AACA,yC;AACA,I;AACA,uC;AACA,uB;AACA,uC;AACA,Y;AACA,2C;AACA,K;AACA,I;;AAEA,uE;AACA,I;AACA,a;AACA,gF;AACA,qC;AACA,oB;;AAEA,2E;AACA,yG;AACA,4H;AACA,uC;AACA,mB;AACA,0C;AACA,gC;AACA,wE;;AAEA,wE;AACA,qC;AACA,8C;AACA,2C;;AAEA,qC;AACA,K;;AAEA,kB;AACA,G;AACA,G;;AAEA,8C;AACA,+C;AACA,yB;AACA,wB;AACA,2B;AACA,8B;AACA,Y;AACA,2B;AACA,K;AACA,G;AACA,G;;AAEA,4C;AACA,+C;AACA,0B;AACA,G;AACA,G;;AAEA,+D;AACA,yC;AACA,4C;AACA,8C;AACA,4C;AACA,yB;AACA,4B;AACA,iD;AACA,Y;AACA,wD;AACA,K;AACA,G;AACA,G;;AAEA,mD;AACA,oC;AACA,mC;AACA,E;;AAEA,mD;AACA,wE;AACA,Q;AACA,yE;AACA,kB;AACA,qB;AACA,yB;AACA,yB;AACA,gB;AACA,kB;AACA,kB;AACA,sD;AACA,yB;AACA,gB;AACA,mB;AACA,mB;AACA,mB;AACA,uC;AACA,+B;AACA,gC;AACA,sB;AACA,oB;AACA,2C;AACA,2B;AACA,mB;AACA,uB;AACA,uB;AACA,qB;AACA,I;;AAEA,8B;AACA,gB;AACA,G;;AAEA,6C;AACA,4C;AACA,E;;AAEA,qE;AACA,uE;AACA,2B;AACA,sB;AACA,2D;AACA,C;;AAEA,qC;AACA,wB;AACA,sC;AACA,iE;AACA,U;AACA,oE;AACA,G;AACA,E;;AAEA,uE;AACA,oD;AACA,mE;AACA,qE;AACA,gD;AACA,mD;AACA,0C;AACA,+C;AACA,oB;AACA,yB;;AAEA,sC;AACA,mC;AACA,Y;AACA,2E;AACA,iC;AACA,2E;AACA,2D;AACA,yD;AACA,yC;AACA,0D;AACA,c;AACA,qC;AACA,O;AACA,K;AACA,G;AACA,G;;AAEA,iE;AACA,qD;AACA,sE;AACA,kE;AACA,yB;AACA,6B;AACA,8C;AACA,Y;AACA,2C;AACA,K;AACA,gC;AACA,yC;AACA,kE;AACA,gE;AACA,2C;AACA,sE;AACA,mC;AACA,8D;AACA,kC;AACA,yC;AACA,gD;AACA,sD;AACA,kD;AACA,uC;AACA,U;AACA,6C;AACA,G;;AAEA,gE;AACA,oC;AACA,E;;;AAGA,4C;AACA,mB;AACA,qB;AACA,E;;AAEA,+D;AACA,sB;AACA,gE;AACA,uB;AACA,+B;;AAEA,2B;AACA,+B;AACA,6D;AACA,4D;AACA,yD;AACA,sD;AACA,4B;AACA,gC;AACA,mC;AACA,2B;AACA,2C;AACA,yB;AACA,K;AACA,G;;AAEA,2B;AACA,uB;AACA,iB;AACA,4B;AACA,+B;AACA,2B;AACA,2B;AACA,uD;AACA,8B;AACA,wB;AACA,O;AACA,Y;AACA,4B;AACA,+B;AACA,K;AACA,6B;AACA,4B;AACA,4C;AACA,yB;AACA,2B;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACjWA,qC;AACA,E;AACA,kE;AACA,E;AACA,wB;AACA,8C;AACA,2B;AACA,sC;AACA,qB;AACA,I;AACA,mD;AACA,mC;AACA,oD;AACA,qB;AACA,I;AACA,+C;AACA,uD;AACA,I;AACA,2C;AACA,0C;AACA,sC;AACA,qB;AACA,I;AACA,+C;AACA,mE;AACA,qB;AACA,I;AACA,uC;AACA,mE;AACA,wB;AACA,sD;AACA,0C;AACA,+B;;AAEA,qB;AACA,I;AACA,uC;AACA,oB;AACA,8B;AACA,a;AACA,6D;AACA,sC;AACA,mB;AACA,6E;AACA,Y;AACA,wB;AACA,6C;AACA,K;;AAEA,6B;AACA,gC;AACA,wD;AACA,gD;AACA,qE;AACA,yC;AACA,qE;AACA,qE;AACA,yE;AACA,uB;AACA,2C;AACA,mC;AACA,2E;AACA,8D;AACA,O;AACA,gD;AACA,gE;AACA,oB;AACA,K;;AAEA,mB;AACA,2D;AACA,0C;AACA,yC;AACA,0E;AACA,mE;AACA,6B;AACA,8C;AACA,wE;AACA,0D;AACA,qE;AACA,S;AACA,wC;AACA,Q;AACA,6B;AACA,4B;AACA,uE;AACA,c;AACA,2D;AACA,2C;AACA,oE;AACA,a;AACA,W;AACA,O;AACA,iF;AACA,kC;AACA,S;AACA,K;;AAEA,uD;AACA,0D;AACA,qC;AACA,sC;AACA,uB;AACA,U;AACA,4B;AACA,K;;AAEA,yB;;AAEA,qB;AACA,I;AACA,wC;AACA,4B;AACA,+B;AACA,kC;AACA,gE;AACA,uB;AACA,K;;AAEA,8B;AACA,4D;AACA,G;AACA,G;;AAEA,mC;AACA,gE;AACA,iE;AACA,qC;AACA,8D;AACA,iE;AACA,wC;AACA,I;AACA,gE;AACA,iD;AACA,+D;AACA,qD;AACA,oB;AACA,iC;AACA,uB;AACA,kD;AACA,E;;;;;;;;;;;;;;;;;;;AC5IA,c;;AAEA,2E;AACA,8E;AACA,4E;AACA,sB;AACA,E;AACA,S;AACA,E;AACA,M;AACA,Q;AACA,yB;AACA,gB;AACA,0B;AACA,I;AACA,M;AACA,E;AACA,6D;;AAEA,yD;AACA,wD;AACA,iD;AACA,kC;;AAEA,2C;AACA,kC;AACA,sC;AACA,Y;AACA,G;;AAEA,kB;AACA,wB;AACA,6B;AACA,6D;AACA,8E;AACA,gC;AACA,M;;AAEA,4E;AACA,gF;AACA,gE;AACA,4E;AACA,E;;AAEA,oD;AACA,8B;AACA,a;;AAEA,sB;AACA,S;AACA,sC;AACA,iB;AACA,8D;AACA,K;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACvDA,G;AACA,yD;AACA,E;AACA,8D;AACA,gE;AACA,6D;AACA,gB;AACA,E;AACA,uE;AACA,yE;AACA,sE;AACA,0E;AACA,E;AACA,uE;AACA,wE;AACA,8D;AACA,qE;AACA,kE;AACA,uE;AACA,uE;AACA,yE;AACA,qE;AACA,sC;AACA,E;AACA,qE;AACA,8D;AACA,G;;AAEA,yD;AACA,4C;AACA,2B;AACA,2D;;AAEA,+B;AACA,+B;AACA,iC;AACA,E;;AAEA,4D;AACA,iC;AACA,0D;AACA,iD;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,+C;AACA,kB;AACA,sB;;AAEA,uB;AACA,E;;AAEA,uD;AACA,+B;;AAEA,0E;AACA,iC;AACA,W;;AAEA,2B;AACA,qB;AACA,E;;AAEA,oD;AACA,2C;AACA,E;;;;;;;;;;;;;;;;;;;ACrEA,0C;AACA,G;AACA,iE;AACA,2B;AACA,G;AACA,uE;AACA,uE;AACA,G;AACA,oE;AACA,gE;AACA,iC;AACA,G;AACA,kE;AACA,+D;AACA,8C;AACA,G;AACA,iE;AACA,4D;AACA,G;AACA,iE;AACA,oE;AACA,+D;AACA,qE;AACA,iE;AACA,6C;AACA,G;AACA,2B;AACA,G;AACA,oE;AACA,mE;AACA,mE;AACA,gE;AACA,sE;AACA,oD;AACA,sC;AACA,qC;AACA,2B;AACA,wC;;AAEA,mC;AACA,8B;AACA,kB;AACA,c;AACA,G;AACA,mB;AACA,uB;;AAEA,qB;AACA,kB;AACA,uB;AACA,mB;AACA,mB;AACA,I;;AAEA,yD;AACA,0D;AACA,kD;AACA,yB;AACA,qC;AACA,2B;AACA,0B;AACA,yB;AACA,uB;;AAEA,uB;AACA,E;;AAEA,2D;;AAEA,gD;AACA,0D;AACA,mC;AACA,E;AACA,qD;AACA,oE;AACA,wC;AACA,E;AACA,iD;AACA,4D;AACA,oC;AACA,E;AACA,kD;AACA,8D;AACA,qC;AACA,E;;AAEA,sB;AACA,G;AACA,+D;AACA,6D;AACA,2D;AACA,8D;AACA,gE;AACA,4C;AACA,G;AACA,+D;AACA,iE;AACA,mE;AACA,8C;AACA,G;AACA,6C;AACA,sE;AACA,6D;AACA,yD;AACA,kD;AACA,2D;AACA,kB;;AAEA,qE;AACA,sE;AACA,mE;AACA,qE;AACA,sE;AACA,+C;AACA,I;AACA,qE;AACA,iE;AACA,sE;AACA,iE;AACA,iE;AACA,kE;AACA,0B;AACA,I;AACA,uE;AACA,oE;AACA,qE;AACA,oE;AACA,uE;AACA,0B;AACA,yB;AACA,6F;AACA,G;AACA,wB;AACA,0H;AACA,G;AACA,oB;AACA,6H;AACA,G;;AAEA,gD;AACA,oE;AACA,6B;AACA,O;AACA,K;AACA,8C;;AAEA,W;AACA,E;;AAEA,+C;AACA,2C;AACA,+C;AACA,uC;AACA,0D;AACA,0B;AACA,O;AACA,K;AACA,E;;AAEA,qD;AACA,yC;;AAEA,qB;AACA,wD;AACA,wB;;AAEA,wC;;AAEA,e;;AAEA,oC;AACA,8C;AACA,sD;AACA,sE;AACA,+C;AACA,0D;AACA,wC;AACA,iD;AACA,S;AACA,S;AACA,K;AACA,I;;AAEA,iB;AACA,qE;AACA,8B;AACA,gC;AACA,uC;AACA,8C;AACA,sE;AACA,wB;AACA,yB;AACA,6B;AACA,iC;AACA,8B;;AAEA,iD;AACA,yE;AACA,4D;AACA,wE;AACA,2B;AACA,0D;AACA,qC;AACA,iC;AACA,kB;AACA,gD;AACA,W;AACA,qD;AACA,uC;AACA,2B;AACA,uC;AACA,S;AACA,S;AACA,0B;;AAEA,sE;AACA,mE;AACA,kE;AACA,wD;AACA,qC;AACA,kC;AACA,S;AACA,O;;AAEA,4B;;AAEA,2D;AACA,iE;AACA,sC;AACA,yD;AACA,W;;AAEA,iC;AACA,O;;AAEA,kC;AACA,kC;AACA,0C;AACA,0B;AACA,O;AACA,K;;AAEA,kB;AACA,E;;AAEA,gE;AACA,oE;AACA,gE;AACA,sE;AACA,mE;AACA,iE;AACA,gE;AACA,oE;AACA,Y;AACA,iD;AACA,yC;;AAEA,qB;AACA,wD;AACA,wB;AACA,oC;;AAEA,wC;;AAEA,yB;AACA,wD;AACA,yB;AACA,K;AACA,0B;;AAEA,2C;;AAEA,oB;AACA,mC;AACA,8B;AACA,O;AACA,U;AACA,4B;AACA,G;;AAEA,gB;AACA,E;;AAEA,wB;AACA,yD;AACA,0B;AACA,6B;AACA,4B;AACA,+B;AACA,gC;AACA,mD;;AAEA,+D;AACA,wE;AACA,I;AACA,qC;AACA,gC;AACA,oC;AACA,4D;;AAEA,2D;AACA,gF;AACA,I;AACA,+C;AACA,uE;AACA,yD;AACA,oC;AACA,4D;;AAEA,kE;AACA,8B;AACA,G;AACA,G;;AAEA,6D;AACA,wC;AACA,0C;AACA,+B;AACA,iD;AACA,E;;AAEA,+C;AACA,sD;AACA,mC;AACA,6C;AACA,E;;AAEA,wD;AACA,sD;AACA,mC;AACA,sD;AACA,E;;AAEA,iD;AACA,uB;AACA,W;AACA,0B;;AAEA,0C;;AAEA,4D;AACA,+D;AACA,iE;;AAEA,oB;AACA,mC;AACA,E;;AAEA,qC;AACA,0B;AACA,oD;AACA,E;;AAEA,6D;AACA,+D;AACA,S;AACA,yC;AACA,8B;AACA,4D;AACA,yB;AACA,uB;AACA,U;AACA,uB;AACA,6D;AACA,gC;AACA,G;AACA,E;;AAEA,yB;;AAEA,+C;AACA,kC;AACA,O;AACA,6B;AACA,kB;AACA,a;AACA,gC;AACA,G;AACA,E;;AAEA,iC;AACA,mD;AACA,E;;AAEA,4C;AACA,4B;AACA,4C;AACA,0D;AACA,yC;AACA,E;;AAEA,+C;AACA,sD;;AAEA,W;AACA,sC;AACA,yC;AACA,yC;AACA,sC;AACA,U;AACA,0C;AACA,gF;AACA,mB;AACA,G;AACA,iD;AACA,E;;AAEA,8C;AACA,mC;AACA,yE;AACA,sD;AACA,wD;AACA,E;;AAEA,wD;AACA,mC;AACA,yE;;AAEA,qE;AACA,kC;AACA,0B;AACA,sB;AACA,G;AACA,sD;;AAEA,iB;AACA,yC;AACA,6C;AACA,6C;AACA,+C;AACA,qD;;AAEA,kE;AACA,E;;AAEA,oC;AACA,6C;AACA,gD;AACA,E;;AAEA,wD;AACA,U;AACA,wC;AACA,+B;AACA,wD;AACA,4D;AACA,4D;AACA,qD;AACA,a;AACA,gD;;AAEA,a;AACA,sC;AACA,6B;AACA,wB;AACA,U;AACA,4D;AACA,yB;AACA,gB;AACA,G;AACA,E;;AAEA,gE;AACA,4C;AACA,oC;;AAEA,iC;AACA,2B;;AAEA,sB;AACA,E;;AAEA,6C;AACA,0B;;AAEA,a;AACA,gC;AACA,uB;AACA,G;;AAEA,mB;AACA,E;;AAEA,8C;AACA,8C;AACA,kB;AACA,2B;AACA,gC;AACA,iB;AACA,4B;AACA,kC;AACA,U;AACA,+D;AACA,K;AACA,G;;AAEA,a;AACA,sC;AACA,6B;AACA,wB;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,wC;AACA,mD;AACA,gD;AACA,E;;AAEA,qC;AACA,kD;AACA,gD;AACA,E;;AAEA,+D;AACA,0C;AACA,mB;;AAEA,sB;AACA,iD;;AAEA,wE;AACA,+C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,+C;AACA,uC;AACA,0B;AACA,2D;AACA,0B;AACA,oD;AACA,wC;AACA,4D;AACA,6D;AACA,e;AACA,Y;AACA,+B;AACA,iC;AACA,c;AACA,S;AACA,O;AACA,K;;AAEA,gC;AACA,kC;AACA,e;AACA,O;AACA,uB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC7iBA,6C;AACA,iD;AACA,iB;AACA,iB;AACA,E;;AAEA,2C;AACA,6C;;AAEA,uC;;AAEA,8B;AACA,qC;AACA,sC;AACA,gC;AACA,iC;AACA,0B;AACA,Y;AACA,6B;AACA,K;AACA,K;;AAEA,c;AACA,E;;AAEA,kE;AACA,2C;;AAEA,6D;AACA,+C;AACA,qC;AACA,K;AACA,qC;AACA,8B;AACA,8B;AACA,4D;AACA,+C;AACA,wB;AACA,K;;AAEA,c;AACA,E;;AAEA,gE;AACA,uE;AACA,E;;AAEA,wD;AACA,iD;AACA,wC;AACA,gC;AACA,qC;AACA,kD;AACA,qC;AACA,K;AACA,oB;AACA,K;AACA,gC;AACA,wB;AACA,8B;AACA,6B;AACA,qC;AACA,+B;AACA,0C;;AAEA,kC;AACA,qD;AACA,gE;AACA,oD;AACA,kC;AACA,qC;AACA,4B;;AAEA,+D;AACA,mC;AACA,Q;AACA,2C;AACA,sC;AACA,mE;AACA,8B;;AAEA,0C;AACA,gD;AACA,yC;AACA,sC;AACA,gD;AACA,0C;AACA,a;;AAEA,qE;AACA,sD;AACA,kB;AACA,mE;AACA,W;AACA,W;AACA,Q;AACA,6C;AACA,sC;AACA,8B;AACA,0C;AACA,gD;AACA,yC;AACA,kD;AACA,+D;AACA,yC;AACA,0C;AACA,sC;AACA,4D;AACA,gC;AACA,a;AACA,kB;AACA,sD;AACA,W;AACA,W;AACA,Q;AACA,yD;AACA,sC;AACA,uB;AACA,0C;AACA,gD;AACA,yC;AACA,+D;AACA,kB;AACA,uD;AACA,W;AACA,wC;AACA,W;AACA,Q;AACA,wD;AACA,sC;AACA,0C;AACA,gD;AACA,yC;AACA,6D;AACA,kB;AACA,oD;AACA,+C;AACA,0C;AACA,kD;AACA,W;AACA,W;AACA,O;AACA,O;;AAEA,uD;AACA,iC;AACA,mC;AACA,mD;AACA,K;AACA,K;;AAEA,oC;AACA,4B;AACA,iC;AACA,K;;AAEA,kB;AACA,E;;AAEA,mE;AACA,6D;AACA,2C;;AAEA,iE;AACA,oE;AACA,+D;AACA,+D;AACA,kC;AACA,uC;;AAEA,8B;AACA,8C;AACA,iC;AACA,K;AACA,c;AACA,E;;;;;;;;;;;;;;;;;;;AC/KA,6C;AACA,8B;AACA,a;AACA,sB;AACA,sC;AACA,I;AACA,E;;AAEA,kD;AACA,gC;AACA,wB;AACA,wC;AACA,uB;AACA,kB;AACA,sC;AACA,M;AACA,G;AACA,W;AACA,E;;AAEA,+B;AACA,4D;AACA,E;;AAEA,2C;AACA,uD;AACA,sD;AACA,uD;AACA,qC;AACA,+B;AACA,E;AACA,sD;AACA,mD;AACA,0C;AACA,yD;AACA,+B;AACA,qD;;AAEA,yB;AACA,mE;AACA,0C;AACA,8B;AACA,uE;;AAEA,yE;;AAEA,8C;AACA,qE;AACA,2D;AACA,qC;AACA,uC;AACA,8E;AACA,U;AACA,wB;AACA,sD;AACA,wC;AACA,qD;AACA,qD;AACA,O;AACA,yD;AACA,qD;AACA,O;AACA,iB;AACA,oB;AACA,yB;AACA,oC;AACA,iC;AACA,2D;AACA,S;AACA,iB;AACA,O;AACA,sC;AACA,M;AACA,G;AACA,c;AACA,E;;AAEA,kC;AACA,6C;AACA,yD;AACA,6C;AACA,iD;AACA,mD;AACA,G;;AAEA,gB;AACA,gB;AACA,uB;AACA,yD;AACA,+B;AACA,E;;;AAGA,uD;AACA,4C;AACA,E","sourcesContent":["Blaze = {};\r\n","var DOMBackend = {};\r\nBlaze.DOMBackend = DOMBackend;\r\n\r\nvar $jq = (typeof jQuery !== 'undefined' ? jQuery :\r\n           (typeof Package !== 'undefined' ?\r\n            Package.jquery && Package.jquery.jQuery : null));\r\nif (! $jq)\r\n  throw new Error(\"jQuery not found\");\r\n\r\nDOMBackend._$jq = $jq;\r\n\r\nDOMBackend.parseHTML = function (html) {\r\n  // Return an array of nodes.\r\n  //\r\n  // jQuery does fancy stuff like creating an appropriate\r\n  // container element and setting innerHTML on it, as well\r\n  // as working around various IE quirks.\r\n  return $jq.parseHTML(html) || [];\r\n};\r\n\r\nDOMBackend.Events = {\r\n  // `selector` is non-null.  `type` is one type (but\r\n  // may be in backend-specific form, e.g. have namespaces).\r\n  // Order fired must be order bound.\r\n  delegateEvents: function (elem, type, selector, handler) {\r\n    $jq(elem).on(type, selector, handler);\r\n  },\r\n\r\n  undelegateEvents: function (elem, type, handler) {\r\n    $jq(elem).off(type, '**', handler);\r\n  },\r\n\r\n  bindEventCapturer: function (elem, type, selector, handler) {\r\n    var $elem = $jq(elem);\r\n\r\n    var wrapper = function (event) {\r\n      event = $jq.event.fix(event);\r\n      event.currentTarget = event.target;\r\n\r\n      // Note: It might improve jQuery interop if we called into jQuery\r\n      // here somehow.  Since we don't use jQuery to dispatch the event,\r\n      // we don't fire any of jQuery's event hooks or anything.  However,\r\n      // since jQuery can't bind capturing handlers, it's not clear\r\n      // where we would hook in.  Internal jQuery functions like `dispatch`\r\n      // are too high-level.\r\n      var $target = $jq(event.currentTarget);\r\n      if ($target.is($elem.find(selector)))\r\n        handler.call(elem, event);\r\n    };\r\n\r\n    handler._meteorui_wrapper = wrapper;\r\n\r\n    type = DOMBackend.Events.parseEventType(type);\r\n    // add *capturing* event listener\r\n    elem.addEventListener(type, wrapper, true);\r\n  },\r\n\r\n  unbindEventCapturer: function (elem, type, handler) {\r\n    type = DOMBackend.Events.parseEventType(type);\r\n    elem.removeEventListener(type, handler._meteorui_wrapper, true);\r\n  },\r\n\r\n  parseEventType: function (type) {\r\n    // strip off namespaces\r\n    var dotLoc = type.indexOf('.');\r\n    if (dotLoc >= 0)\r\n      return type.slice(0, dotLoc);\r\n    return type;\r\n  }\r\n};\r\n\r\n\r\n///// Removal detection and interoperability.\r\n\r\n// For an explanation of this technique, see:\r\n// http://bugs.jquery.com/ticket/12213#comment:23 .\r\n//\r\n// In short, an element is considered \"removed\" when jQuery\r\n// cleans up its *private* userdata on the element,\r\n// which we can detect using a custom event with a teardown\r\n// hook.\r\n\r\nvar NOOP = function () {};\r\n\r\n// Circular doubly-linked list\r\nvar TeardownCallback = function (func) {\r\n  this.next = this;\r\n  this.prev = this;\r\n  this.func = func;\r\n};\r\n\r\n// Insert newElt before oldElt in the circular list\r\nTeardownCallback.prototype.linkBefore = function(oldElt) {\r\n  this.prev = oldElt.prev;\r\n  this.next = oldElt;\r\n  oldElt.prev.next = this;\r\n  oldElt.prev = this;\r\n};\r\n\r\nTeardownCallback.prototype.unlink = function () {\r\n  this.prev.next = this.next;\r\n  this.next.prev = this.prev;\r\n};\r\n\r\nTeardownCallback.prototype.go = function () {\r\n  var func = this.func;\r\n  func && func();\r\n};\r\n\r\nTeardownCallback.prototype.stop = TeardownCallback.prototype.unlink;\r\n\r\nDOMBackend.Teardown = {\r\n  _JQUERY_EVENT_NAME: 'blaze_teardown_watcher',\r\n  _CB_PROP: '$blaze_teardown_callbacks',\r\n  // Registers a callback function to be called when the given element or\r\n  // one of its ancestors is removed from the DOM via the backend library.\r\n  // The callback function is called at most once, and it receives the element\r\n  // in question as an argument.\r\n  onElementTeardown: function (elem, func) {\r\n    var elt = new TeardownCallback(func);\r\n\r\n    var propName = DOMBackend.Teardown._CB_PROP;\r\n    if (! elem[propName]) {\r\n      // create an empty node that is never unlinked\r\n      elem[propName] = new TeardownCallback;\r\n\r\n      // Set up the event, only the first time.\r\n      $jq(elem).on(DOMBackend.Teardown._JQUERY_EVENT_NAME, NOOP);\r\n    }\r\n\r\n    elt.linkBefore(elem[propName]);\r\n\r\n    return elt; // so caller can call stop()\r\n  },\r\n  // Recursively call all teardown hooks, in the backend and registered\r\n  // through DOMBackend.onElementTeardown.\r\n  tearDownElement: function (elem) {\r\n    var elems = [];\r\n    // Array.prototype.slice.call doesn't work when given a NodeList in\r\n    // IE8 (\"JScript object expected\").\r\n    var nodeList = elem.getElementsByTagName('*');\r\n    for (var i = 0; i < nodeList.length; i++) {\r\n      elems.push(nodeList[i]);\r\n    }\r\n    elems.push(elem);\r\n    $jq.cleanData(elems);\r\n  }\r\n};\r\n\r\n$jq.event.special[DOMBackend.Teardown._JQUERY_EVENT_NAME] = {\r\n  setup: function () {\r\n    // This \"setup\" callback is important even though it is empty!\r\n    // Without it, jQuery will call addEventListener, which is a\r\n    // performance hit, especially with Chrome's async stack trace\r\n    // feature enabled.\r\n  },\r\n  teardown: function() {\r\n    var elem = this;\r\n    var callbacks = elem[DOMBackend.Teardown._CB_PROP];\r\n    if (callbacks) {\r\n      var elt = callbacks.next;\r\n      while (elt !== callbacks) {\r\n        elt.go();\r\n        elt = elt.next;\r\n      }\r\n      callbacks.go();\r\n\r\n      elem[DOMBackend.Teardown._CB_PROP] = null;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n// Must use jQuery semantics for `context`, not\r\n// querySelectorAll's.  In other words, all the parts\r\n// of `selector` must be found under `context`.\r\nDOMBackend.findBySelector = function (selector, context) {\r\n  return $jq(selector, context);\r\n};\r\n","\r\n// A constant empty array (frozen if the JS engine supports it).\r\nvar _emptyArray = Object.freeze ? Object.freeze([]) : [];\r\n\r\n// `[new] Blaze.DOMRange([nodeAndRangeArray])`\r\n//\r\n// A DOMRange consists of an array of consecutive nodes and DOMRanges,\r\n// which may be replaced at any time with a new array.  If the DOMRange\r\n// has been attached to the DOM at some location, then updating\r\n// the array will cause the DOM to be updated at that location.\r\nBlaze.DOMRange = function (nodeAndRangeArray) {\r\n  if (! (this instanceof DOMRange))\r\n    // called without `new`\r\n    return new DOMRange(nodeAndRangeArray);\r\n\r\n  var members = (nodeAndRangeArray || _emptyArray);\r\n  if (! (members && (typeof members.length) === 'number'))\r\n    throw new Error(\"Expected array\");\r\n\r\n  for (var i = 0; i < members.length; i++)\r\n    this._memberIn(members[i]);\r\n\r\n  this.members = members;\r\n  this.emptyRangePlaceholder = null;\r\n  this.attached = false;\r\n  this.parentElement = null;\r\n  this.parentRange = null;\r\n  this.attachedCallbacks = _emptyArray;\r\n};\r\nvar DOMRange = Blaze.DOMRange;\r\n\r\n// In IE 8, don't use empty text nodes as placeholders\r\n// in empty DOMRanges, use comment nodes instead.  Using\r\n// empty text nodes in modern browsers is great because\r\n// it doesn't clutter the web inspector.  In IE 8, however,\r\n// it seems to lead in some roundabout way to the OAuth\r\n// pop-up crashing the browser completely.  In the past,\r\n// we didn't use empty text nodes on IE 8 because they\r\n// don't accept JS properties, so just use the same logic\r\n// even though we don't need to set properties on the\r\n// placeholder anymore.\r\nDOMRange._USE_COMMENT_PLACEHOLDERS = (function () {\r\n  var result = false;\r\n  var textNode = document.createTextNode(\"\");\r\n  try {\r\n    textNode.someProp = true;\r\n  } catch (e) {\r\n    // IE 8\r\n    result = true;\r\n  }\r\n  return result;\r\n})();\r\n\r\n// static methods\r\nDOMRange._insert = function (rangeOrNode, parentElement, nextNode, _isMove) {\r\n  var m = rangeOrNode;\r\n  if (m instanceof DOMRange) {\r\n    m.attach(parentElement, nextNode, _isMove);\r\n  } else {\r\n    if (_isMove)\r\n      DOMRange._moveNodeWithHooks(m, parentElement, nextNode);\r\n    else\r\n      DOMRange._insertNodeWithHooks(m, parentElement, nextNode);\r\n  }\r\n};\r\n\r\nDOMRange._remove = function (rangeOrNode) {\r\n  var m = rangeOrNode;\r\n  if (m instanceof DOMRange) {\r\n    m.detach();\r\n  } else {\r\n    DOMRange._removeNodeWithHooks(m);\r\n  }\r\n};\r\n\r\nDOMRange._removeNodeWithHooks = function (n) {\r\n  if (! n.parentNode)\r\n    return;\r\n  if (n.nodeType === 1 &&\r\n      n.parentNode._uihooks && n.parentNode._uihooks.removeElement) {\r\n    n.parentNode._uihooks.removeElement(n);\r\n  } else {\r\n    n.parentNode.removeChild(n);\r\n  }\r\n};\r\n\r\nDOMRange._insertNodeWithHooks = function (n, parent, next) {\r\n  // `|| null` because IE throws an error if 'next' is undefined\r\n  next = next || null;\r\n  if (n.nodeType === 1 &&\r\n      parent._uihooks && parent._uihooks.insertElement) {\r\n    parent._uihooks.insertElement(n, next);\r\n  } else {\r\n    parent.insertBefore(n, next);\r\n  }\r\n};\r\n\r\nDOMRange._moveNodeWithHooks = function (n, parent, next) {\r\n  if (n.parentNode !== parent)\r\n    return;\r\n  // `|| null` because IE throws an error if 'next' is undefined\r\n  next = next || null;\r\n  if (n.nodeType === 1 &&\r\n      parent._uihooks && parent._uihooks.moveElement) {\r\n    parent._uihooks.moveElement(n, next);\r\n  } else {\r\n    parent.insertBefore(n, next);\r\n  }\r\n};\r\n\r\nDOMRange.forElement = function (elem) {\r\n  if (elem.nodeType !== 1)\r\n    throw new Error(\"Expected element, found: \" + elem);\r\n  var range = null;\r\n  while (elem && ! range) {\r\n    range = (elem.$blaze_range || null);\r\n    if (! range)\r\n      elem = elem.parentNode;\r\n  }\r\n  return range;\r\n};\r\n\r\nDOMRange.prototype.attach = function (parentElement, nextNode, _isMove) {\r\n  // This method is called to insert the DOMRange into the DOM for\r\n  // the first time, but it's also used internally when\r\n  // updating the DOM.\r\n  //\r\n  // If _isMove is true, move this attached range to a different\r\n  // location under the same parentElement.\r\n  if (_isMove) {\r\n    if (! (this.parentElement === parentElement &&\r\n           this.attached))\r\n      throw new Error(\"Can only move an attached DOMRange, and only under the same parent element\");\r\n  }\r\n\r\n  var members = this.members;\r\n  if (members.length) {\r\n    this.emptyRangePlaceholder = null;\r\n    for (var i = 0; i < members.length; i++) {\r\n      DOMRange._insert(members[i], parentElement, nextNode, _isMove);\r\n    }\r\n  } else {\r\n    var placeholder = (\r\n      DOMRange._USE_COMMENT_PLACEHOLDERS ?\r\n        document.createComment(\"\") :\r\n        document.createTextNode(\"\"));\r\n    this.emptyRangePlaceholder = placeholder;\r\n    parentElement.insertBefore(placeholder, nextNode || null);\r\n  }\r\n  this.attached = true;\r\n  this.parentElement = parentElement;\r\n\r\n  if (! _isMove) {\r\n    for(var i = 0; i < this.attachedCallbacks.length; i++) {\r\n      var obj = this.attachedCallbacks[i];\r\n      obj.attached && obj.attached(this, parentElement);\r\n    }\r\n  }\r\n};\r\n\r\nDOMRange.prototype.setMembers = function (newNodeAndRangeArray) {\r\n  var newMembers = newNodeAndRangeArray;\r\n  if (! (newMembers && (typeof newMembers.length) === 'number'))\r\n    throw new Error(\"Expected array\");\r\n\r\n  var oldMembers = this.members;\r\n\r\n  for (var i = 0; i < oldMembers.length; i++)\r\n    this._memberOut(oldMembers[i]);\r\n  for (var i = 0; i < newMembers.length; i++)\r\n    this._memberIn(newMembers[i]);\r\n\r\n  if (! this.attached) {\r\n    this.members = newMembers;\r\n  } else {\r\n    // don't do anything if we're going from empty to empty\r\n    if (newMembers.length || oldMembers.length) {\r\n      // detach the old members and insert the new members\r\n      var nextNode = this.lastNode().nextSibling;\r\n      var parentElement = this.parentElement;\r\n      this.detach();\r\n      this.members = newMembers;\r\n      this.attach(parentElement, nextNode);\r\n    }\r\n  }\r\n};\r\n\r\nDOMRange.prototype.firstNode = function () {\r\n  if (! this.attached)\r\n    throw new Error(\"Must be attached\");\r\n\r\n  if (! this.members.length)\r\n    return this.emptyRangePlaceholder;\r\n\r\n  var m = this.members[0];\r\n  return (m instanceof DOMRange) ? m.firstNode() : m;\r\n};\r\n\r\nDOMRange.prototype.lastNode = function () {\r\n  if (! this.attached)\r\n    throw new Error(\"Must be attached\");\r\n\r\n  if (! this.members.length)\r\n    return this.emptyRangePlaceholder;\r\n\r\n  var m = this.members[this.members.length - 1];\r\n  return (m instanceof DOMRange) ? m.lastNode() : m;\r\n};\r\n\r\nDOMRange.prototype.detach = function () {\r\n  if (! this.attached)\r\n    throw new Error(\"Must be attached\");\r\n\r\n  var oldParentElement = this.parentElement;\r\n  var members = this.members;\r\n  if (members.length) {\r\n    for (var i = 0; i < members.length; i++) {\r\n      DOMRange._remove(members[i]);\r\n    }\r\n  } else {\r\n    var placeholder = this.emptyRangePlaceholder;\r\n    this.parentElement.removeChild(placeholder);\r\n    this.emptyRangePlaceholder = null;\r\n  }\r\n  this.attached = false;\r\n  this.parentElement = null;\r\n\r\n  for(var i = 0; i < this.attachedCallbacks.length; i++) {\r\n    var obj = this.attachedCallbacks[i];\r\n    obj.detached && obj.detached(this, oldParentElement);\r\n  }\r\n};\r\n\r\nDOMRange.prototype.addMember = function (newMember, atIndex, _isMove) {\r\n  var members = this.members;\r\n  if (! (atIndex >= 0 && atIndex <= members.length))\r\n    throw new Error(\"Bad index in range.addMember: \" + atIndex);\r\n\r\n  if (! _isMove)\r\n    this._memberIn(newMember);\r\n\r\n  if (! this.attached) {\r\n    // currently detached; just updated members\r\n    members.splice(atIndex, 0, newMember);\r\n  } else if (members.length === 0) {\r\n    // empty; use the empty-to-nonempty handling of setMembers\r\n    this.setMembers([newMember]);\r\n  } else {\r\n    var nextNode;\r\n    if (atIndex === members.length) {\r\n      // insert at end\r\n      nextNode = this.lastNode().nextSibling;\r\n    } else {\r\n      var m = members[atIndex];\r\n      nextNode = (m instanceof DOMRange) ? m.firstNode() : m;\r\n    }\r\n    members.splice(atIndex, 0, newMember);\r\n    DOMRange._insert(newMember, this.parentElement, nextNode, _isMove);\r\n  }\r\n};\r\n\r\nDOMRange.prototype.removeMember = function (atIndex, _isMove) {\r\n  var members = this.members;\r\n  if (! (atIndex >= 0 && atIndex < members.length))\r\n    throw new Error(\"Bad index in range.removeMember: \" + atIndex);\r\n\r\n  if (_isMove) {\r\n    members.splice(atIndex, 1);\r\n  } else {\r\n    var oldMember = members[atIndex];\r\n    this._memberOut(oldMember);\r\n\r\n    if (members.length === 1) {\r\n      // becoming empty; use the logic in setMembers\r\n      this.setMembers(_emptyArray);\r\n    } else {\r\n      members.splice(atIndex, 1);\r\n      if (this.attached)\r\n        DOMRange._remove(oldMember);\r\n    }\r\n  }\r\n};\r\n\r\nDOMRange.prototype.moveMember = function (oldIndex, newIndex) {\r\n  var member = this.members[oldIndex];\r\n  this.removeMember(oldIndex, true /*_isMove*/);\r\n  this.addMember(member, newIndex, true /*_isMove*/);\r\n};\r\n\r\nDOMRange.prototype.getMember = function (atIndex) {\r\n  var members = this.members;\r\n  if (! (atIndex >= 0 && atIndex < members.length))\r\n    throw new Error(\"Bad index in range.getMember: \" + atIndex);\r\n  return this.members[atIndex];\r\n};\r\n\r\nDOMRange.prototype._memberIn = function (m) {\r\n  if (m instanceof DOMRange)\r\n    m.parentRange = this;\r\n  else if (m.nodeType === 1) // DOM Element\r\n    m.$blaze_range = this;\r\n};\r\n\r\nDOMRange._destroy = function (m, _skipNodes) {\r\n  if (m instanceof DOMRange) {\r\n    if (m.view)\r\n      Blaze.destroyView(m.view, _skipNodes);\r\n    m.parentRange = null;\r\n  } else if ((! _skipNodes) && m.nodeType === 1) {\r\n    // DOM Element\r\n    if (m.$blaze_range) {\r\n      Blaze.destroyNode(m);\r\n      m.$blaze_range = null;\r\n    }\r\n  }\r\n};\r\n\r\nDOMRange.prototype._memberOut = DOMRange._destroy;\r\n\r\n// Tear down, but don't remove, the members.  Used when chunks\r\n// of DOM are being torn down or replaced.\r\nDOMRange.prototype.destroyMembers = function (_skipNodes) {\r\n  var members = this.members;\r\n  for (var i = 0; i < members.length; i++)\r\n    this._memberOut(members[i], _skipNodes);\r\n};\r\n\r\nDOMRange.prototype.destroy = function (_skipNodes) {\r\n  DOMRange._destroy(this, _skipNodes);\r\n};\r\n\r\nDOMRange.prototype.containsElement = function (elem) {\r\n  if (! this.attached)\r\n    throw new Error(\"Must be attached\");\r\n\r\n  // An element is contained in this DOMRange if it's possible to\r\n  // reach it by walking parent pointers, first through the DOM and\r\n  // then parentRange pointers.  In other words, the element or some\r\n  // ancestor of it is at our level of the DOM (a child of our\r\n  // parentElement), and this element is one of our members or\r\n  // is a member of a descendant Range.\r\n\r\n  // First check that elem is a descendant of this.parentElement,\r\n  // according to the DOM.\r\n  if (! Blaze._elementContains(this.parentElement, elem))\r\n    return false;\r\n\r\n  // If elem is not an immediate child of this.parentElement,\r\n  // walk up to its ancestor that is.\r\n  while (elem.parentNode !== this.parentElement)\r\n    elem = elem.parentNode;\r\n\r\n  var range = elem.$blaze_range;\r\n  while (range && range !== this)\r\n    range = range.parentRange;\r\n\r\n  return range === this;\r\n};\r\n\r\nDOMRange.prototype.containsRange = function (range) {\r\n  if (! this.attached)\r\n    throw new Error(\"Must be attached\");\r\n\r\n  if (! range.attached)\r\n    return false;\r\n\r\n  // A DOMRange is contained in this DOMRange if it's possible\r\n  // to reach this range by following parent pointers.  If the\r\n  // DOMRange has the same parentElement, then it should be\r\n  // a member, or a member of a member etc.  Otherwise, we must\r\n  // contain its parentElement.\r\n\r\n  if (range.parentElement !== this.parentElement)\r\n    return this.containsElement(range.parentElement);\r\n\r\n  if (range === this)\r\n    return false; // don't contain self\r\n\r\n  while (range && range !== this)\r\n    range = range.parentRange;\r\n\r\n  return range === this;\r\n};\r\n\r\nDOMRange.prototype.onAttached = function (attached) {\r\n  this.onAttachedDetached({ attached: attached });\r\n};\r\n\r\n// callbacks are `attached(range, element)` and\r\n// `detached(range, element)`, and they may\r\n// access the `callbacks` object in `this`.\r\n// The arguments to `detached` are the same\r\n// range and element that were passed to `attached`.\r\nDOMRange.prototype.onAttachedDetached = function (callbacks) {\r\n  if (this.attachedCallbacks === _emptyArray)\r\n    this.attachedCallbacks = [];\r\n  this.attachedCallbacks.push(callbacks);\r\n};\r\n\r\nDOMRange.prototype.$ = function (selector) {\r\n  var self = this;\r\n\r\n  var parentNode = this.parentElement;\r\n  if (! parentNode)\r\n    throw new Error(\"Can't select in removed DomRange\");\r\n\r\n  // Strategy: Find all selector matches under parentNode,\r\n  // then filter out the ones that aren't in this DomRange\r\n  // using `DOMRange#containsElement`.  This is\r\n  // asymptotically slow in the presence of O(N) sibling\r\n  // content that is under parentNode but not in our range,\r\n  // so if performance is an issue, the selector should be\r\n  // run on a child element.\r\n\r\n  // Since jQuery can't run selectors on a DocumentFragment,\r\n  // we don't expect findBySelector to work.\r\n  if (parentNode.nodeType === 11 /* DocumentFragment */)\r\n    throw new Error(\"Can't use $ on an offscreen range\");\r\n\r\n  var results = Blaze.DOMBackend.findBySelector(selector, parentNode);\r\n\r\n  // We don't assume `results` has jQuery API; a plain array\r\n  // should do just as well.  However, if we do have a jQuery\r\n  // array, we want to end up with one also, so we use\r\n  // `.filter`.\r\n\r\n  // Function that selects only elements that are actually\r\n  // in this DomRange, rather than simply descending from\r\n  // `parentNode`.\r\n  var filterFunc = function (elem) {\r\n    // handle jQuery's arguments to filter, where the node\r\n    // is in `this` and the index is the first argument.\r\n    if (typeof elem === 'number')\r\n      elem = this;\r\n\r\n    return self.containsElement(elem);\r\n  };\r\n\r\n  if (! results.filter) {\r\n    // not a jQuery array, and not a browser with\r\n    // Array.prototype.filter (e.g. IE <9)\r\n    var newResults = [];\r\n    for (var i = 0; i < results.length; i++) {\r\n      var x = results[i];\r\n      if (filterFunc(x))\r\n        newResults.push(x);\r\n    }\r\n    results = newResults;\r\n  } else {\r\n    // `results.filter` is either jQuery's or ECMAScript's `filter`\r\n    results = results.filter(filterFunc);\r\n  }\r\n\r\n  return results;\r\n};\r\n\r\n// Returns true if element a contains node b and is not node b.\r\n//\r\n// The restriction that `a` be an element (not a document fragment,\r\n// say) is based on what's easy to implement cross-browser.\r\nBlaze._elementContains = function (a, b) {\r\n  if (a.nodeType !== 1) // ELEMENT\r\n    return false;\r\n  if (a === b)\r\n    return false;\r\n\r\n  if (a.compareDocumentPosition) {\r\n    return a.compareDocumentPosition(b) & 0x10;\r\n  } else {\r\n    // Should be only old IE and maybe other old browsers here.\r\n    // Modern Safari has both functions but seems to get contains() wrong.\r\n    // IE can't handle b being a text node.  We work around this\r\n    // by doing a direct parent test now.\r\n    b = b.parentNode;\r\n    if (! (b && b.nodeType === 1)) // ELEMENT\r\n      return false;\r\n    if (a === b)\r\n      return true;\r\n\r\n    return a.contains(b);\r\n  }\r\n};\r\n","var EventSupport = Blaze.EventSupport = {};\r\n\r\nvar DOMBackend = Blaze.DOMBackend;\r\n\r\n// List of events to always delegate, never capture.\r\n// Since jQuery fakes bubbling for certain events in\r\n// certain browsers (like `submit`), we don't want to\r\n// get in its way.\r\n//\r\n// We could list all known bubbling\r\n// events here to avoid creating speculative capturers\r\n// for them, but it would only be an optimization.\r\nvar eventsToDelegate = EventSupport.eventsToDelegate = {\r\n  blur: 1, change: 1, click: 1, focus: 1, focusin: 1,\r\n  focusout: 1, reset: 1, submit: 1\r\n};\r\n\r\nvar EVENT_MODE = EventSupport.EVENT_MODE = {\r\n  TBD: 0,\r\n  BUBBLING: 1,\r\n  CAPTURING: 2\r\n};\r\n\r\nvar NEXT_HANDLERREC_ID = 1;\r\n\r\nvar HandlerRec = function (elem, type, selector, handler, recipient) {\r\n  this.elem = elem;\r\n  this.type = type;\r\n  this.selector = selector;\r\n  this.handler = handler;\r\n  this.recipient = recipient;\r\n  this.id = (NEXT_HANDLERREC_ID++);\r\n\r\n  this.mode = EVENT_MODE.TBD;\r\n\r\n  // It's important that delegatedHandler be a different\r\n  // instance for each handlerRecord, because its identity\r\n  // is used to remove it.\r\n  //\r\n  // It's also important that the closure have access to\r\n  // `this` when it is not called with it set.\r\n  this.delegatedHandler = (function (h) {\r\n    return function (evt) {\r\n      if ((! h.selector) && evt.currentTarget !== evt.target)\r\n        // no selector means only fire on target\r\n        return;\r\n      return h.handler.apply(h.recipient, arguments);\r\n    };\r\n  })(this);\r\n\r\n  // WHY CAPTURE AND DELEGATE: jQuery can't delegate\r\n  // non-bubbling events, because\r\n  // event capture doesn't work in IE 8.  However, there\r\n  // are all sorts of new-fangled non-bubbling events\r\n  // like \"play\" and \"touchenter\".  We delegate these\r\n  // events using capture in all browsers except IE 8.\r\n  // IE 8 doesn't support these events anyway.\r\n\r\n  var tryCapturing = elem.addEventListener &&\r\n        (! _.has(eventsToDelegate,\r\n                 DOMBackend.Events.parseEventType(type)));\r\n\r\n  if (tryCapturing) {\r\n    this.capturingHandler = (function (h) {\r\n      return function (evt) {\r\n        if (h.mode === EVENT_MODE.TBD) {\r\n          // must be first time we're called.\r\n          if (evt.bubbles) {\r\n            // this type of event bubbles, so don't\r\n            // get called again.\r\n            h.mode = EVENT_MODE.BUBBLING;\r\n            DOMBackend.Events.unbindEventCapturer(\r\n              h.elem, h.type, h.capturingHandler);\r\n            return;\r\n          } else {\r\n            // this type of event doesn't bubble,\r\n            // so unbind the delegation, preventing\r\n            // it from ever firing.\r\n            h.mode = EVENT_MODE.CAPTURING;\r\n            DOMBackend.Events.undelegateEvents(\r\n              h.elem, h.type, h.delegatedHandler);\r\n          }\r\n        }\r\n\r\n        h.delegatedHandler(evt);\r\n      };\r\n    })(this);\r\n\r\n  } else {\r\n    this.mode = EVENT_MODE.BUBBLING;\r\n  }\r\n};\r\nEventSupport.HandlerRec = HandlerRec;\r\n\r\nHandlerRec.prototype.bind = function () {\r\n  // `this.mode` may be EVENT_MODE_TBD, in which case we bind both. in\r\n  // this case, 'capturingHandler' is in charge of detecting the\r\n  // correct mode and turning off one or the other handlers.\r\n  if (this.mode !== EVENT_MODE.BUBBLING) {\r\n    DOMBackend.Events.bindEventCapturer(\r\n      this.elem, this.type, this.selector || '*',\r\n      this.capturingHandler);\r\n  }\r\n\r\n  if (this.mode !== EVENT_MODE.CAPTURING)\r\n    DOMBackend.Events.delegateEvents(\r\n      this.elem, this.type,\r\n      this.selector || '*', this.delegatedHandler);\r\n};\r\n\r\nHandlerRec.prototype.unbind = function () {\r\n  if (this.mode !== EVENT_MODE.BUBBLING)\r\n    DOMBackend.Events.unbindEventCapturer(this.elem, this.type,\r\n                                          this.capturingHandler);\r\n\r\n  if (this.mode !== EVENT_MODE.CAPTURING)\r\n    DOMBackend.Events.undelegateEvents(this.elem, this.type,\r\n                                       this.delegatedHandler);\r\n};\r\n\r\nEventSupport.listen = function (element, events, selector, handler, recipient, getParentRecipient) {\r\n\r\n  var eventTypes = [];\r\n  events.replace(/[^ /]+/g, function (e) {\r\n    eventTypes.push(e);\r\n  });\r\n\r\n  var newHandlerRecs = [];\r\n  for (var i = 0, N = eventTypes.length; i < N; i++) {\r\n    var type = eventTypes[i];\r\n\r\n    var eventDict = element.$blaze_events;\r\n    if (! eventDict)\r\n      eventDict = (element.$blaze_events = {});\r\n\r\n    var info = eventDict[type];\r\n    if (! info) {\r\n      info = eventDict[type] = {};\r\n      info.handlers = [];\r\n    }\r\n    var handlerList = info.handlers;\r\n    var handlerRec = new HandlerRec(\r\n      element, type, selector, handler, recipient);\r\n    newHandlerRecs.push(handlerRec);\r\n    handlerRec.bind();\r\n    handlerList.push(handlerRec);\r\n    // Move handlers of enclosing ranges to end, by unbinding and rebinding\r\n    // them.  In jQuery (or other DOMBackend) this causes them to fire\r\n    // later when the backend dispatches event handlers.\r\n    if (getParentRecipient) {\r\n      for (var r = getParentRecipient(recipient); r;\r\n           r = getParentRecipient(r)) {\r\n        // r is an enclosing range (recipient)\r\n        for (var j = 0, Nj = handlerList.length;\r\n             j < Nj; j++) {\r\n          var h = handlerList[j];\r\n          if (h.recipient === r) {\r\n            h.unbind();\r\n            h.bind();\r\n            handlerList.splice(j, 1); // remove handlerList[j]\r\n            handlerList.push(h);\r\n            j--; // account for removed handler\r\n            Nj--; // don't visit appended handlers\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    // closes over just `element` and `newHandlerRecs`\r\n    stop: function () {\r\n      var eventDict = element.$blaze_events;\r\n      if (! eventDict)\r\n        return;\r\n      // newHandlerRecs has only one item unless you specify multiple\r\n      // event types.  If this code is slow, it's because we have to\r\n      // iterate over handlerList here.  Clearing a whole handlerList\r\n      // via stop() methods is O(N^2) in the number of handlers on\r\n      // an element.\r\n      for (var i = 0; i < newHandlerRecs.length; i++) {\r\n        var handlerToRemove = newHandlerRecs[i];\r\n        var info = eventDict[handlerToRemove.type];\r\n        if (! info)\r\n          continue;\r\n        var handlerList = info.handlers;\r\n        for (var j = handlerList.length - 1; j >= 0; j--) {\r\n          if (handlerList[j] === handlerToRemove) {\r\n            handlerToRemove.unbind();\r\n            handlerList.splice(j, 1); // remove handlerList[j]\r\n          }\r\n        }\r\n      }\r\n      newHandlerRecs.length = 0;\r\n    }\r\n  };\r\n};\r\n","\r\n// An AttributeHandler object is responsible for updating a particular attribute\r\n// of a particular element.  AttributeHandler subclasses implement\r\n// browser-specific logic for dealing with particular attributes across\r\n// different browsers.\r\n//\r\n// To define a new type of AttributeHandler, use\r\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\r\n// where the `update` function takes arguments `(element, oldValue, value)`.\r\n// The `element` argument is always the same between calls to `update` on\r\n// the same instance.  `oldValue` and `value` are each either `null` or\r\n// a Unicode string of the type that might be passed to the value argument\r\n// of `setAttribute` (i.e. not an HTML string with character references).\r\n// When an AttributeHandler is installed, an initial call to `update` is\r\n// always made with `oldValue = null`.  The `update` method can access\r\n// `this.name` if the AttributeHandler class is a generic one that applies\r\n// to multiple attribute names.\r\n//\r\n// AttributeHandlers can store custom properties on `this`, as long as they\r\n// don't use the names `element`, `name`, `value`, and `oldValue`.\r\n//\r\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\r\n// only how they are updated after materialization as DOM.\r\n\r\nAttributeHandler = function (name, value) {\r\n  this.name = name;\r\n  this.value = value;\r\n};\r\n\r\nAttributeHandler.prototype.update = function (element, oldValue, value) {\r\n  if (value === null) {\r\n    if (oldValue !== null)\r\n      element.removeAttribute(this.name);\r\n  } else {\r\n    element.setAttribute(this.name, value);\r\n  }\r\n};\r\n\r\nAttributeHandler.extend = function (options) {\r\n  var curType = this;\r\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\r\n    AttributeHandler.apply(this, arguments);\r\n  };\r\n  subType.prototype = new curType;\r\n  subType.extend = curType.extend;\r\n  if (options)\r\n    _.extend(subType.prototype, options);\r\n  return subType;\r\n};\r\n\r\n/// Apply the diff between the attributes of \"oldValue\" and \"value\" to \"element.\"\r\n//\r\n// Each subclass must implement a parseValue method which takes a string\r\n// as an input and returns a dict of attributes. The keys of the dict\r\n// are unique identifiers (ie. css properties in the case of styles), and the\r\n// values are the entire attribute which will be injected into the element.\r\n//\r\n// Extended below to support classes, SVG elements and styles.\r\n\r\nvar DiffingAttributeHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    if (!this.getCurrentValue || !this.setValue || !this.parseValue)\r\n      throw new Error(\"Missing methods in subclass of 'DiffingAttributeHandler'\");\r\n\r\n    var oldAttrsMap = oldValue ? this.parseValue(oldValue) : {};\r\n    var newAttrsMap = value ? this.parseValue(value) : {};\r\n\r\n    // the current attributes on the element, which we will mutate.\r\n\r\n    var attrString = this.getCurrentValue(element);\r\n    var attrsMap = attrString ? this.parseValue(attrString) : {};\r\n\r\n    _.each(_.keys(oldAttrsMap), function (t) {\r\n      if (! (t in newAttrsMap))\r\n        delete attrsMap[t];\r\n    });\r\n\r\n    _.each(_.keys(newAttrsMap), function (t) {\r\n      attrsMap[t] = newAttrsMap[t];\r\n    });\r\n\r\n    this.setValue(element, _.values(attrsMap).join(' '));\r\n  }\r\n});\r\n\r\nvar ClassHandler = DiffingAttributeHandler.extend({\r\n  // @param rawValue {String}\r\n  getCurrentValue: function (element) {\r\n    return element.className;\r\n  },\r\n  setValue: function (element, className) {\r\n    element.className = className;\r\n  },\r\n  parseValue: function (attrString) {\r\n    var tokens = {};\r\n\r\n    _.each(attrString.split(' '), function(token) {\r\n      if (token)\r\n        tokens[token] = token;\r\n    });\r\n    return tokens;\r\n  }\r\n});\r\n\r\nvar SVGClassHandler = ClassHandler.extend({\r\n  getCurrentValue: function (element) {\r\n    return element.className.baseVal;\r\n  },\r\n  setValue: function (element, className) {\r\n    element.setAttribute('class', className);\r\n  }\r\n});\r\n\r\nvar StyleHandler = DiffingAttributeHandler.extend({\r\n  getCurrentValue: function (element) {\r\n    return element.getAttribute('style');\r\n  },\r\n  setValue: function (element, style) {\r\n    if (style === '') {\r\n      element.removeAttribute('style');\r\n    } else {\r\n      element.setAttribute('style', style);\r\n    }\r\n  },\r\n\r\n  // Parse a string to produce a map from property to attribute string.\r\n  //\r\n  // Example:\r\n  // \"color:red; foo:12px\" produces a token {color: \"color:red\", foo:\"foo:12px\"}\r\n  parseValue: function (attrString) {\r\n    var tokens = {};\r\n\r\n    // Regex for parsing a css attribute declaration, taken from css-parse:\r\n    // https://github.com/reworkcss/css-parse/blob/7cef3658d0bba872cde05a85339034b187cb3397/index.js#L219\r\n    var regex = /(\\*?[-#\\/\\*\\\\\\w]+(?:\\[[0-9a-z_-]+\\])?)\\s*:\\s*(?:\\'(?:\\\\\\'|.)*?\\'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+[;\\s]*/g;\r\n    var match = regex.exec(attrString);\r\n    while (match) {\r\n      // match[0] = entire matching string\r\n      // match[1] = css property\r\n      // Prefix the token to prevent conflicts with existing properties.\r\n\r\n      // XXX No `String.trim` on Safari 4. Swap out $.trim if we want to\r\n      // remove strong dep on jquery.\r\n      tokens[' ' + match[1]] = match[0].trim ?\r\n        match[0].trim() : $.trim(match[0]);\r\n\r\n      match = regex.exec(attrString);\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n});\r\n\r\nvar BooleanHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    var name = this.name;\r\n    if (value == null) {\r\n      if (oldValue != null)\r\n        element[name] = false;\r\n    } else {\r\n      element[name] = true;\r\n    }\r\n  }\r\n});\r\n\r\nvar ValueHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    element.value = value;\r\n  }\r\n});\r\n\r\n// attributes of the type 'xlink:something' should be set using\r\n// the correct namespace in order to work\r\nvar XlinkHandler = AttributeHandler.extend({\r\n  update: function(element, oldValue, value) {\r\n    var NS = 'http://www.w3.org/1999/xlink';\r\n    if (value === null) {\r\n      if (oldValue !== null)\r\n        element.removeAttributeNS(NS, this.name);\r\n    } else {\r\n      element.setAttributeNS(NS, this.name, this.value);\r\n    }\r\n  }\r\n});\r\n\r\n// cross-browser version of `instanceof SVGElement`\r\nvar isSVGElement = function (elem) {\r\n  return 'ownerSVGElement' in elem;\r\n};\r\n\r\nvar isUrlAttribute = function (tagName, attrName) {\r\n  // Compiled from http://www.w3.org/TR/REC-html40/index/attributes.html\r\n  // and\r\n  // http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1\r\n  var urlAttrs = {\r\n    FORM: ['action'],\r\n    BODY: ['background'],\r\n    BLOCKQUOTE: ['cite'],\r\n    Q: ['cite'],\r\n    DEL: ['cite'],\r\n    INS: ['cite'],\r\n    OBJECT: ['classid', 'codebase', 'data', 'usemap'],\r\n    APPLET: ['codebase'],\r\n    A: ['href'],\r\n    AREA: ['href'],\r\n    LINK: ['href'],\r\n    BASE: ['href'],\r\n    IMG: ['longdesc', 'src', 'usemap'],\r\n    FRAME: ['longdesc', 'src'],\r\n    IFRAME: ['longdesc', 'src'],\r\n    HEAD: ['profile'],\r\n    SCRIPT: ['src'],\r\n    INPUT: ['src', 'usemap', 'formaction'],\r\n    BUTTON: ['formaction'],\r\n    BASE: ['href'],\r\n    MENUITEM: ['icon'],\r\n    HTML: ['manifest'],\r\n    VIDEO: ['poster']\r\n  };\r\n\r\n  if (attrName === 'itemid') {\r\n    return true;\r\n  }\r\n\r\n  var urlAttrNames = urlAttrs[tagName] || [];\r\n  return _.contains(urlAttrNames, attrName);\r\n};\r\n\r\n// To get the protocol for a URL, we let the browser normalize it for\r\n// us, by setting it as the href for an anchor tag and then reading out\r\n// the 'protocol' property.\r\nif (Meteor.isClient) {\r\n  var anchorForNormalization = document.createElement('A');\r\n}\r\n\r\nvar getUrlProtocol = function (url) {\r\n  if (Meteor.isClient) {\r\n    anchorForNormalization.href = url;\r\n    return (anchorForNormalization.protocol || \"\").toLowerCase();\r\n  } else {\r\n    throw new Error('getUrlProtocol not implemented on the server');\r\n  }\r\n};\r\n\r\n// UrlHandler is an attribute handler for all HTML attributes that take\r\n// URL values. It disallows javascript: URLs, unless\r\n// UI._allowJavascriptUrls() has been called. To detect javascript:\r\n// urls, we set the attribute on a dummy anchor element and then read\r\n// out the 'protocol' property of the attribute.\r\nvar origUpdate = AttributeHandler.prototype.update;\r\nvar UrlHandler = AttributeHandler.extend({\r\n  update: function (element, oldValue, value) {\r\n    var self = this;\r\n    var args = arguments;\r\n\r\n    if (UI._javascriptUrlsAllowed()) {\r\n      origUpdate.apply(self, args);\r\n    } else {\r\n      var isJavascriptProtocol = (getUrlProtocol(value) === \"javascript:\");\r\n      if (isJavascriptProtocol) {\r\n        Meteor._debug(\"URLs that use the 'javascript:' protocol are not \" +\r\n                      \"allowed in URL attribute values. \" +\r\n                      \"Call UI._allowJavascriptUrls() \" +\r\n                      \"to enable them.\");\r\n        origUpdate.apply(self, [element, oldValue, null]);\r\n      } else {\r\n        origUpdate.apply(self, args);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n// XXX make it possible for users to register attribute handlers!\r\nmakeAttributeHandler = function (elem, name, value) {\r\n  // generally, use setAttribute but certain attributes need to be set\r\n  // by directly setting a JavaScript property on the DOM element.\r\n  if (name === 'class') {\r\n    if (isSVGElement(elem)) {\r\n      return new SVGClassHandler(name, value);\r\n    } else {\r\n      return new ClassHandler(name, value);\r\n    }\r\n  } else if (name === 'style') {\r\n    return new StyleHandler(name, value);\r\n  } else if ((elem.tagName === 'OPTION' && name === 'selected') ||\r\n             (elem.tagName === 'INPUT' && name === 'checked')) {\r\n    return new BooleanHandler(name, value);\r\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\r\n             && name === 'value') {\r\n    // internally, TEXTAREAs tracks their value in the 'value'\r\n    // attribute just like INPUTs.\r\n    return new ValueHandler(name, value);\r\n  } else if (name.substring(0,6) === 'xlink:') {\r\n    return new XlinkHandler(name.substring(6), value);\r\n  } else if (isUrlAttribute(elem.tagName, name)) {\r\n    return new UrlHandler(name, value);\r\n  } else {\r\n    return new AttributeHandler(name, value);\r\n  }\r\n\r\n  // XXX will need one for 'style' on IE, though modern browsers\r\n  // seem to handle setAttribute ok.\r\n};\r\n\r\n\r\nElementAttributesUpdater = function (elem) {\r\n  this.elem = elem;\r\n  this.handlers = {};\r\n};\r\n\r\n// Update attributes on `elem` to the dictionary `attrs`, whose\r\n// values are strings.\r\nElementAttributesUpdater.prototype.update = function(newAttrs) {\r\n  var elem = this.elem;\r\n  var handlers = this.handlers;\r\n\r\n  for (var k in handlers) {\r\n    if (! _.has(newAttrs, k)) {\r\n      // remove attributes (and handlers) for attribute names\r\n      // that don't exist as keys of `newAttrs` and so won't\r\n      // be visited when traversing it.  (Attributes that\r\n      // exist in the `newAttrs` object but are `null`\r\n      // are handled later.)\r\n      var handler = handlers[k];\r\n      var oldValue = handler.value;\r\n      handler.value = null;\r\n      handler.update(elem, oldValue, null);\r\n      delete handlers[k];\r\n    }\r\n  }\r\n\r\n  for (var k in newAttrs) {\r\n    var handler = null;\r\n    var oldValue;\r\n    var value = newAttrs[k];\r\n    if (! _.has(handlers, k)) {\r\n      if (value !== null) {\r\n        // make new handler\r\n        handler = makeAttributeHandler(elem, k, value);\r\n        handlers[k] = handler;\r\n        oldValue = null;\r\n      }\r\n    } else {\r\n      handler = handlers[k];\r\n      oldValue = handler.value;\r\n    }\r\n    if (oldValue !== value) {\r\n      handler.value = value;\r\n      handler.update(elem, oldValue, value);\r\n      if (value === null)\r\n        delete handlers[k];\r\n    }\r\n  }\r\n};\r\n","// new Blaze.DOMMaterializer(options)\r\n//\r\n// An HTML.Visitor that turns HTMLjs into DOM nodes and DOMRanges.\r\n//\r\n// Options: `parentView`\r\nBlaze.DOMMaterializer = HTML.Visitor.extend();\r\nBlaze.DOMMaterializer.def({\r\n  visitNull: function (x, intoArray) {\r\n    return intoArray;\r\n  },\r\n  visitPrimitive: function (primitive, intoArray) {\r\n    var string = String(primitive);\r\n    intoArray.push(document.createTextNode(string));\r\n    return intoArray;\r\n  },\r\n  visitCharRef: function (charRef, intoArray) {\r\n    return this.visitPrimitive(charRef.str, intoArray);\r\n  },\r\n  visitArray: function (array, intoArray) {\r\n    for (var i = 0; i < array.length; i++)\r\n      this.visit(array[i], intoArray);\r\n    return intoArray;\r\n  },\r\n  visitComment: function (comment, intoArray) {\r\n    intoArray.push(document.createComment(comment.sanitizedValue));\r\n    return intoArray;\r\n  },\r\n  visitRaw: function (raw, intoArray) {\r\n    // Get an array of DOM nodes by using the browser's HTML parser\r\n    // (like innerHTML).\r\n    var nodes = Blaze.DOMBackend.parseHTML(raw.value);\r\n    for (var i = 0; i < nodes.length; i++)\r\n      intoArray.push(nodes[i]);\r\n\r\n    return intoArray;\r\n  },\r\n  visitTag: function (tag, intoArray) {\r\n    var self = this;\r\n    var tagName = tag.tagName;\r\n    var elem;\r\n    if ((HTML.isKnownSVGElement(tagName) || isSVGAnchor(tag))\r\n        && document.createElementNS) {\r\n      // inline SVG\r\n      elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n    } else {\r\n      // normal elements\r\n      elem = document.createElement(tagName);\r\n    }\r\n\r\n    var rawAttrs = tag.attrs;\r\n    var children = tag.children;\r\n    if (tagName === 'textarea' && tag.children.length &&\r\n        ! (rawAttrs && ('value' in rawAttrs))) {\r\n      // Provide very limited support for TEXTAREA tags with children\r\n      // rather than a \"value\" attribute.\r\n      // Reactivity in the form of Views nested in the tag's children\r\n      // won't work.  Compilers should compile textarea contents into\r\n      // the \"value\" attribute of the tag, wrapped in a function if there\r\n      // is reactivity.\r\n      if (typeof rawAttrs === 'function' ||\r\n          HTML.isArray(rawAttrs)) {\r\n        throw new Error(\"Can't have reactive children of TEXTAREA node; \" +\r\n                        \"use the 'value' attribute instead.\");\r\n      }\r\n      rawAttrs = _.extend({}, rawAttrs || null);\r\n      rawAttrs.value = Blaze._expand(children, self.parentView);\r\n      children = [];\r\n    }\r\n\r\n    if (rawAttrs) {\r\n      var attrUpdater = new ElementAttributesUpdater(elem);\r\n      var updateAttributes = function () {\r\n        var parentView = self.parentView;\r\n        var expandedAttrs = Blaze._expandAttributes(rawAttrs, parentView);\r\n        var flattenedAttrs = HTML.flattenAttributes(expandedAttrs);\r\n        var stringAttrs = {};\r\n        for (var attrName in flattenedAttrs) {\r\n          stringAttrs[attrName] = Blaze.toText(flattenedAttrs[attrName],\r\n                                               parentView,\r\n                                               HTML.TEXTMODE.STRING);\r\n        }\r\n        attrUpdater.update(stringAttrs);\r\n      };\r\n      var updaterComputation;\r\n      if (self.parentView) {\r\n        updaterComputation = self.parentView.autorun(updateAttributes);\r\n      } else {\r\n        updaterComputation = Deps.nonreactive(function () {\r\n          return Deps.autorun(function () {\r\n            Deps.withCurrentView(self.parentView, updateAttributes);\r\n          });\r\n        });\r\n      }\r\n      Blaze.DOMBackend.Teardown.onElementTeardown(elem, function attrTeardown() {\r\n        updaterComputation.stop();\r\n      });\r\n    }\r\n\r\n    var childNodesAndRanges = self.visit(children, []);\r\n    for (var i = 0; i < childNodesAndRanges.length; i++) {\r\n      var x = childNodesAndRanges[i];\r\n      if (x instanceof Blaze.DOMRange)\r\n        x.attach(elem);\r\n      else\r\n        elem.appendChild(x);\r\n    }\r\n\r\n    intoArray.push(elem);\r\n\r\n    return intoArray;\r\n  },\r\n  visitObject: function (x, intoArray) {\r\n    if (Blaze.isTemplate(x))\r\n      x = Blaze.runTemplate(x);\r\n    if (x instanceof Blaze.View) {\r\n      intoArray.push(Blaze.materializeView(x, this.parentView));\r\n      return intoArray;\r\n    }\r\n\r\n    // throw the default error\r\n    return HTML.Visitor.prototype.visitObject.call(this, x);\r\n  }\r\n});\r\n\r\nvar isSVGAnchor = function (node) {\r\n  // We generally aren't able to detect SVG <a> elements because\r\n  // if \"A\" were in our list of known svg element names, then all\r\n  // <a> nodes would be created using\r\n  // `document.createElementNS`. But in the special case of <a\r\n  // xlink:href=\"...\">, we can at least detect that attribute and\r\n  // create an SVG <a> tag in that case.\r\n  //\r\n  // However, we still have a general problem of knowing when to\r\n  // use document.createElementNS and when to use\r\n  // document.createElement; for example, font tags will always\r\n  // be created as SVG elements which can cause other\r\n  // problems. #1977\r\n  return (node.tagName === \"a\" &&\r\n          node.attrs &&\r\n          node.attrs[\"xlink:href\"] !== undefined);\r\n};\r\n","var debugFunc;\r\n\r\n// We call into user code in many places, and it's nice to catch exceptions\r\n// propagated from user code immediately so that the whole system doesn't just\r\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\r\n// reports exceptions.\r\n//\r\n// Usage:\r\n//\r\n// ```\r\n// try {\r\n//   // ... someStuff ...\r\n// } catch (e) {\r\n//   reportUIException(e);\r\n// }\r\n// ```\r\n//\r\n// An optional second argument overrides the default message.\r\n\r\n// Set this to `true` to cause `reportException` to throw\r\n// the next exception rather than reporting it.  This is\r\n// useful in unit tests that test error messages.\r\nBlaze._throwNextException = false;\r\n\r\nBlaze.reportException = function (e, msg) {\r\n  if (Blaze._throwNextException) {\r\n    Blaze._throwNextException = false;\r\n    throw e;\r\n  }\r\n\r\n  if (! debugFunc)\r\n    // adapted from Deps\r\n    debugFunc = function () {\r\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\r\n              ((typeof console !== \"undefined\") && console.log ? console.log :\r\n               function () {}));\r\n    };\r\n\r\n  // In Chrome, `e.stack` is a multiline string that starts with the message\r\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\r\n  // `console.log` supplies the space between the two arguments.\r\n  debugFunc()(msg || 'Exception caught in template:', e.stack || e.message);\r\n};\r\n\r\nBlaze.wrapCatchingExceptions = function (f, where) {\r\n  if (typeof f !== 'function')\r\n    return f;\r\n\r\n  return function () {\r\n    try {\r\n      return f.apply(this, arguments);\r\n    } catch (e) {\r\n      Blaze.reportException(e, 'Exception in ' + where + ':');\r\n    }\r\n  };\r\n};\r\n","/**\r\n * ## [new] Blaze.ReactiveVar(initialValue, [equalsFunc])\r\n *\r\n * A ReactiveVar holds a single value that can be get and set,\r\n * such that calling `set` will invalidate any Computations that\r\n * called `get`, according to the usual contract for reactive\r\n * data sources.\r\n *\r\n * A ReactiveVar is much like a Session variable -- compare `foo.get()`\r\n * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\r\n * automatically migrated across hot code pushes.  Also, while Session\r\n * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\r\n *\r\n * An important property of ReactiveVars, which is sometimes the reason\r\n * to use one, is that setting the value to the same value as before has\r\n * no effect, meaning ReactiveVars can be used to absorb extra\r\n * invalidations that wouldn't serve a purpose.  However, by default,\r\n * ReactiveVars are extremely conservative about what changes they\r\n * absorb.  Calling `set` with an object argument will *always* trigger\r\n * invalidations, because even if the new value is `===` the old value,\r\n * the object may have been mutated.  You can change the default behavior\r\n * by passing a function of two arguments, `oldValue` and `newValue`,\r\n * to the constructor as `equalsFunc`.\r\n *\r\n * This class is extremely basic right now, but the idea is to evolve\r\n * it into the ReactiveVar of Geoff's Lickable Forms proposal.\r\n */\r\n\r\nBlaze.ReactiveVar = function (initialValue, equalsFunc) {\r\n  if (! (this instanceof Blaze.ReactiveVar))\r\n    // called without `new`\r\n    return new Blaze.ReactiveVar(initialValue, equalsFunc);\r\n\r\n  this.curValue = initialValue;\r\n  this.equalsFunc = equalsFunc;\r\n  this.dep = new Deps.Dependency;\r\n};\r\n\r\nBlaze.ReactiveVar._isEqual = function (oldValue, newValue) {\r\n  var a = oldValue, b = newValue;\r\n  // Two values are \"equal\" here if they are `===` and are\r\n  // number, boolean, string, undefined, or null.\r\n  if (a !== b)\r\n    return false;\r\n  else\r\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\r\n            (typeof a === 'string'));\r\n};\r\n\r\nBlaze.ReactiveVar.prototype.get = function () {\r\n  if (Deps.active)\r\n    this.dep.depend();\r\n\r\n  return this.curValue;\r\n};\r\n\r\nBlaze.ReactiveVar.prototype.set = function (newValue) {\r\n  var oldValue = this.curValue;\r\n\r\n  if ((this.equalsFunc || Blaze.ReactiveVar._isEqual)(oldValue, newValue))\r\n    // value is same as last time\r\n    return;\r\n\r\n  this.curValue = newValue;\r\n  this.dep.changed();\r\n};\r\n\r\nBlaze.ReactiveVar.prototype.toString = function () {\r\n  return 'ReactiveVar{' + this.get() + '}';\r\n};\r\n","/// [new] Blaze.View([kind], renderMethod)\r\n///\r\n/// Blaze.View is the building block of reactive DOM.  Views have\r\n/// the following features:\r\n///\r\n/// * lifecycle callbacks - Views are created, rendered, and destroyed,\r\n///   and callbacks can be registered to fire when these things happen.\r\n///\r\n/// * parent pointer - A View points to its parentView, which is the\r\n///   View that caused it to be rendered.  These pointers form a\r\n///   hierarchy or tree of Views.\r\n///\r\n/// * render() method - A View's render() method specifies the DOM\r\n///   (or HTML) content of the View.  If the method establishes\r\n///   reactive dependencies, it may be re-run.\r\n///\r\n/// * a DOMRange - If a View is rendered to DOM, its position and\r\n///   extent in the DOM are tracked using a DOMRange object.\r\n///\r\n/// When a View is constructed by calling Blaze.View, the View is\r\n/// not yet considered \"created.\"  It doesn't have a parentView yet,\r\n/// and no logic has been run to initialize the View.  All real\r\n/// work is deferred until at least creation time, when the onCreated\r\n/// callbacks are fired, which happens when the View is \"used\" in\r\n/// some way that requires it to be rendered.\r\n///\r\n/// ...more lifecycle stuff\r\n///\r\n/// `kind` is an optional string tag identifying the View.  The only\r\n/// time it's used is when looking in the View tree for a View of a\r\n/// particular kind; for example, data contexts are stored on Views\r\n/// of kind \"with\".  Kinds are also useful when debugging, so in\r\n/// general it's good for functions that create Views to set the kind.\r\n/// Templates have kinds of the form \"Template.foo\".\r\nBlaze.View = function (kind, render) {\r\n  if (! (this instanceof Blaze.View))\r\n    // called without `new`\r\n    return new Blaze.View(kind, render);\r\n\r\n  if (typeof kind === 'function') {\r\n    // omitted \"kind\" argument\r\n    render = kind;\r\n    kind = '';\r\n  }\r\n  this.kind = kind;\r\n  this.render = render;\r\n\r\n  this._callbacks = {\r\n    created: null,\r\n    materialized: null,\r\n    rendered: null,\r\n    destroyed: null\r\n  };\r\n\r\n  // Setting all properties here is good for readability,\r\n  // and also may help Chrome optimize the code by keeping\r\n  // the View object from changing shape too much.\r\n  this.isCreated = false;\r\n  this.isCreatedForExpansion = false;\r\n  this.isDestroyed = false;\r\n  this.isInRender = false;\r\n  this.parentView = null;\r\n  this.domrange = null;\r\n\r\n  this.renderCount = 0;\r\n};\r\n\r\nBlaze.View.prototype.render = function () { return null; };\r\n\r\nBlaze.View.prototype.onCreated = function (cb) {\r\n  this._callbacks.created = this._callbacks.created || [];\r\n  this._callbacks.created.push(cb);\r\n};\r\nBlaze.View.prototype.onMaterialized = function (cb) {\r\n  this._callbacks.materialized = this._callbacks.materialized || [];\r\n  this._callbacks.materialized.push(cb);\r\n};\r\nBlaze.View.prototype.onRendered = function (cb) {\r\n  this._callbacks.rendered = this._callbacks.rendered || [];\r\n  this._callbacks.rendered.push(cb);\r\n};\r\nBlaze.View.prototype.onDestroyed = function (cb) {\r\n  this._callbacks.destroyed = this._callbacks.destroyed || [];\r\n  this._callbacks.destroyed.push(cb);\r\n};\r\n\r\n/// View#autorun(func)\r\n///\r\n/// Sets up a Deps autorun that is \"scoped\" to this View in two\r\n/// important ways: 1) Blaze.currentView is automatically set\r\n/// on every re-run, and 2) the autorun is stopped when the\r\n/// View is destroyed.  As with Deps.autorun, the first run of\r\n/// the function is immediate, and a Computation object that can\r\n/// be used to stop the autorun is returned.\r\n///\r\n/// View#autorun is meant to be called from View callbacks like\r\n/// onCreated, or from outside the rendering process.  It may not\r\n/// be called before the onCreated callbacks are fired (too early),\r\n/// or from a render() method (too confusing).\r\n///\r\n/// Typically, autoruns that update the state\r\n/// of the View (as in Blaze.With) should be started from an onCreated\r\n/// callback.  Autoruns that update the DOM should be started\r\n/// from either onCreated (guarded against the absence of\r\n/// view.domrange), onMaterialized, or onRendered.\r\nBlaze.View.prototype.autorun = function (f, _inViewScope) {\r\n  var self = this;\r\n\r\n  // The restrictions on when View#autorun can be called are in order\r\n  // to avoid bad patterns, like creating a Blaze.View and immediately\r\n  // calling autorun on it.  A freshly created View is not ready to\r\n  // have logic run on it; it doesn't have a parentView, for example.\r\n  // It's when the View is materialized or expanded that the onCreated\r\n  // handlers are fired and the View starts up.\r\n  //\r\n  // Letting the render() method call `this.autorun()` is problematic\r\n  // because of re-render.  The best we can do is to stop the old\r\n  // autorun and start a new one for each render, but that's a pattern\r\n  // we try to avoid internally because it leads to helpers being\r\n  // called extra times, in the case where the autorun causes the\r\n  // view to re-render (and thus the autorun to be torn down and a\r\n  // new one established).\r\n  //\r\n  // We could lift these restrictions in various ways.  One interesting\r\n  // idea is to allow you to call `view.autorun` after instantiating\r\n  // `view`, and automatically wrap it in `view.onCreated`, deferring\r\n  // the autorun so that it starts at an appropriate time.  However,\r\n  // then we can't return the Computation object to the caller, because\r\n  // it doesn't exist yet.\r\n  if (! self.isCreated) {\r\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");\r\n  }\r\n  if (this.isInRender) {\r\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\r\n  }\r\n  if (Deps.active) {\r\n    throw new Error(\"Can't call View#autorun from a Deps Computation; try calling it from the created or rendered callback\");\r\n  }\r\n\r\n  var c = Deps.autorun(function viewAutorun(c) {\r\n    return Blaze.withCurrentView(_inViewScope || self, function () {\r\n      return f.call(self, c);\r\n    });\r\n  });\r\n  self.onDestroyed(function () { c.stop(); });\r\n\r\n  return c;\r\n};\r\n\r\nBlaze._fireCallbacks = function (view, which) {\r\n  Blaze.withCurrentView(view, function () {\r\n    Deps.nonreactive(function fireCallbacks() {\r\n      var cbs = view._callbacks[which];\r\n      for (var i = 0, N = (cbs && cbs.length); i < N; i++)\r\n        cbs[i].call(view);\r\n    });\r\n  });\r\n};\r\n\r\nBlaze.materializeView = function (view, parentView) {\r\n  view.parentView = (parentView || null);\r\n\r\n  if (view.isCreated)\r\n    throw new Error(\"Can't render the same View twice\");\r\n  view.isCreated = true;\r\n\r\n  Blaze._fireCallbacks(view, 'created');\r\n\r\n  var domrange;\r\n\r\n  var needsRenderedCallback = false;\r\n  var scheduleRenderedCallback = function () {\r\n    if (needsRenderedCallback && ! view.isDestroyed &&\r\n        view._callbacks.rendered && view._callbacks.rendered.length) {\r\n      Deps.afterFlush(function callRendered() {\r\n        if (needsRenderedCallback && ! view.isDestroyed) {\r\n          needsRenderedCallback = false;\r\n          Blaze._fireCallbacks(view, 'rendered');\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  var lastHtmljs;\r\n  // We don't expect to be called in a Computation, but just in case,\r\n  // wrap in Deps.nonreactive.\r\n  Deps.nonreactive(function () {\r\n    view.autorun(function doRender(c) {\r\n      // `view.autorun` sets the current view.\r\n      // Any dependencies that should invalidate this Computation come\r\n      // from this line:\r\n      view.renderCount++;\r\n      view.isInRender = true;\r\n      var htmljs = view.render();\r\n      view.isInRender = false;\r\n\r\n      Deps.nonreactive(function doMaterialize() {\r\n        var materializer = new Blaze.DOMMaterializer({parentView: view});\r\n        var rangesAndNodes = materializer.visit(htmljs, []);\r\n        if (c.firstRun || ! Blaze._isContentEqual(lastHtmljs, htmljs)) {\r\n          if (c.firstRun) {\r\n            domrange = new Blaze.DOMRange(rangesAndNodes);\r\n            view.domrange = domrange;\r\n            domrange.view = view;\r\n          } else {\r\n            domrange.setMembers(rangesAndNodes);\r\n          }\r\n          Blaze._fireCallbacks(view, 'materialized');\r\n          needsRenderedCallback = true;\r\n          if (! c.firstRun)\r\n            scheduleRenderedCallback();\r\n        }\r\n      });\r\n      lastHtmljs = htmljs;\r\n\r\n      // Causes any nested views to stop immediately, not when we call\r\n      // `setMembers` the next time around the autorun.  Otherwise,\r\n      // helpers in the DOM tree to be replaced might be scheduled\r\n      // to re-run before we have a chance to stop them.\r\n      Deps.onInvalidate(function () {\r\n        domrange.destroyMembers();\r\n      });\r\n    });\r\n\r\n    var teardownHook = null;\r\n\r\n    domrange.onAttached(function attached(range, element) {\r\n      teardownHook = Blaze.DOMBackend.Teardown.onElementTeardown(\r\n        element, function teardown() {\r\n          Blaze.destroyView(view, true /* _skipNodes */);\r\n        });\r\n\r\n      scheduleRenderedCallback();\r\n    });\r\n\r\n    // tear down the teardown hook\r\n    view.onDestroyed(function () {\r\n      teardownHook && teardownHook.stop();\r\n      teardownHook = null;\r\n    });\r\n  });\r\n\r\n  return domrange;\r\n};\r\n\r\n// Expands a View to HTMLjs, calling `render` recursively on all\r\n// Views and evaluating any dynamic attributes.  Calls the `created`\r\n// callback, but not the `materialized` or `rendered` callbacks.\r\n// Destroys the view immediately, unless called in a Deps Computation,\r\n// in which case the view will be destroyed when the Computation is\r\n// invalidated.  If called in a Deps Computation, the result is a\r\n// reactive string; that is, the Computation will be invalidated\r\n// if any changes are made to the view or subviews that might affect\r\n// the HTML.\r\nBlaze._expandView = function (view, parentView) {\r\n  view.parentView = (parentView || null);\r\n\r\n  if (view.isCreated)\r\n    throw new Error(\"Can't render the same View twice\");\r\n  view.isCreated = true;\r\n  view.isCreatedForExpansion = true;\r\n\r\n  Blaze._fireCallbacks(view, 'created');\r\n\r\n  view.isInRender = true;\r\n  var htmljs = Blaze.withCurrentView(view, function () {\r\n    return view.render();\r\n  });\r\n  view.isInRender = false;\r\n\r\n  var result = Blaze._expand(htmljs, view);\r\n\r\n  if (Deps.active) {\r\n    Deps.onInvalidate(function () {\r\n      Blaze.destroyView(view);\r\n    });\r\n  } else {\r\n    Blaze.destroyView(view);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// Options: `parentView`\r\nBlaze.HTMLJSExpander = HTML.TransformingVisitor.extend();\r\nBlaze.HTMLJSExpander.def({\r\n  visitObject: function (x) {\r\n    if (Blaze.isTemplate(x))\r\n      x = Blaze.runTemplate(x);\r\n    if (x instanceof Blaze.View)\r\n      return Blaze._expandView(x, this.parentView);\r\n\r\n    // this will throw an error; other objects are not allowed!\r\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\r\n  },\r\n  visitAttributes: function (attrs) {\r\n    // expand dynamic attributes\r\n    if (typeof attrs === 'function')\r\n      attrs = Blaze.withCurrentView(this.parentView, attrs);\r\n\r\n    // call super (e.g. for case where `attrs` is an array)\r\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\r\n  },\r\n  visitAttribute: function (name, value, tag) {\r\n    // expand attribute values that are functions.  Any attribute value\r\n    // that contains Views must be wrapped in a function.\r\n    if (typeof value === 'function')\r\n      value = Blaze.withCurrentView(this.parentView, value);\r\n\r\n    return HTML.TransformingVisitor.prototype.visitAttribute.call(\r\n      this, name, value, tag);\r\n  }\r\n});\r\n\r\n// Return Blaze.currentView, but only if it is being rendered\r\n// (i.e. we are in its render() method).\r\nvar currentViewIfRendering = function () {\r\n  var view = Blaze.currentView;\r\n  return (view && view.isInRender) ? view : null;\r\n};\r\n\r\nBlaze._expand = function (htmljs, parentView) {\r\n  parentView = parentView || currentViewIfRendering();\r\n  return (new Blaze.HTMLJSExpander(\r\n    {parentView: parentView})).visit(htmljs);\r\n};\r\n\r\nBlaze._expandAttributes = function (attrs, parentView) {\r\n  parentView = parentView || currentViewIfRendering();\r\n  return (new Blaze.HTMLJSExpander(\r\n    {parentView: parentView})).visitAttributes(attrs);\r\n};\r\n\r\nBlaze.destroyView = function (view, _skipNodes) {\r\n  if (view.isDestroyed)\r\n    return;\r\n  view.isDestroyed = true;\r\n\r\n  Blaze._fireCallbacks(view, 'destroyed');\r\n\r\n  // Destroy views and elements recursively.  If _skipNodes,\r\n  // only recurse up to views, not elements, for the case where\r\n  // the backend (jQuery) is recursing over the elements already.\r\n\r\n  if (view.domrange)\r\n    view.domrange.destroyMembers();\r\n};\r\n\r\nBlaze.destroyNode = function (node) {\r\n  if (node.nodeType === 1)\r\n    Blaze.DOMBackend.Teardown.tearDownElement(node);\r\n};\r\n\r\n// Are the HTMLjs entities `a` and `b` the same?  We could be\r\n// more elaborate here but the point is to catch the most basic\r\n// cases.\r\nBlaze._isContentEqual = function (a, b) {\r\n  if (a instanceof HTML.Raw) {\r\n    return (b instanceof HTML.Raw) && (a.value === b.value);\r\n  } else if (a == null) {\r\n    return (b == null);\r\n  } else {\r\n    return (a === b) &&\r\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\r\n       (typeof a === 'string'));\r\n  }\r\n};\r\n\r\nBlaze.currentView = null;\r\n\r\nBlaze.withCurrentView = function (view, func) {\r\n  var oldView = Blaze.currentView;\r\n  try {\r\n    Blaze.currentView = view;\r\n    return func();\r\n  } finally {\r\n    Blaze.currentView = oldView;\r\n  }\r\n};\r\n\r\nBlaze.isTemplate = function (t) {\r\n  return t && (typeof t.__makeView === 'function');\r\n};\r\n\r\nBlaze.runTemplate = function (t/*, args*/) {\r\n  if (! Blaze.isTemplate(t))\r\n    throw new Error(\"Not a template: \" + t);\r\n  var restArgs = Array.prototype.slice.call(arguments, 1);\r\n  return t.__makeView.apply(t, restArgs);\r\n};\r\n\r\nBlaze.render = function (content, parentView) {\r\n  parentView = parentView || currentViewIfRendering();\r\n\r\n  var view;\r\n  if (typeof content === 'function') {\r\n    view = Blaze.View('render', content);\r\n  } else if (Blaze.isTemplate(content)) {\r\n    view = Blaze.runTemplate(content);\r\n  } else {\r\n    if (! (content instanceof Blaze.View))\r\n      throw new Error(\"Expected a function, template, or View in Blaze.render\");\r\n    view = content;\r\n  }\r\n  return Blaze.materializeView(view, parentView);\r\n};\r\n\r\nBlaze.toHTML = function (htmljs, parentView) {\r\n  if (typeof htmljs === 'function')\r\n    throw new Error(\"Blaze.toHTML doesn't take a function, just HTMLjs\");\r\n  parentView = parentView || currentViewIfRendering();\r\n  return HTML.toHTML(Blaze._expand(htmljs, parentView));\r\n};\r\n\r\nBlaze.toText = function (htmljs, parentView, textMode) {\r\n  if (typeof htmljs === 'function')\r\n    throw new Error(\"Blaze.toText doesn't take a function, just HTMLjs\");\r\n\r\n  if ((parentView != null) && ! (parentView instanceof Blaze.View)) {\r\n    // omitted parentView argument\r\n    textMode = parentView;\r\n    parentView = null;\r\n  }\r\n  parentView = parentView || currentViewIfRendering();\r\n\r\n  if (! textMode)\r\n    throw new Error(\"textMode required\");\r\n  if (! (textMode === HTML.TEXTMODE.STRING ||\r\n         textMode === HTML.TEXTMODE.RCDATA ||\r\n         textMode === HTML.TEXTMODE.ATTRIBUTE))\r\n    throw new Error(\"Unknown textMode: \" + textMode);\r\n\r\n  return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\r\n};\r\n\r\nBlaze.getCurrentData = function () {\r\n  var theWith = Blaze.getCurrentView('with');\r\n  return theWith ? theWith.dataVar.get() : null;\r\n};\r\n\r\n// Gets the current view or its nearest ancestor of kind\r\n// `kind`.\r\nBlaze.getCurrentView = function (kind) {\r\n  var view = Blaze.currentView;\r\n  // Better to fail in cases where it doesn't make sense\r\n  // to use Blaze.getCurrentView().  There will be a current\r\n  // view anywhere it does.  You can check Blaze.currentView\r\n  // if you want to know whether there is one or not.\r\n  if (! view)\r\n    throw new Error(\"There is no current view\");\r\n\r\n  if (kind) {\r\n    while (view && view.kind !== kind)\r\n      view = view.parentView;\r\n    return view || null;\r\n  } else {\r\n    // Blaze.getCurrentView() with no arguments just returns\r\n    // Blaze.currentView.\r\n    return view;\r\n  }\r\n};\r\n\r\n// Gets the nearest ancestor view that corresponds to a template\r\nBlaze.getCurrentTemplateView = function () {\r\n  var view = Blaze.getCurrentView();\r\n\r\n  while (view && ! view.template)\r\n    view = view.parentView;\r\n\r\n  return view || null;\r\n};\r\n\r\nBlaze.getParentView = function (view, kind) {\r\n  var v = view.parentView;\r\n\r\n  if (kind) {\r\n    while (v && v.kind !== kind)\r\n      v = v.parentView;\r\n  }\r\n\r\n  return v || null;\r\n};\r\n\r\nBlaze.getElementView = function (elem, kind) {\r\n  var range = Blaze.DOMRange.forElement(elem);\r\n  var view = null;\r\n  while (range && ! view) {\r\n    view = (range.view || null);\r\n    if (! view) {\r\n      if (range.parentRange)\r\n        range = range.parentRange;\r\n      else\r\n        range = Blaze.DOMRange.forElement(range.parentElement);\r\n    }\r\n  }\r\n\r\n  if (kind) {\r\n    while (view && view.kind !== kind)\r\n      view = view.parentView;\r\n    return view || null;\r\n  } else {\r\n    return view;\r\n  }\r\n};\r\n\r\nBlaze.getElementData = function (elem) {\r\n  var theWith = Blaze.getElementView(elem, 'with');\r\n  return theWith ? theWith.dataVar.get() : null;\r\n};\r\n\r\nBlaze.getViewData = function (view) {\r\n  var theWith = Blaze.getParentView(view, 'with');\r\n  return theWith ? theWith.dataVar.get() : null;\r\n};\r\n\r\nBlaze._addEventMap = function (view, eventMap, thisInHandler) {\r\n  thisInHandler = (thisInHandler || null);\r\n  var handles = [];\r\n\r\n  if (! view.domrange)\r\n    throw new Error(\"View must have a DOMRange\");\r\n\r\n  view.domrange.onAttached(function attached_eventMaps(range, element) {\r\n    _.each(eventMap, function (handler, spec) {\r\n      var clauses = spec.split(/,\\s+/);\r\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\r\n      _.each(clauses, function (clause) {\r\n        var parts = clause.split(/\\s+/);\r\n        if (parts.length === 0)\r\n          return;\r\n\r\n        var newEvents = parts.shift();\r\n        var selector = parts.join(' ');\r\n        handles.push(Blaze.EventSupport.listen(\r\n          element, newEvents, selector,\r\n          function (evt) {\r\n            if (! range.containsElement(evt.currentTarget))\r\n              return null;\r\n            var handlerThis = thisInHandler || this;\r\n            var handlerArgs = arguments;\r\n            return Blaze.withCurrentView(view, function () {\r\n              return handler.apply(handlerThis, handlerArgs);\r\n            });\r\n          },\r\n          range, function (r) {\r\n            return r.parentRange;\r\n          }));\r\n      });\r\n    });\r\n  });\r\n\r\n  view.onDestroyed(function () {\r\n    _.each(handles, function (h) {\r\n      h.stop();\r\n    });\r\n    handles.length = 0;\r\n  });\r\n};\r\n","Blaze._calculateCondition = function (cond) {\r\n  if (cond instanceof Array && cond.length === 0)\r\n    cond = false;\r\n  return !! cond;\r\n};\r\n\r\nBlaze.With = function (data, contentFunc) {\r\n  var view = Blaze.View('with', contentFunc);\r\n\r\n  view.dataVar = new Blaze.ReactiveVar;\r\n\r\n  view.onCreated(function () {\r\n    if (typeof data === 'function') {\r\n      // `data` is a reactive function\r\n      view.autorun(function () {\r\n        view.dataVar.set(data());\r\n      }, view.parentView);\r\n    } else {\r\n      view.dataVar.set(data);\r\n    }\r\n  });\r\n\r\n  return view;\r\n};\r\n\r\nBlaze.If = function (conditionFunc, contentFunc, elseFunc, _not) {\r\n  var conditionVar = new Blaze.ReactiveVar;\r\n\r\n  var view = Blaze.View(_not ? 'unless' : 'if', function () {\r\n    return conditionVar.get() ? contentFunc() :\r\n      (elseFunc ? elseFunc() : null);\r\n  });\r\n  view.__conditionVar = conditionVar;\r\n  view.onCreated(function () {\r\n    this.autorun(function () {\r\n      var cond = Blaze._calculateCondition(conditionFunc());\r\n      conditionVar.set(_not ? (! cond) : cond);\r\n    }, this.parentView);\r\n  });\r\n\r\n  return view;\r\n};\r\n\r\nBlaze.Unless = function (conditionFunc, contentFunc, elseFunc) {\r\n  return Blaze.If(conditionFunc, contentFunc, elseFunc, true /*_not*/);\r\n};\r\n\r\nBlaze.Each = function (argFunc, contentFunc, elseFunc) {\r\n  var eachView = Blaze.View('each', function () {\r\n    var subviews = this.initialSubviews;\r\n    this.initialSubviews = null;\r\n    if (this.isCreatedForExpansion) {\r\n      this.expandedValueDep = new Deps.Dependency;\r\n      this.expandedValueDep.depend();\r\n    }\r\n    return subviews;\r\n  });\r\n  eachView.initialSubviews = [];\r\n  eachView.numItems = 0;\r\n  eachView.inElseMode = false;\r\n  eachView.stopHandle = null;\r\n  eachView.contentFunc = contentFunc;\r\n  eachView.elseFunc = elseFunc;\r\n  eachView.argVar = new Blaze.ReactiveVar;\r\n\r\n  eachView.onCreated(function () {\r\n    // We evaluate argFunc in an autorun to make sure\r\n    // Blaze.currentView is always set when it runs (rather than\r\n    // passing argFunc straight to ObserveSequence).\r\n    eachView.autorun(function () {\r\n      eachView.argVar.set(argFunc());\r\n    }, eachView.parentView);\r\n\r\n    eachView.stopHandle = ObserveSequence.observe(function () {\r\n      return eachView.argVar.get();\r\n    }, {\r\n      addedAt: function (id, item, index) {\r\n        Deps.nonreactive(function () {\r\n          var newItemView = Blaze.With(item, eachView.contentFunc);\r\n          eachView.numItems++;\r\n\r\n          if (eachView.expandedValueDep) {\r\n            eachView.expandedValueDep.changed();\r\n          } else if (eachView.domrange) {\r\n            if (eachView.inElseMode) {\r\n              eachView.domrange.removeMember(0);\r\n              eachView.inElseMode = false;\r\n            }\r\n\r\n            var range = Blaze.materializeView(newItemView, eachView);\r\n            eachView.domrange.addMember(range, index);\r\n          } else {\r\n            eachView.initialSubviews.splice(index, 0, newItemView);\r\n          }\r\n        });\r\n      },\r\n      removedAt: function (id, item, index) {\r\n        Deps.nonreactive(function () {\r\n          eachView.numItems--;\r\n          if (eachView.expandedValueDep) {\r\n            eachView.expandedValueDep.changed();\r\n          } else if (eachView.domrange) {\r\n            eachView.domrange.removeMember(index);\r\n            if (eachView.elseFunc && eachView.numItems === 0) {\r\n              eachView.inElseMode = true;\r\n              eachView.domrange.addMember(\r\n                Blaze.materializeView(\r\n                  Blaze.View('each_else',eachView.elseFunc),\r\n                  eachView), 0);\r\n            }\r\n          } else {\r\n            eachView.initialSubviews.splice(index, 1);\r\n          }\r\n        });\r\n      },\r\n      changedAt: function (id, newItem, oldItem, index) {\r\n        Deps.nonreactive(function () {\r\n          var itemView;\r\n          if (eachView.expandedValueDep) {\r\n            eachView.expandedValueDep.changed();\r\n          } else if (eachView.domrange) {\r\n            itemView = eachView.domrange.getMember(index).view;\r\n          } else {\r\n            itemView = eachView.initialSubviews[index];\r\n          }\r\n          itemView.dataVar.set(newItem);\r\n        });\r\n      },\r\n      movedTo: function (id, item, fromIndex, toIndex) {\r\n        Deps.nonreactive(function () {\r\n          if (eachView.expandedValueDep) {\r\n            eachView.expandedValueDep.changed();\r\n          } else if (eachView.domrange) {\r\n            eachView.domrange.moveMember(fromIndex, toIndex);\r\n          } else {\r\n            var subviews = eachView.initialSubviews;\r\n            var itemView = subviews[fromIndex];\r\n            subviews.splice(fromIndex, 1);\r\n            subviews.splice(toIndex, 0, itemView);\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    if (eachView.elseFunc && eachView.numItems === 0) {\r\n      eachView.inElseMode = true;\r\n      eachView.initialSubviews[0] =\r\n        Blaze.View('each_else', eachView.elseFunc);\r\n    }\r\n  });\r\n\r\n  eachView.onDestroyed(function () {\r\n    if (eachView.stopHandle)\r\n      eachView.stopHandle.stop();\r\n  });\r\n\r\n  return eachView;\r\n};\r\n\r\nBlaze.InOuterTemplateScope = function (templateView, contentFunc) {\r\n  var view = Blaze.View('InOuterTemplateScope', contentFunc);\r\n  var parentView = templateView.parentView;\r\n\r\n  // Hack so that if you call `{{> foo bar}}` and it expands into\r\n  // `{{#with bar}}{{> foo}}{{/with}}`, and then `foo` is a template\r\n  // that inserts `{{> UI.contentBlock}}`, the data context for\r\n  // `UI.contentBlock` is not `bar` but the one enclosing that.\r\n  if (parentView.__isTemplateWith)\r\n    parentView = parentView.parentView;\r\n\r\n  view.onCreated(function () {\r\n    this.originalParentView = this.parentView;\r\n    this.parentView = parentView;\r\n  });\r\n  return view;\r\n};\r\n","var bindIfIsFunction = function (x, target) {\r\n  if (typeof x !== 'function')\r\n    return x;\r\n  return function () {\r\n    return x.apply(target, arguments);\r\n  };\r\n};\r\n\r\nvar bindToCurrentDataIfIsFunction = function (x) {\r\n  if (typeof x === 'function') {\r\n    return function () {\r\n      var data = Blaze.getCurrentData();\r\n      if (data == null)\r\n        data = {};\r\n      return x.apply(data, arguments);\r\n    };\r\n  }\r\n  return x;\r\n};\r\n\r\nvar wrapHelper = function (f) {\r\n  return Blaze.wrapCatchingExceptions(f, 'template helper');\r\n};\r\n\r\n// Implements {{foo}} where `name` is \"foo\"\r\n// and `component` is the component the tag is found in\r\n// (the lexical \"self,\" on which to look for methods).\r\n// If a function is found, it is bound to the object it\r\n// was found on.  Returns a function,\r\n// non-function value, or null.\r\n//\r\n// NOTE: This function must not establish any reactive\r\n// dependencies.  If there is any reactivity in the\r\n// value, lookup should return a function.\r\nBlaze.View.prototype.lookup = function (name, _options) {\r\n  var template = this.template;\r\n  var lookupTemplate = _options && _options.template;\r\n\r\n  if (/^\\./.test(name)) {\r\n    // starts with a dot. must be a series of dots which maps to an\r\n    // ancestor of the appropriate height.\r\n    if (!/^(\\.)+$/.test(name))\r\n      throw new Error(\"id starting with dot must be a series of dots\");\r\n\r\n    return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\r\n\r\n  } else if (template && (name in template)) {\r\n    return wrapHelper(bindToCurrentDataIfIsFunction(template[name]));\r\n  } else if (lookupTemplate && Template.__lookup__(name)) {\r\n    return Template.__lookup__(name);\r\n  } else if (UI._globalHelpers[name]) {\r\n    return wrapHelper(bindToCurrentDataIfIsFunction(UI._globalHelpers[name]));\r\n  } else {\r\n    return function () {\r\n      var isCalledAsFunction = (arguments.length > 0);\r\n      var data = Blaze.getCurrentData();\r\n      if (lookupTemplate && ! (data && data[name])) {\r\n        throw new Error(\"No such template: \" + name);\r\n      }\r\n      if (isCalledAsFunction && ! (data && data[name])) {\r\n        throw new Error(\"No such function: \" + name);\r\n      }\r\n      if (! data)\r\n        return null;\r\n      var x = data[name];\r\n      if (typeof x !== 'function') {\r\n        if (isCalledAsFunction) {\r\n          throw new Error(\"Can't call non-function: \" + x);\r\n        }\r\n        return x;\r\n      }\r\n      return x.apply(data, arguments);\r\n    };\r\n  }\r\n  return null;\r\n};\r\n\r\n// Implement Spacebars' {{../..}}.\r\n// @param height {Number} The number of '..'s\r\nBlaze._parentData = function (height, _functionWrapped) {\r\n  var theWith = Blaze.getCurrentView('with');\r\n  for (var i = 0; (i < height) && theWith; i++) {\r\n    theWith = Blaze.getParentView(theWith, 'with');\r\n  }\r\n\r\n  if (! theWith)\r\n    return null;\r\n  if (_functionWrapped)\r\n    return function () { return theWith.dataVar.get(); };\r\n  return theWith.dataVar.get();\r\n};\r\n\r\n\r\nBlaze.View.prototype.lookupTemplate = function (name) {\r\n  return this.lookup(name, {template:true});\r\n};\r\n"]}