)]}'
{"version":3,"file":"\\packages\\templating.js","sources":["templating/templating.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,sE;AACA,kB;AACA,c;;AAEA,yE;AACA,iE;AACA,qD;AACA,mC;AACA,2D;AACA,+B;AACA,4C;AACA,K;;AAEA,8C;AACA,qB;AACA,sB;AACA,E;;AAEA,qD;AACA,+D;AACA,e;AACA,oC;AACA,e;AACA,qC;AACA,8B;AACA,4B;AACA,kE;AACA,yC;AACA,Q;AACA,oC;AACA,4D;AACA,Q;AACA,iC;AACA,sC;AACA,iC;AACA,Q;AACA,iB;AACA,sB;AACA,qB;AACA,6B;AACA,+B;AACA,Q;AACA,oB;AACA,M;AACA,G;;AAEA,sC;;AAEA,2C;AACA,+C;AACA,6C;AACA,U;AACA,qE;AACA,0B;AACA,yB;AACA,G;;AAEA,c;AACA,E;;AAEA,oC;AACA,oD;AACA,qB;AACA,2C;;AAEA,yD;AACA,E;;AAEA,iD;AACA,sB;AACA,sD;AACA,qB;AACA,2B;AACA,qC;AACA,wC;AACA,oD;AACA,6D;AACA,yB;AACA,oB;AACA,yD;AACA,mE;AACA,wC;AACA,mC;AACA,Q;AACA,uB;AACA,G;;AAEA,uC;AACA,E;;AAEA,kE;AACA,sB;AACA,wD;AACA,2B;;AAEA,+B;AACA,6E;AACA,4B;AACA,oE;;AAEA,6B;AACA,4C;AACA,qC;AACA,mC;AACA,gD;AACA,oE;AACA,yE;AACA,mE;AACA,kE;AACA,sE;AACA,mD;AACA,kE;AACA,O;;AAEA,iD;AACA,0C;AACA,S;AACA,O;AACA,G;;AAEA,0B;AACA,8B;;AAEA,yB;AACA,gC;AACA,yD;AACA,kC;AACA,O;AACA,G;;AAEA,0B;AACA,iC;AACA,yD;AACA,mC;AACA,O;AACA,G;;AAEA,2B;AACA,kC;AACA,yD;AACA,oC;AACA,O;AACA,G;;AAEA,c;AACA,E;;AAEA,sD;;AAEA,+C;AACA,qD;AACA,gB;AACA,oC;AACA,oC;AACA,gB;AACA,c;AACA,E;;AAEA,mE;AACA,gD;AACA,6B;AACA,+B;AACA,e;AACA,+B;;AAEA,c;AACA,E;;AAEA,6D;AACA,qD;AACA,0C;AACA,uH;AACA,uE;AACA,G;;AAEA,2E;AACA,qC;;AAEA,gC;AACA,c;AACA,E;;AAEA,wC;AACA,2B;AACA,E;;AAEA,yD;AACA,oB;AACA,6C;AACA,+C;AACA,6C;AACA,wC;AACA,0C;AACA,e;AACA,G;AACA,8D;;AAEA,gE;AACA,iE;AACA,+D;AACA,0C;AACA,qD;AACA,2C;AACA,mC;AACA,yC;AACA,W;AACA,4C;AACA,8C;AACA,wC;AACA,8B;AACA,E;AACA,kD;;;AAGA,oE;AACA,uC;AACA,6B;AACA,sC;AACA,8C;;AAEA,4B;AACA,E;;AAEA,qD;AACA,2C;AACA,sC;AACA,8C;AACA,iC;AACA,2E;;AAEA,oD;AACA,gB;AACA,M;AACA,E;;AAEA,qE;AACA,sE;AACA,qE;AACA,sB;AACA,uD;AACA,kE;AACA,sE;AACA,4C;AACA,oE;AACA,0D;AACA,kF;AACA,qD;AACA,wC;AACA,iE;;AAEA,wC;AACA,E;;AAEA,wB;AACA,8B;AACA,wC;AACA,iE;;AAEA,qB;AACA,mB;AACA,kB;AACA,E;;AAEA,4B","sourcesContent":["// Create an empty template object. Packages and apps add templates on\r\n// to this object.\r\nTemplate = {};\r\n\r\n// `Template` is not a function so this is not a real function prototype,\r\n// but it is used as the prototype of all `Template.foo` objects.\r\n// Naming a template \"prototype\" will cause an error.\r\nTemplate.prototype = (function () {\r\n  // IE 8 exposes function names in the enclosing scope, so\r\n  // use this IIFE to catch it.\r\n  return (function Template() {}).prototype;\r\n})();\r\n\r\nTemplate.prototype.helpers = function (dict) {\r\n  for (var k in dict)\r\n    this[k] = dict[k];\r\n};\r\n\r\nTemplate.__updateTemplateInstance = function (view) {\r\n  // Populate `view.templateInstance.{firstNode,lastNode,data}`\r\n  // on demand.\r\n  var tmpl = view._templateInstance;\r\n  if (! tmpl) {\r\n    tmpl = view._templateInstance = {\r\n      $: function (selector) {\r\n        if (! view.domrange)\r\n          throw new Error(\"Can't use $ on component with no DOM\");\r\n        return view.domrange.$(selector);\r\n      },\r\n      findAll: function (selector) {\r\n        return Array.prototype.slice.call(this.$(selector));\r\n      },\r\n      find: function (selector) {\r\n        var result = this.$(selector);\r\n        return result[0] || null;\r\n      },\r\n      data: null,\r\n      firstNode: null,\r\n      lastNode: null,\r\n      autorun: function (f) {\r\n        return view.autorun(f);\r\n      },\r\n      __view__: view\r\n    };\r\n  }\r\n\r\n  tmpl.data = Blaze.getViewData(view);\r\n\r\n  if (view.domrange && !view.isDestroyed) {\r\n    tmpl.firstNode = view.domrange.firstNode();\r\n    tmpl.lastNode = view.domrange.lastNode();\r\n  } else {\r\n    // on 'created' or 'destroyed' callbacks we don't have a DomRange\r\n    tmpl.firstNode = null;\r\n    tmpl.lastNode = null;\r\n  }\r\n\r\n  return tmpl;\r\n};\r\n\r\nUI._templateInstance = function () {\r\n  var templateView = Blaze.getCurrentTemplateView();\r\n  if (! templateView)\r\n    throw new Error(\"No current template\");\r\n\r\n  return Template.__updateTemplateInstance(templateView);\r\n};\r\n\r\nTemplate.prototype.events = function (eventMap) {\r\n  var template = this;\r\n  template.__eventMaps = (template.__eventMaps || []);\r\n  var eventMap2 = {};\r\n  for (var k in eventMap) {\r\n    eventMap2[k] = (function (k, v) {\r\n      return function (event/*, ...*/) {\r\n        var view = this; // passed by EventAugmenter\r\n        var data = Blaze.getElementData(event.currentTarget);\r\n        if (data == null)\r\n          data = {};\r\n        var args = Array.prototype.slice.call(arguments);\r\n        var tmplInstance = Template.__updateTemplateInstance(view);\r\n        args.splice(1, 0, tmplInstance);\r\n        return v.apply(data, args);\r\n      };\r\n    })(k, eventMap[k]);\r\n  }\r\n\r\n  template.__eventMaps.push(eventMap2);\r\n};\r\n\r\nTemplate.prototype.__makeView = function (contentFunc, elseFunc) {\r\n  var template = this;\r\n  var view = Blaze.View(this.__viewName, this.__render);\r\n  view.template = template;\r\n\r\n  view.templateContentBlock = (\r\n    contentFunc ? Template.__create__('(contentBlock)', contentFunc) : null);\r\n  view.templateElseBlock = (\r\n    elseFunc ? Template.__create__('(elseBlock)', elseFunc) : null);\r\n\r\n  if (template.__eventMaps ||\r\n      typeof template.events === 'object') {\r\n    view.onMaterialized(function () {\r\n      if (! template.__eventMaps &&\r\n          typeof template.events === \"object\") {\r\n        // Provide limited back-compat support for `.events = {...}`\r\n        // syntax.  Pass `template.events` to the original `.events(...)`\r\n        // function.  This code must run only once per template, in\r\n        // order to not bind the handlers more than once, which is\r\n        // ensured by the fact that we only do this when `__eventMaps`\r\n        // is falsy, and we cause it to be set now.\r\n        Template.prototype.events.call(template, template.events);\r\n      }\r\n\r\n      _.each(template.__eventMaps, function (m) {\r\n        Blaze._addEventMap(view, m, view);\r\n      });\r\n    });\r\n  }\r\n\r\n  if (template.__initView)\r\n    template.__initView(view);\r\n\r\n  if (template.created) {\r\n    view.onCreated(function () {\r\n      var inst = Template.__updateTemplateInstance(view);\r\n      template.created.call(inst);\r\n    });\r\n  }\r\n\r\n  if (template.rendered) {\r\n    view.onRendered(function () {\r\n      var inst = Template.__updateTemplateInstance(view);\r\n      template.rendered.call(inst);\r\n    });\r\n  }\r\n\r\n  if (template.destroyed) {\r\n    view.onDestroyed(function () {\r\n      var inst = Template.__updateTemplateInstance(view);\r\n      template.destroyed.call(inst);\r\n    });\r\n  }\r\n\r\n  return view;\r\n};\r\n\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nTemplate.__lookup__ = function (templateName) {\r\n  if (! _hasOwnProperty.call(Template, templateName))\r\n    return null;\r\n  var tmpl = Template[templateName];\r\n  if (Template.__isTemplate__(tmpl))\r\n    return tmpl;\r\n  return null;\r\n};\r\n\r\nTemplate.__create__ = function (viewName, templateFunc, initView) {\r\n  var tmpl = new Template.prototype.constructor;\r\n  tmpl.__viewName = viewName;\r\n  tmpl.__render = templateFunc;\r\n  if (initView)\r\n    tmpl.__initView = initView;\r\n\r\n  return tmpl;\r\n};\r\n\r\nTemplate.__define__ = function (templateName, templateFunc) {\r\n  if (_hasOwnProperty.call(Template, templateName)) {\r\n    if (Template[templateName].__makeView)\r\n      throw new Error(\"There are multiple templates named '\" + templateName + \"'. Each template needs a unique name.\");\r\n    throw new Error(\"This template name is reserved: \" + templateName);\r\n  }\r\n\r\n  var tmpl = Template.__create__('Template.' + templateName, templateFunc);\r\n  tmpl.__templateName = templateName;\r\n\r\n  Template[templateName] = tmpl;\r\n  return tmpl;\r\n};\r\n\r\nTemplate.__isTemplate__ = function (x) {\r\n  return x && x.__makeView;\r\n};\r\n\r\n// Define a template `Template.__body__` that renders its\r\n// `__contentParts`.\r\nTemplate.__define__('__body__', function () {\r\n  var parts = Template.__body__.__contentParts;\r\n  // enable lookup by setting `view.template`\r\n  for (var i = 0; i < parts.length; i++)\r\n    parts[i].template = Template.__body__;\r\n  return parts;\r\n});\r\nTemplate.__body__.__contentParts = []; // array of Blaze.Views\r\n\r\n// Define `Template.__body__.__instantiate()` as a function that\r\n// renders `Template.__body__` into `document.body`, at most once\r\n// (calling it a second time does nothing).  This function does\r\n// not use `this`, so you can safely call:\r\n// `Meteor.startup(Template.__body__.__instantiate)`.\r\nTemplate.__body__.__isInstantiated = false;\r\nvar instantiateBody = function () {\r\n  if (Template.__body__.__isInstantiated)\r\n    return;\r\n  Template.__body__.__isInstantiated = true;\r\n  var range = Blaze.render(Template.__body__);\r\n  Template.__body__.__view = range.view;\r\n  range.attach(document.body);\r\n};\r\nTemplate.__body__.__instantiate = instantiateBody;\r\n\r\n\r\n// Renders a template (eg `Template.foo`), returning a DOMRange. The\r\n// range will keep updating reactively.\r\nUI.render = function (tmpl) {\r\n  if (! Template.__isTemplate__(tmpl))\r\n    throw new Error(\"Template required here\");\r\n\r\n  return Blaze.render(tmpl);\r\n};\r\n\r\n// Same as `UI.render` with a data context passed in.\r\nUI.renderWithData = function (tmpl, data) {\r\n  if (! Template.__isTemplate__(tmpl))\r\n    throw new Error(\"Template required here\");\r\n  if (typeof data === 'function')\r\n    throw new Error(\"Data argument can't be a function\"); // XXX or can it?\r\n\r\n  return Blaze.render(Blaze.With(data, function () {\r\n    return tmpl;\r\n  }));\r\n};\r\n\r\n// The publicly documented API for inserting a DOMRange returned from\r\n// `UI.render` or `UI.renderWithData` into the DOM. If you then remove\r\n// `parentElement` using jQuery, all reactive updates on the rendered\r\n// template will stop.\r\nUI.insert = function (range, parentElement, nextNode) {\r\n  // parentElement must be a DOM node. in particular, can't be the\r\n  // result of a call to `$`. Can't check if `parentElement instanceof\r\n  // Node` since 'Node' is undefined in IE8.\r\n  if (! parentElement || typeof parentElement.nodeType !== 'number')\r\n    throw new Error(\"'parentElement' must be a DOM node\");\r\n  if (nextNode && typeof nextNode.nodeType !== 'number') // 'nextNode' is optional\r\n    throw new Error(\"'nextNode' must be a DOM node\");\r\n  if (! range instanceof Blaze.DOMRange)\r\n    throw new Error(\"Expected template rendered with UI.render\");\r\n\r\n  range.attach(parentElement, nextNode);\r\n};\r\n\r\n// XXX test and document\r\nUI.remove = function (range) {\r\n  if (! range instanceof Blaze.DOMRange)\r\n    throw new Error(\"Expected template rendered with UI.render\");\r\n\r\n  if (range.attached)\r\n    range.detach();\r\n  range.destroy();\r\n};\r\n\r\nUI.body = Template.__body__;\r\n"]}