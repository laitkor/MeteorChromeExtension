)]}'
{"version":3,"file":"\\packages\\ordered-dict.js","sources":["ordered-dict/ordered_dict.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yE;AACA,8E;AACA,+C;;AAEA,4E;AACA,sB;;AAEA,kC;AACA,8C;AACA,iD;AACA,U;AACA,a;AACA,iB;AACA,e;AACA,c;AACA,I;AACA,E;AACA,oC;AACA,kB;AACA,kB;AACA,qB;AACA,oB;AACA,iB;AACA,kC;AACA,+C;AACA,oC;AACA,mC;AACA,8B;AACA,uC;AACA,K;AACA,E;;AAEA,iC;AACA,yD;AACA,gF;AACA,4D;;AAEA,sB;AACA,oB;AACA,wB;AACA,I;AACA,qB;AACA,oB;AACA,sB;AACA,I;AACA,8B;AACA,oB;AACA,oB;AACA,4B;AACA,qB;AACA,8B;AACA,uB;AACA,Y;AACA,+B;AACA,0B;AACA,mB;AACA,4B;AACA,K;AACA,yD;AACA,wB;AACA,I;AACA,+B;AACA,oB;AACA,iB;AACA,+B;AACA,iB;AACA,+B;AACA,2B;AACA,4B;AACA,4B;AACA,6B;AACA,I;AACA,2C;AACA,oB;AACA,iC;AACA,yE;AACA,sB;AACA,2D;AACA,mC;AACA,+B;AACA,oE;AACA,yB;AACA,mC;AACA,iB;AACA,I;AACA,gC;AACA,oB;AACA,oC;AACA,I;AACA,0B;AACA,oB;AACA,uC;AACA,0B;AACA,qE;AACA,0B;AACA,iB;AACA,oC;AACA,qB;AACA,I;AACA,uB;AACA,oB;AACA,sB;AACA,8C;AACA,qB;AACA,I;AACA,uB;AACA,oB;AACA,2C;AACA,I;AACA,mE;AACA,yC;;AAEA,8E;AACA,4B;AACA,oB;AACA,c;AACA,0B;AACA,0B;AACA,0C;AACA,kC;AACA,e;AACA,qB;AACA,U;AACA,K;AACA,I;AACA,sB;AACA,oB;AACA,qB;AACA,uB;AACA,2B;AACA,I;AACA,2B;AACA,oB;AACA,qB;AACA,uB;AACA,6B;AACA,I;AACA,qB;AACA,oB;AACA,qB;AACA,uB;AACA,0B;AACA,I;AACA,0B;AACA,oB;AACA,qB;AACA,uB;AACA,4B;AACA,I;AACA,wB;AACA,oB;AACA,wB;AACA,yC;AACA,mB;AACA,4B;AACA,K;AACA,gB;AACA,I;AACA,wB;AACA,oB;AACA,wB;AACA,yC;AACA,mB;AACA,4B;AACA,K;AACA,gB;AACA,I;AACA,sC;AACA,oB;AACA,uC;AACA,gE;AACA,0B;AACA,qD;AACA,kC;AACA,wE;AACA,K;AACA,sD;AACA,a;AACA,gC;AACA,0B;AACA,+B;AACA,yB;AACA,yB;AACA,I;AACA,mB;AACA,2B;AACA,oB;AACA,mB;AACA,qC;AACA,wC;AACA,gB;AACA,iC;AACA,O;AACA,uB;AACA,O;AACA,e;AACA,I;AACA,0B;AACA,oB;AACA,wC;AACA,uB;AACA,0C;AACA,uB;AACA,0C;AACA,O;AACA,G;;AAEA,G;AACA,oC","sourcesContent":["// This file defines an ordered dictionary abstraction that is useful for\r\n// maintaining a dataset backed by observeChanges.  It supports ordering items\r\n// by specifying the item they now come before.\r\n\r\n// The implementation is a dictionary that contains nodes of a doubly-linked\r\n// list as its values.\r\n\r\n// constructs a new element struct\r\n// next and prev are whole elements, not keys.\r\nvar element = function (key, value, next, prev) {\r\n  return {\r\n    key: key,\r\n    value: value,\r\n    next: next,\r\n    prev: prev\r\n  };\r\n};\r\nOrderedDict = function (/* ... */) {\r\n  var self = this;\r\n  self._dict = {};\r\n  self._first = null;\r\n  self._last = null;\r\n  self._size = 0;\r\n  var args = _.toArray(arguments);\r\n  self._stringify = function (x) { return x; };\r\n  if (typeof args[0] === 'function')\r\n    self._stringify = args.shift();\r\n  _.each(args, function (kv) {\r\n    self.putBefore(kv[0], kv[1], null);\r\n  });\r\n};\r\n\r\n_.extend(OrderedDict.prototype, {\r\n  // the \"prefix keys with a space\" thing comes from here\r\n  // https://github.com/documentcloud/underscore/issues/376#issuecomment-2815649\r\n  _k: function (key) { return \" \" + this._stringify(key); },\r\n\r\n  empty: function () {\r\n    var self = this;\r\n    return !self._first;\r\n  },\r\n  size: function () {\r\n    var self = this;\r\n    return self._size;\r\n  },\r\n  _linkEltIn: function (elt) {\r\n    var self = this;\r\n    if (!elt.next) {\r\n      elt.prev = self._last;\r\n      if (self._last)\r\n        self._last.next = elt;\r\n      self._last = elt;\r\n    } else {\r\n      elt.prev = elt.next.prev;\r\n      elt.next.prev = elt;\r\n      if (elt.prev)\r\n        elt.prev.next = elt;\r\n    }\r\n    if (self._first === null || self._first === elt.next)\r\n      self._first = elt;\r\n  },\r\n  _linkEltOut: function (elt) {\r\n    var self = this;\r\n    if (elt.next)\r\n      elt.next.prev = elt.prev;\r\n    if (elt.prev)\r\n      elt.prev.next = elt.next;\r\n    if (elt === self._last)\r\n      self._last = elt.prev;\r\n    if (elt === self._first)\r\n      self._first = elt.next;\r\n  },\r\n  putBefore: function (key, item, before) {\r\n    var self = this;\r\n    if (self._dict[self._k(key)])\r\n      throw new Error(\"Item \" + key + \" already present in OrderedDict\");\r\n    var elt = before ?\r\n          element(key, item, self._dict[self._k(before)]) :\r\n          element(key, item, null);\r\n    if (elt.next === undefined)\r\n      throw new Error(\"could not find item to put this one before\");\r\n    self._linkEltIn(elt);\r\n    self._dict[self._k(key)] = elt;\r\n    self._size++;\r\n  },\r\n  append: function (key, item) {\r\n    var self = this;\r\n    self.putBefore(key, item, null);\r\n  },\r\n  remove: function (key) {\r\n    var self = this;\r\n    var elt = self._dict[self._k(key)];\r\n    if (elt === undefined)\r\n      throw new Error(\"Item \" + key + \" not present in OrderedDict\");\r\n    self._linkEltOut(elt);\r\n    self._size--;\r\n    delete self._dict[self._k(key)];\r\n    return elt.value;\r\n  },\r\n  get: function (key) {\r\n    var self = this;\r\n    if (self.has(key))\r\n        return self._dict[self._k(key)].value;\r\n    return undefined;\r\n  },\r\n  has: function (key) {\r\n    var self = this;\r\n    return _.has(self._dict, self._k(key));\r\n  },\r\n  // Iterate through the items in this dictionary in order, calling\r\n  // iter(value, key, index) on each one.\r\n\r\n  // Stops whenever iter returns OrderedDict.BREAK, or after the last element.\r\n  forEach: function (iter) {\r\n    var self = this;\r\n    var i = 0;\r\n    var elt = self._first;\r\n    while (elt !== null) {\r\n      var b = iter(elt.value, elt.key, i);\r\n      if (b === OrderedDict.BREAK)\r\n        return;\r\n      elt = elt.next;\r\n      i++;\r\n    }\r\n  },\r\n  first: function () {\r\n    var self = this;\r\n    if (self.empty())\r\n      return undefined;\r\n    return self._first.key;\r\n  },\r\n  firstValue: function () {\r\n    var self = this;\r\n    if (self.empty())\r\n      return undefined;\r\n    return self._first.value;\r\n  },\r\n  last: function () {\r\n    var self = this;\r\n    if (self.empty())\r\n      return undefined;\r\n    return self._last.key;\r\n  },\r\n  lastValue: function () {\r\n    var self = this;\r\n    if (self.empty())\r\n      return undefined;\r\n    return self._last.value;\r\n  },\r\n  prev: function (key) {\r\n    var self = this;\r\n    if (self.has(key)) {\r\n      var elt = self._dict[self._k(key)];\r\n      if (elt.prev)\r\n        return elt.prev.key;\r\n    }\r\n    return null;\r\n  },\r\n  next: function (key) {\r\n    var self = this;\r\n    if (self.has(key)) {\r\n      var elt = self._dict[self._k(key)];\r\n      if (elt.next)\r\n        return elt.next.key;\r\n    }\r\n    return null;\r\n  },\r\n  moveBefore: function (key, before) {\r\n    var self = this;\r\n    var elt = self._dict[self._k(key)];\r\n    var eltBefore = before ? self._dict[self._k(before)] : null;\r\n    if (elt === undefined)\r\n      throw new Error(\"Item to move is not present\");\r\n    if (eltBefore === undefined) {\r\n      throw new Error(\"Could not find element to move this one before\");\r\n    }\r\n    if (eltBefore === elt.next) // no moving necessary\r\n      return;\r\n    // remove from its old place\r\n    self._linkEltOut(elt);\r\n    // patch into its new place\r\n    elt.next = eltBefore;\r\n    self._linkEltIn(elt);\r\n  },\r\n  // Linear, sadly.\r\n  indexOf: function (key) {\r\n    var self = this;\r\n    var ret = null;\r\n    self.forEach(function (v, k, i) {\r\n      if (self._k(k) === self._k(key)) {\r\n        ret = i;\r\n        return OrderedDict.BREAK;\r\n      }\r\n      return undefined;\r\n    });\r\n    return ret;\r\n  },\r\n  _checkRep: function () {\r\n    var self = this;\r\n    _.each(self._dict, function (k, v) {\r\n      if (v.next === v)\r\n        throw new Error(\"Next is a loop\");\r\n      if (v.prev === v)\r\n        throw new Error(\"Prev is a loop\");\r\n    });\r\n  }\r\n\r\n});\r\nOrderedDict.BREAK = {\"break\": true};\r\n"]}