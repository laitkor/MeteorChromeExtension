)]}'
{"version":3,"file":"\\packages\\logging.js","sources":["logging/logging.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mB;AACA,yC;AACA,E;;AAEA,e;AACA,kB;AACA,0B;AACA,iB;;AAEA,iE;AACA,kE;AACA,sB;AACA,mC;AACA,qB;AACA,E;;AAEA,sE;AACA,mE;AACA,kC;AACA,kC;AACA,oB;AACA,E;;AAEA,8D;AACA,gC;AACA,+B;AACA,wB;AACA,gB;AACA,e;AACA,E;;AAEA,mC;AACA,E;AACA,8E;AACA,wE;AACA,gC;AACA,E;AACA,yE;AACA,2E;AACA,0D;AACA,0B;;AAEA,oB;AACA,iB;AACA,oC;AACA,kB;AACA,c;AACA,E;;AAEA,8E;;AAEA,c;AACA,sE;AACA,uE;;AAEA,gE;;AAEA,mC;AACA,4B;;AAEA,6D;AACA,wB;;AAEA,2D;AACA,wB;AACA,U;AACA,4E;AACA,yE;AACA,kC;AACA,uB;AACA,G;AACA,E;;AAEA,oD;AACA,qC;AACA,8B;AACA,gF;AACA,4E;AACA,kE;AACA,wB;AACA,0B;AACA,iB;AACA,I;;AAEA,yB;;AAEA,wB;;AAEA,gC;;AAEA,kE;AACA,gC;AACA,W;AACA,0C;AACA,oB;AACA,2C;AACA,4B;AACA,K;;AAEA,+D;AACA,+D;AACA,Y;AACA,G;;AAEA,mB;;AAEA,4D;AACA,4E;AACA,0D;AACA,mE;AACA,a;AACA,mB;AACA,kD;AACA,wC;;AAEA,uE;AACA,oE;AACA,2B;AACA,gE;;AAEA,iB;AACA,E;;AAEA,6D;AACA,+B;AACA,+B;AACA,mB;AACA,iB;AACA,a;AACA,K;;AAEA,4B;AACA,oB;AACA,kB;AACA,yB;AACA,K;;AAEA,wE;AACA,2D;;AAEA,4C;AACA,mB;AACA,kE;AACA,O;;AAEA,0D;AACA,6E;AACA,+B;AACA,mD;AACA,0B;AACA,sB;;AAEA,4D;AACA,0B;AACA,a;;AAEA,sB;AACA,kD;AACA,iC;AACA,gD;AACA,oD;AACA,+C;AACA,0C;AACA,c;AACA,8E;AACA,O;AACA,Y;AACA,wB;AACA,K;AACA,I;AACA,G;;AAEA,sF;AACA,6B;AACA,iB;AACA,qF;AACA,iD;AACA,G;;AAEA,uD;AACA,oD;AACA,e;AACA,M;AACA,gB;AACA,E;;AAEA,oE;AACA,sC;AACA,sD;AACA,0B;;AAEA,sB;AACA,8B;AACA,oD;AACA,oC;;AAEA,gE;AACA,kC;AACA,sB;AACA,4B;AACA,8B;AACA,gC;AACA,kC;AACA,kC;AACA,gC;AACA,gC;;AAEA,wC;AACA,oB;AACA,K;;AAEA,wB;AACA,gC;AACA,oC;AACA,G;;AAEA,qE;AACA,4E;;AAEA,iD;AACA,2C;AACA,yB;AACA,yC;AACA,a;AACA,iC;AACA,a;AACA,iC;AACA,a;AACA,qC;;AAEA,oD;AACA,0E;;AAEA,mB;AACA,kC;AACA,yE;AACA,8C;;AAEA,yC;AACA,iF;AACA,W;;AAEA,gB;AACA,iD;;AAEA,kD;;AAEA,oB;AACA,kC;AACA,c;AACA,Q;AACA,c;AACA,iB;AACA,6B;AACA,Y;AACA,e;AACA,8B;;AAEA,yC;AACA,wD;AACA,mD;AACA,I;;AAEA,yC;AACA,6C;AACA,E;;AAEA,8C;AACA,uB;AACA,2B;AACA,6C;AACA,gF;AACA,iC;AACA,E","sourcesContent":["Log = function () {\r\n  return Log.info.apply(this, arguments);\r\n};\r\n\r\n/// FOR TESTING\r\nvar intercept = 0;\r\nvar interceptedLines = [];\r\nvar suppress = 0;\r\n\r\n// Intercept the next 'count' calls to a Log function. The actual\r\n// lines printed to the console can be cleared and read by calling\r\n// Log._intercepted().\r\nLog._intercept = function (count) {\r\n  intercept += count;\r\n};\r\n\r\n// Suppress the next 'count' calls to a Log function. Use this to stop\r\n// tests from spamming the console, especially with red errors that\r\n// might look like a failing test.\r\nLog._suppress = function (count) {\r\n  suppress += count;\r\n};\r\n\r\n// Returns intercepted lines and resets the intercept counter.\r\nLog._intercepted = function () {\r\n  var lines = interceptedLines;\r\n  interceptedLines = [];\r\n  intercept = 0;\r\n  return lines;\r\n};\r\n\r\n// Either 'json' or 'colored-text'.\r\n//\r\n// When this is set to 'json', print JSON documents that are parsed by another\r\n// process ('satellite' or 'meteor run'). This other process should call\r\n// 'Log.format' for nice output.\r\n//\r\n// When this is set to 'colored-text', call 'Log.format' before printing.\r\n// This should be used for logging from within satellite, since there is no\r\n// other process that will be reading its standard output.\r\nLog.outputFormat = 'json';\r\n\r\nvar LEVEL_COLORS = {\r\n  debug: 'green',\r\n  // leave info as the default color\r\n  warn: 'magenta',\r\n  error: 'red'\r\n};\r\n\r\nvar META_COLOR = 'cyan'; // 'blue'; Dark blue is hard to see on black consoles\r\n\r\n// XXX package\r\nvar RESTRICTED_KEYS = ['time', 'timeInexact', 'level', 'file', 'line',\r\n                        'program', 'originApp', 'satellite', 'stderr'];\r\n\r\nvar FORMATTED_KEYS = RESTRICTED_KEYS.concat(['app', 'message']);\r\n\r\nvar logInBrowser = function (obj) {\r\n  var str = Log.format(obj);\r\n\r\n  // XXX Some levels should be probably be sent to the server\r\n  var level = obj.level;\r\n\r\n  if ((typeof console !== 'undefined') && console[level]) {\r\n    console[level](str);\r\n  } else {\r\n    // XXX Uses of Meteor._debug should probably be replaced by Log.debug or\r\n    //     Log.info, and we should have another name for \"do your best to\r\n    //     call call console.log\".\r\n    Meteor._debug(str);\r\n  }\r\n};\r\n\r\n// @returns {Object: { line: Number, file: String }}\r\nLog._getCallerDetails = function () {\r\n  var getStack = function () {\r\n    // We do NOT use Error.prepareStackTrace here (a V8 extension that gets us a\r\n    // pre-parsed stack) since it's impossible to compose it with the use of\r\n    // Error.prepareStackTrace used on the server for source maps.\r\n    var err = new Error;\r\n    var stack = err.stack;\r\n    return stack;\r\n  };\r\n\r\n  var stack = getStack();\r\n\r\n  if (!stack) return {};\r\n\r\n  var lines = stack.split('\\n');\r\n\r\n  // looking for the first line outside the logging package (or an\r\n  // eval if we find that first)\r\n  var line;\r\n  for (var i = 1; i < lines.length; ++i) {\r\n    line = lines[i];\r\n    if (line.match(/^\\s*at eval \\(eval/)) {\r\n      return {file: \"eval\"};\r\n    }\r\n\r\n    // XXX probably wants to be / or .js in case no source maps\r\n    if (!line.match(/packages\\/logging(?:\\/|(?::tests)?\\.js)/))\r\n      break;\r\n  }\r\n\r\n  var details = {};\r\n\r\n  // The format for FF is 'functionName@filePath:lineNumber'\r\n  // The format for V8 is 'functionName (packages/logging/logging.js:81)' or\r\n  //                      'packages/logging/logging.js:81'\r\n  var match = /(?:[@(]| at )([^(]+?):([0-9:]+)(?:\\)|$)/.exec(line);\r\n  if (!match)\r\n    return details;\r\n  // in case the matched block here is line:column\r\n  details.line = match[2].split(':')[0];\r\n\r\n  // Possible format: https://foo.bar.com/scripts/file.js?random=foobar\r\n  // XXX: if you can write the following in better way, please do it\r\n  // XXX: what about evals?\r\n  details.file = match[1].split('/').slice(-1)[0].split('?')[0];\r\n\r\n  return details;\r\n};\r\n\r\n_.each(['debug', 'info', 'warn', 'error'], function (level) {\r\n  // @param arg {String|Object}\r\n  Log[level] = function (arg) {\r\n    if (suppress) {\r\n      suppress--;\r\n      return;\r\n    }\r\n\r\n    var intercepted = false;\r\n    if (intercept) {\r\n      intercept--;\r\n      intercepted = true;\r\n    }\r\n\r\n    var obj = (_.isObject(arg) && !_.isRegExp(arg) && !_.isDate(arg) ) ?\r\n              arg : {message: new String(arg).toString() };\r\n\r\n    _.each(RESTRICTED_KEYS, function (key) {\r\n      if (obj[key])\r\n        throw new Error(\"Can't set '\" + key + \"' in log message\");\r\n    });\r\n\r\n    if (_.has(obj, 'message') && !_.isString(obj.message))\r\n      throw new Error(\"The 'message' field in log objects must be a string\");\r\n    if (!obj.omitCallerDetails)\r\n      obj = _.extend(Log._getCallerDetails(), obj);\r\n    obj.time = new Date();\r\n    obj.level = level;\r\n\r\n    // XXX allow you to enable 'debug', probably per-package\r\n    if (level === 'debug')\r\n      return;\r\n\r\n    if (intercepted) {\r\n      interceptedLines.push(EJSON.stringify(obj));\r\n    } else if (Meteor.isServer) {\r\n      if (Log.outputFormat === 'colored-text') {\r\n        console.log(Log.format(obj, {color: true}));\r\n      } else if (Log.outputFormat === 'json') {\r\n        console.log(EJSON.stringify(obj));\r\n      } else {\r\n        throw new Error(\"Unknown logging output format: \" + Log.outputFormat);\r\n      }\r\n    } else {\r\n      logInBrowser(obj);\r\n    }\r\n  };\r\n});\r\n\r\n// tries to parse line as EJSON. returns object if parse is successful, or null if not\r\nLog.parse = function (line) {\r\n  var obj = null;\r\n  if (line && line.charAt(0) === '{') { // might be json generated from calling 'Log'\r\n    try { obj = EJSON.parse(line); } catch (e) {}\r\n  }\r\n\r\n  // XXX should probably check fields other than 'time'\r\n  if (obj && obj.time && (obj.time instanceof Date))\r\n    return obj;\r\n  else\r\n    return null;\r\n};\r\n\r\n// formats a log object into colored human and machine-readable text\r\nLog.format = function (obj, options) {\r\n  obj = EJSON.clone(obj); // don't mutate the argument\r\n  options = options || {};\r\n\r\n  var time = obj.time;\r\n  if (!(time instanceof Date))\r\n    throw new Error(\"'time' must be a Date object\");\r\n  var timeInexact = obj.timeInexact;\r\n\r\n  // store fields that are in FORMATTED_KEYS since we strip them\r\n  var level = obj.level || 'info';\r\n  var file = obj.file;\r\n  var lineNumber = obj.line;\r\n  var appName = obj.app || '';\r\n  var originApp = obj.originApp;\r\n  var message = obj.message || '';\r\n  var program = obj.program || '';\r\n  var satellite = obj.satellite;\r\n  var stderr = obj.stderr || '';\r\n\r\n  _.each(FORMATTED_KEYS, function(key) {\r\n    delete obj[key];\r\n  });\r\n\r\n  if (!_.isEmpty(obj)) {\r\n    if (message) message += \" \";\r\n    message += EJSON.stringify(obj);\r\n  }\r\n\r\n  var pad2 = function(n) { return n < 10 ? '0' + n : n.toString(); };\r\n  var pad3 = function(n) { return n < 100 ? '0' + pad2(n) : n.toString(); };\r\n\r\n  var dateStamp = time.getFullYear().toString() +\r\n    pad2(time.getMonth() + 1 /*0-based*/) +\r\n    pad2(time.getDate());\r\n  var timeStamp = pad2(time.getHours()) +\r\n        ':' +\r\n        pad2(time.getMinutes()) +\r\n        ':' +\r\n        pad2(time.getSeconds()) +\r\n        '.' +\r\n        pad3(time.getMilliseconds());\r\n\r\n  // eg in San Francisco in June this will be '(-7)'\r\n  var utcOffsetStr = '(' + (-(new Date().getTimezoneOffset() / 60)) + ')';\r\n\r\n  var appInfo = '';\r\n  if (appName) appInfo += appName;\r\n  if (originApp && originApp !== appName) appInfo += ' via ' + originApp;\r\n  if (appInfo) appInfo = '[' + appInfo + '] ';\r\n\r\n  var sourceInfo = (file && lineNumber) ?\r\n      ['(', (program ? program + ':' : ''), file, ':', lineNumber, ') '].join('')\r\n      : '';\r\n\r\n  if (satellite)\r\n    sourceInfo += ['[', satellite, ']'].join('');\r\n\r\n  var stderrIndicator = stderr ? '(STDERR) ' : '';\r\n\r\n  var metaPrefix = [\r\n    level.charAt(0).toUpperCase(),\r\n    dateStamp,\r\n    '-',\r\n    timeStamp,\r\n    utcOffsetStr,\r\n    timeInexact ? '? ' : ' ',\r\n    appInfo,\r\n    sourceInfo,\r\n    stderrIndicator].join('');\r\n\r\n  var prettify = function (line, color) {\r\n    return (options.color && Meteor.isServer && color) ?\r\n      Npm.require('cli-color')[color](line) : line;\r\n  };\r\n\r\n  return prettify(metaPrefix, META_COLOR)\r\n    + prettify(message, LEVEL_COLORS[level]);\r\n};\r\n\r\n// Turn a line of text into a loggable object.\r\n// @param line {String}\r\n// @param override {Object}\r\nLog.objFromText = function (line, override) {\r\n  var obj = {message: line, level: \"info\", time: new Date(), timeInexact: true};\r\n  return _.extend(obj, override);\r\n};\r\n"]}