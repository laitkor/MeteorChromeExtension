)]}'
{"version":3,"file":"\\packages\\autoupdate.js","sources":["autoupdate/autoupdate_client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kE;AACA,wD;AACA,E;AACA,sE;AACA,mE;AACA,uE;AACA,uD;AACA,E;AACA,+D;AACA,gE;AACA,2B;AACA,E;AACA,sE;AACA,qE;AACA,mC;AACA,E;AACA,kE;AACA,yE;AACA,c;AACA,E;AACA,oE;AACA,kE;AACA,sC;;AAEA,iE;AACA,W;AACA,iF;;;AAGA,gD;AACA,+E;;;AAGA,gB;;AAEA,6C;AACA,mC;AACA,Y;AACA,sB;AACA,qC;AACA,M;AACA,I;AACA,E;;;;AAIA,uB;AACA,0E;AACA,yE;AACA,qC;AACA,I;AACA,uE;AACA,uE;AACA,mE;AACA,+D;AACA,gD;AACA,wC;AACA,G;AACA,iB;;AAEA,6C;AACA,wD;AACA,+B;AACA,8D;AACA,iB;AACA,8C;AACA,qE;AACA,qE;AACA,wE;AACA,mE;AACA,+D;AACA,wE;AACA,+B;AACA,wC;AACA,S;AACA,M;AACA,0B;AACA,2B;AACA,6C;AACA,wD;AACA,qE;AACA,+B;AACA,4C;AACA,W;AACA,W;AACA,O;AACA,G;AACA,K;AACA,E;AACA,gC","sourcesContent":["// Subscribe to the `meteor_autoupdate_clientVersions` collection,\r\n// which contains the set of acceptable client versions.\r\n//\r\n// A \"hard code push\" occurs when the running client version is not in\r\n// the set of acceptable client versions (or the server updates the\r\n// collection, there is a published client version marked `current` and\r\n// the running client version is no longer in the set).\r\n//\r\n// When the `reload` package is loaded, a hard code push causes\r\n// the browser to reload, so that it will load the latest client\r\n// version from the server.\r\n//\r\n// A \"soft code push\" represents the situation when the running client\r\n// version is in the set of acceptable versions, but there is a newer\r\n// version available on the server.\r\n//\r\n// `Autoupdate.newClientAvailable` is a reactive data source which\r\n// becomes `true` if there is a new version of the client is available on\r\n// the server.\r\n//\r\n// This package doesn't implement a soft code reload process itself,\r\n// but `newClientAvailable` could be used for example to display a\r\n// \"click to reload\" link to the user.\r\n\r\n// The client version of the client code currently running in the\r\n// browser.\r\nvar autoupdateVersion = __meteor_runtime_config__.autoupdateVersion || \"unknown\";\r\n\r\n\r\n// The collection of acceptable client versions.\r\nvar ClientVersions = new Meteor.Collection(\"meteor_autoupdate_clientVersions\");\r\n\r\n\r\nAutoupdate = {};\r\n\r\nAutoupdate.newClientAvailable = function () {\r\n  return !! ClientVersions.findOne(\r\n    {$and: [\r\n      {current: true},\r\n      {_id: {$ne: autoupdateVersion}}\r\n    ]}\r\n  );\r\n};\r\n\r\n\r\n\r\nvar retry = new Retry({\r\n  // Unlike the stream reconnect use of Retry, which we want to be instant\r\n  // in normal operation, this is a wacky failure. We don't want to retry\r\n  // right away, we can start slowly.\r\n  //\r\n  // A better way than timeconstants here might be to use the knowledge\r\n  // of when we reconnect to help trigger these retries. Typically, the\r\n  // server fixing code will result in a restart and reconnect, but\r\n  // potentially the subscription could have a transient error.\r\n  minCount: 0, // don't do any immediate retries\r\n  baseTimeout: 30*1000 // start with 30s\r\n});\r\nvar failures = 0;\r\n\r\nAutoupdate._retrySubscription = function () {\r\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", {\r\n    onError: function (error) {\r\n      Meteor._debug(\"autoupdate subscription failed:\", error);\r\n      failures++;\r\n      retry.retryLater(failures, function () {\r\n        // Just retry making the subscription, don't reload the whole\r\n        // page. While reloading would catch more cases (for example,\r\n        // the server went back a version and is now doing old-style hot\r\n        // code push), it would also be more prone to reload loops,\r\n        // which look really bad to the user. Just retrying the\r\n        // subscription over DDP means it is at least possible to fix by\r\n        // updating the server.\r\n        Autoupdate._retrySubscription();\r\n      });\r\n    },\r\n    onReady: function () {\r\n      if (Package.reload) {\r\n        Deps.autorun(function (computation) {\r\n          if (ClientVersions.findOne({current: true}) &&\r\n              (! ClientVersions.findOne({_id: autoupdateVersion}))) {\r\n            computation.stop();\r\n            Package.reload.Reload._reload();\r\n          }\r\n        });\r\n      }\r\n  }\r\n  });\r\n};\r\nAutoupdate._retrySubscription();\r\n"]}