)]}'
{"version":3,"file":"\\packages\\reload.js","sources":["reload/reload.js","reload/deprecated.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,kE;AACA,gE;AACA,E;AACA,sD;AACA,E;AACA,mE;AACA,uE;AACA,qE;AACA,gE;AACA,sE;AACA,mE;AACA,4C;AACA,uC;AACA,gE;AACA,4D;AACA,E;AACA,qE;AACA,qE;AACA,wE;AACA,sE;AACA,oC;AACA,E;AACA,qE;AACA,uE;AACA,2C;AACA,G;;AAEA,kE;AACA,kE;AACA,qD;AACA,4C;;AAEA,+B;AACA,gE;AACA,gE;AACA,iE;AACA,gE;AACA,4C;AACA,oB;;;AAGA,kB;AACA,+B;AACA,a;AACA,4E;AACA,iE;AACA,8D;AACA,8C;AACA,sC;AACA,Q;AACA,yD;AACA,8C;AACA,C;;AAEA,+B;AACA,oB;AACA,K;AACA,oC;AACA,uC;AACA,uD;AACA,oB;AACA,G;AACA,e;AACA,yD;AACA,C;;AAEA,+D;AACA,yD;AACA,6C;AACA,6B;AACA,C;;;AAGA,mB;;AAEA,kC;;AAEA,Y;;AAEA,gE;AACA,kE;AACA,oE;AACA,oE;AACA,mE;AACA,+D;AACA,oE;AACA,2D;AACA,iE;AACA,mE;AACA,oE;AACA,6E;AACA,qB;AACA,E;AACA,+C;AACA,kB;AACA,mD;AACA,oB;AACA,qB;AACA,G;AACA,mD;AACA,E;;AAEA,yC;AACA,iE;AACA,E;AACA,yC;AACA,wB;AACA,E;;AAEA,kE;AACA,iE;AACA,iE;AACA,mE;AACA,wB;AACA,E;AACA,sB;AACA,8B;AACA,gB;AACA,W;AACA,mB;;AAEA,qD;AACA,+D;AACA,qB;AACA,2B;AACA,uC;AACA,8B;AACA,gC;AACA,yC;AACA,qB;AACA,kC;AACA,sC;AACA,0C;AACA,M;;AAEA,S;AACA,mC;AACA,iC;AACA,uE;AACA,S;AACA,mB;AACA,4E;AACA,gB;AACA,K;;AAEA,kE;AACA,W;AACA,+C;AACA,qB;AACA,kD;AACA,iF;AACA,O;AACA,Y;AACA,4F;AACA,K;;AAEA,+D;AACA,6B;AACA,Q;;AAEA,c;AACA,E;;;;;;;;;;;;;;;;;;;AClKA,8E;AACA,sD;AACA,wB;AACA,kB;AACA,+B;AACA,uC;AACA,wB;AACA,E","sourcesContent":["/**\r\n * This code does _NOT_ support hot (session-restoring) reloads on\r\n * IE6,7. It only works on browsers with sessionStorage support.\r\n *\r\n * There are a couple approaches to add IE6,7 support:\r\n *\r\n * - use IE's \"userData\" mechanism in combination with window.name.\r\n * This mostly works, however the problem is that it can not get to the\r\n * data until after DOMReady. This is a problem for us since this API\r\n * relies on the data being ready before API users run. We could\r\n * refactor using Meteor.startup in all API users, but that might slow\r\n * page loads as we couldn't start the stream until after DOMReady.\r\n * Here are some resources on this approach:\r\n * https://github.com/hugeinc/USTORE.js\r\n * http://thudjs.tumblr.com/post/419577524/localstorage-userdata\r\n * http://www.javascriptkit.com/javatutors/domstorage2.shtml\r\n *\r\n * - POST the data to the server, and have the server send it back on\r\n * page load. This is nice because it sidesteps all the local storage\r\n * compatibility issues, however it is kinda tricky. We can use a unique\r\n * token in the URL, then get rid of it with HTML5 pushstate, but that\r\n * only works on pushstate browsers.\r\n *\r\n * This will all need to be reworked entirely when we add server-side\r\n * HTML rendering. In that case, the server will need to have access to\r\n * the client's session to render properly.\r\n */\r\n\r\n// XXX when making this API public, also expose a flag for the app\r\n// developer to know whether a hot code push is happening. This is\r\n// useful for apps using `window.onbeforeunload`. See\r\n// https://github.com/meteor/meteor/pull/657\r\n\r\nvar KEY_NAME = 'Meteor_Reload';\r\n// after how long should we consider this no longer an automatic\r\n// reload, but a fresh restart. This only happens if a reload is\r\n// interrupted and a user manually restarts things. The only time\r\n// this is really weird is if a user navigates away mid-refresh,\r\n// then manually navigates back to the page.\r\nvar TIMEOUT = 30000;\r\n\r\n\r\nvar old_data = {};\r\n// read in old data at startup.\r\nvar old_json;\r\n// On Firefox with dom.storage.enabled set to false, sessionStorage is null,\r\n// so we have to both check to see if it is defined and not null.\r\nif (typeof sessionStorage !== \"undefined\" && sessionStorage) {\r\n  old_json = sessionStorage.getItem(KEY_NAME);\r\n  sessionStorage.removeItem(KEY_NAME);\r\n} else {\r\n  // Unsupported browser (IE 6,7). No session resumption.\r\n  // Meteor._debug(\"XXX UNSUPPORTED BROWSER\");\r\n}\r\n\r\nif (!old_json) old_json = '{}';\r\nvar old_parsed = {};\r\ntry {\r\n  old_parsed = JSON.parse(old_json);\r\n  if (typeof old_parsed !== \"object\") {\r\n    Meteor._debug(\"Got bad data on reload. Ignoring.\");\r\n    old_parsed = {};\r\n  }\r\n} catch (err) {\r\n  Meteor._debug(\"Got invalid JSON on reload. Ignoring.\");\r\n}\r\n\r\nif (old_parsed.reload && typeof old_parsed.data === \"object\" &&\r\n    old_parsed.time + TIMEOUT > (new Date()).getTime()) {\r\n  // Meteor._debug(\"Restoring reload data.\");\r\n  old_data = old_parsed.data;\r\n}\r\n\r\n\r\nvar providers = [];\r\n\r\n////////// External API //////////\r\n\r\nReload = {};\r\n\r\n// Packages that support migration should register themselves by\r\n// calling this function. When it's time to migrate, callback will\r\n// be called with one argument, the \"retry function.\" If the package\r\n// is ready to migrate, it should return [true, data], where data is\r\n// its migration data, an arbitrary JSON value (or [true] if it has\r\n// no migration data this time). If the package needs more time\r\n// before it is ready to migrate, it should return false. Then, once\r\n// it is ready to migrating again, it should call the retry\r\n// function. The retry function will return immediately, but will\r\n// schedule the migration to be retried, meaning that every package\r\n// will be polled once again for its migration data. If they are all\r\n// ready this time, then the migration will happen. name must be set if there\r\n// is migration data.\r\n//\r\nReload._onMigrate = function (name, callback) {\r\n  if (!callback) {\r\n    // name not provided, so first arg is callback.\r\n    callback = name;\r\n    name = undefined;\r\n  }\r\n  providers.push({name: name, callback: callback});\r\n};\r\n\r\n// Called by packages when they start up.\r\n// Returns the object that was saved, or undefined if none saved.\r\n//\r\nReload._migrationData = function (name) {\r\n  return old_data[name];\r\n};\r\n\r\n// Migrating reload: reload this page (presumably to pick up a new\r\n// version of the code or assets), but save the program state and\r\n// migrate it over. This function returns immediately. The reload\r\n// will happen at some point in the future once all of the packages\r\n// are ready to migrate.\r\n//\r\nvar reloading = false;\r\nReload._reload = function () {\r\n  if (reloading)\r\n    return;\r\n  reloading = true;\r\n\r\n  var tryReload = function () { _.defer(function () {\r\n    // Make sure each package is ready to go, and collect their\r\n    // migration data\r\n    var migrationData = {};\r\n    var remaining = _.clone(providers);\r\n    while (remaining.length) {\r\n      var p = remaining.shift();\r\n      var status = p.callback(tryReload);\r\n      if (!status[0])\r\n        return; // not ready yet..\r\n      if (status.length > 1 && p.name)\r\n        migrationData[p.name] = status[1];\r\n    };\r\n\r\n    try {\r\n      // Persist the migration data\r\n      var json = JSON.stringify({\r\n        time: (new Date()).getTime(), data: migrationData, reload: true\r\n      });\r\n    } catch (err) {\r\n      Meteor._debug(\"Couldn't serialize data for migration\", migrationData);\r\n      throw err;\r\n    }\r\n\r\n    if (typeof sessionStorage !== \"undefined\" && sessionStorage) {\r\n      try {\r\n        sessionStorage.setItem(KEY_NAME, json);\r\n      } catch (err) {\r\n        // happens in safari with private browsing\r\n        Meteor._debug(\"Couldn't save data for migration to sessionStorage\", err);\r\n      }\r\n    } else {\r\n      Meteor._debug(\"Browser does not support sessionStorage. Not saving migration state.\");\r\n    }\r\n\r\n    // Tell the browser to shut down this VM and make a new one\r\n    window.location.reload();\r\n  }); };\r\n\r\n  tryReload();\r\n};\r\n","// Reload functionality used to live on Meteor._reload. Be nice and try not to\r\n// break code that uses it, even though it's internal.\r\n// XXX COMPAT WITH 0.6.4\r\nMeteor._reload = {\r\n  onMigrate: Reload._onMigrate,\r\n  migrationData: Reload._migrationData,\r\n  reload: Reload._reload\r\n};\r\n"]}