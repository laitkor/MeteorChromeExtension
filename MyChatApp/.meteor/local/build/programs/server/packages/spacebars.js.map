{"version":3,"file":"\\packages\\spacebars.js","sources":["spacebars/spacebars-runtime.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,e;;AAEA,uD;;AAEA,0E;AACA,2B;AACA,gB;;AAEA,iD;AACA,sC;AACA,qC;AACA,uE;AACA,wE;AACA,G;;AAEA,0D;AACA,0D;AACA,qC;AACA,0B;AACA,kB;;AAEA,4C;AACA,uE;;AAEA,8D;AACA,K;AACA,mC;AACA,8B;AACA,8B;AACA,4C;AACA,O;AACA,K;;AAEA,c;AACA,E;;AAEA,+D;AACA,2D;AACA,2B;AACA,E;AACA,oD;AACA,oE;AACA,U;AACA,qD;AACA,uB;AACA,kE;AACA,wB;AACA,wB;AACA,mC;AACA,yC;AACA,0B;AACA,wD;AACA,6B;AACA,mD;AACA,oB;AACA,Y;AACA,yD;AACA,uB;AACA,8B;AACA,2B;AACA,yD;AACA,O;AACA,oD;AACA,K;AACA,G;;AAEA,0C;AACA,E;;AAEA,iD;AACA,6D;;AAEA,6C;AACA,uC;AACA,M;AACA,uE;AACA,kE;AACA,6E;AACA,wE;AACA,E;;AAEA,qD;AACA,6D;;AAEA,wC;AACA,gB;AACA,0C;AACA,kB;AACA,+E;AACA,iB;AACA,qB;AACA,e;AACA,U;AACA,0E;AACA,G;AACA,E;;AAEA,qD;AACA,6D;;AAEA,gB;AACA,E;;AAEA,mC;AACA,E;AACA,mE;AACA,qD;AACA,sC;AACA,yC;AACA,gB;AACA,qC;AACA,iB;AACA,M;AACA,2B;AACA,E;;AAEA,2D;AACA,8D;AACA,iE;AACA,sB;AACA,6C;AACA,oC;AACA,iE;AACA,qB;AACA,gD;AACA,6B;AACA,+D;AACA,K;;AAEA,sC;AACA,U;AACA,6B;AACA,2D;;AAEA,iB;AACA,G;AACA,E;;AAEA,0D;AACA,gC;AACA,gC;AACA,uC;AACA,wC;AACA,kC;;AAEA,yB;AACA,E;;AAEA,sE;AACA,gF;AACA,wC;AACA,+C;AACA,wC;AACA,0C;;AAEA,yC;AACA,E;AACA,iE;;AAEA,6D;AACA,2D;AACA,4D;AACA,4D;AACA,2D;AACA,W;AACA,E;AACA,gE;AACA,qE;AACA,oE;AACA,E;AACA,4D;AACA,E;AACA,qC;AACA,E;AACA,4D;AACA,E;AACA,yC;AACA,E;AACA,8D;AACA,qD;AACA,6B;AACA,mE;AACA,qC;AACA,4B;AACA,mD;AACA,6C;AACA,wE;AACA,qD;AACA,G;;AAEA,kC;AACA,oB;;AAEA,c;AACA,qD;;AAEA,0B;AACA,mC;AACA,kB;AACA,oD;AACA,mE;AACA,mC;AACA,0C;AACA,I;AACA,E;;AAEA,2D;AACA,Q;;AAEA,yE;AACA,4E;AACA,6E;AACA,sE;AACA,0D;AACA,2E;AACA,qE;AACA,gC;AACA,I;AACA,yE;AACA,mE;AACA,oC;AACA,iC;AACA,uE;AACA,0D;AACA,K;AACA,4B;AACA,+D;AACA,Y;AACA,uB;AACA,K;AACA,I;;AAEA,+C;AACA,4B;AACA,W;AACA,E;;AAEA,+D;AACA,8D;AACA,8D;AACA,2D;AACA,uB;AACA,4D;AACA,qC;AACA,uD;AACA,yD;AACA,iE;AACA,8D;AACA,8B;AACA,K;AACA,8B;AACA,8B;AACA,4B;;AAEA,wD;AACA,4D;AACA,2C;;AAEA,qC;AACA,6B;AACA,S;;AAEA,gE;AACA,+D;AACA,+C;AACA,Q;AACA,2C;AACA,Q;AACA,qD;AACA,gC;AACA,mC;AACA,kC;AACA,oC;AACA,Q;AACA,kE;AACA,mE;AACA,oE;AACA,kE;AACA,uB;AACA,Q;AACA,oE;AACA,uD;AACA,8C;AACA,Q;AACA,uC;AACA,8C;AACA,oB;AACA,4D;AACA,Q;AACA,6B;AACA,Q;AACA,iE;AACA,oB;AACA,4D;AACA,Q;AACA,oE;AACA,gE;AACA,sE;AACA,gE;AACA,oB;AACA,O;AACA,K;;AAEA,c;AACA,E","sourcesContent":["Spacebars = {};\r\n\r\nvar tripleEquals = function (a, b) { return a === b; };\r\n\r\nSpacebars.include = function (templateOrFunction, contentFunc, elseFunc) {\r\n  if (! templateOrFunction)\r\n    return null;\r\n\r\n  if (typeof templateOrFunction !== 'function') {\r\n    var template = templateOrFunction;\r\n    if (! Blaze.isTemplate(template))\r\n      throw new Error(\"Expected template or null, found: \" + template);\r\n    return Blaze.runTemplate(templateOrFunction, contentFunc, elseFunc);\r\n  }\r\n\r\n  var templateVar = Blaze.ReactiveVar(null, tripleEquals);\r\n  var view = Blaze.View('Spacebars.include', function () {\r\n    var template = templateVar.get();\r\n    if (template === null)\r\n      return null;\r\n\r\n    if (! Template.__isTemplate__(template))\r\n      throw new Error(\"Expected template or null, found: \" + template);\r\n\r\n    return Blaze.runTemplate(template, contentFunc, elseFunc);\r\n  });\r\n  view.__templateVar = templateVar;\r\n  view.onCreated(function () {\r\n    this.autorun(function () {\r\n      templateVar.set(templateOrFunction());\r\n    });\r\n  });\r\n\r\n  return view;\r\n};\r\n\r\n// Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.\r\n// If `bar` and `baz` are functions, they are called before\r\n// `foo` is called on them.\r\n//\r\n// This is the shared part of Spacebars.mustache and\r\n// Spacebars.attrMustache, which differ in how they post-process the\r\n// result.\r\nSpacebars.mustacheImpl = function (value/*, args*/) {\r\n  var args = arguments;\r\n  // if we have any arguments (pos or kw), add an options argument\r\n  // if there isn't one.\r\n  if (args.length > 1) {\r\n    var kw = args[args.length - 1];\r\n    if (! (kw instanceof Spacebars.kw)) {\r\n      kw = Spacebars.kw();\r\n      // clone arguments into an actual array, then push\r\n      // the empty kw object.\r\n      args = Array.prototype.slice.call(arguments);\r\n      args.push(kw);\r\n    } else {\r\n      // For each keyword arg, call it if it's a function\r\n      var newHash = {};\r\n      for (var k in kw.hash) {\r\n        var v = kw.hash[k];\r\n        newHash[k] = (typeof v === 'function' ? v() : v);\r\n      }\r\n      args[args.length - 1] = Spacebars.kw(newHash);\r\n    }\r\n  }\r\n\r\n  return Spacebars.call.apply(null, args);\r\n};\r\n\r\nSpacebars.mustache = function (value/*, args*/) {\r\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\r\n\r\n  if (result instanceof Spacebars.SafeString)\r\n    return HTML.Raw(result.toString());\r\n  else\r\n    // map `null`, `undefined`, and `false` to null, which is important\r\n    // so that attributes with nully values are considered absent.\r\n    // stringify anything else (e.g. strings, booleans, numbers including 0).\r\n    return (result == null || result === false) ? null : String(result);\r\n};\r\n\r\nSpacebars.attrMustache = function (value/*, args*/) {\r\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\r\n\r\n  if (result == null || result === '') {\r\n    return null;\r\n  } else if (typeof result === 'object') {\r\n    return result;\r\n  } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {\r\n    var obj = {};\r\n    obj[result] = '';\r\n    return obj;\r\n  } else {\r\n    throw new Error(\"Expected valid attribute name, '', null, or object\");\r\n  }\r\n};\r\n\r\nSpacebars.dataMustache = function (value/*, args*/) {\r\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\r\n\r\n  return result;\r\n};\r\n\r\n// Idempotently wrap in `HTML.Raw`.\r\n//\r\n// Called on the return value from `Spacebars.mustache` in case the\r\n// template uses triple-stache (`{{{foo bar baz}}}`).\r\nSpacebars.makeRaw = function (value) {\r\n  if (value == null) // null or undefined\r\n    return null;\r\n  else if (value instanceof HTML.Raw)\r\n    return value;\r\n  else\r\n    return HTML.Raw(value);\r\n};\r\n\r\n// If `value` is a function, called it on the `args`, after\r\n// evaluating the args themselves (by calling them if they are\r\n// functions).  Otherwise, simply return `value` (and assert that\r\n// there are no args).\r\nSpacebars.call = function (value/*, args*/) {\r\n  if (typeof value === 'function') {\r\n    // evaluate arguments if they are functions (by calling them)\r\n    var newArgs = [];\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var arg = arguments[i];\r\n      newArgs[i-1] = (typeof arg === 'function' ? arg() : arg);\r\n    }\r\n\r\n    return value.apply(null, newArgs);\r\n  } else {\r\n    if (arguments.length > 1)\r\n      throw new Error(\"Can't call non-function: \" + value);\r\n\r\n    return value;\r\n  }\r\n};\r\n\r\n// Call this as `Spacebars.kw({ ... })`.  The return value\r\n// is `instanceof Spacebars.kw`.\r\nSpacebars.kw = function (hash) {\r\n  if (! (this instanceof Spacebars.kw))\r\n    // called without new; call with new\r\n    return new Spacebars.kw(hash);\r\n\r\n  this.hash = hash || {};\r\n};\r\n\r\n// Call this as `Spacebars.SafeString(\"some HTML\")`.  The return value\r\n// is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).\r\nSpacebars.SafeString = function (html) {\r\n  if (! (this instanceof Spacebars.SafeString))\r\n    // called without new; call with new\r\n    return new Spacebars.SafeString(html);\r\n\r\n  return new Handlebars.SafeString(html);\r\n};\r\nSpacebars.SafeString.prototype = Handlebars.SafeString.prototype;\r\n\r\n// `Spacebars.dot(foo, \"bar\", \"baz\")` performs a special kind\r\n// of `foo.bar.baz` that allows safe indexing of `null` and\r\n// indexing of functions (which calls the function).  If the\r\n// result is a function, it is always a bound function (e.g.\r\n// a wrapped version of `baz` that always uses `foo.bar` as\r\n// `this`).\r\n//\r\n// In `Spacebars.dot(foo, \"bar\")`, `foo` is assumed to be either\r\n// a non-function value or a \"fully-bound\" function wrapping a value,\r\n// where fully-bound means it takes no arguments and ignores `this`.\r\n//\r\n// `Spacebars.dot(foo, \"bar\")` performs the following steps:\r\n//\r\n// * If `foo` is falsy, return `foo`.\r\n//\r\n// * If `foo` is a function, call it (set `foo` to `foo()`).\r\n//\r\n// * If `foo` is falsy now, return `foo`.\r\n//\r\n// * Return `foo.bar`, binding it to `foo` if it's a function.\r\nSpacebars.dot = function (value, id1/*, id2, ...*/) {\r\n  if (arguments.length > 2) {\r\n    // Note: doing this recursively is probably less efficient than\r\n    // doing it in an iterative loop.\r\n    var argsForRecurse = [];\r\n    argsForRecurse.push(Spacebars.dot(value, id1));\r\n    argsForRecurse.push.apply(argsForRecurse,\r\n                              Array.prototype.slice.call(arguments, 2));\r\n    return Spacebars.dot.apply(null, argsForRecurse);\r\n  }\r\n\r\n  if (typeof value === 'function')\r\n    value = value();\r\n\r\n  if (! value)\r\n    return value; // falsy, don't index, pass through\r\n\r\n  var result = value[id1];\r\n  if (typeof result !== 'function')\r\n    return result;\r\n  // `value[id1]` (or `value()[id1]`) is a function.\r\n  // Bind it so that when called, `value` will be placed in `this`.\r\n  return function (/*arguments*/) {\r\n    return result.apply(value, arguments);\r\n  };\r\n};\r\n\r\nSpacebars.TemplateWith = function (argFunc, contentBlock) {\r\n  var w;\r\n\r\n  // This is a little messy.  When we compile `{{> UI.contentBlock}}`, we\r\n  // wrap it in Blaze.InOuterTemplateScope in order to skip the intermediate\r\n  // parent Views in the current template.  However, when there's an argument\r\n  // (`{{> UI.contentBlock arg}}`), the argument needs to be evaluated\r\n  // in the original scope.  There's no good order to nest\r\n  // Blaze.InOuterTemplateScope and Spacebars.TemplateWith to achieve this,\r\n  // so we wrap argFunc to run it in the \"original parentView\" of the\r\n  // Blaze.InOuterTemplateScope.\r\n  //\r\n  // To make this better, reconsider InOuterTemplateScope as a primitive.\r\n  // Longer term, evaluate expressions in the proper lexical scope.\r\n  var wrappedArgFunc = function () {\r\n    var viewToEvaluateArg = null;\r\n    if (w.parentView && w.parentView.kind === 'InOuterTemplateScope') {\r\n      viewToEvaluateArg = w.parentView.originalParentView;\r\n    }\r\n    if (viewToEvaluateArg) {\r\n      return Blaze.withCurrentView(viewToEvaluateArg, argFunc);\r\n    } else {\r\n      return argFunc();\r\n    }\r\n  };\r\n\r\n  w = Blaze.With(wrappedArgFunc, contentBlock);\r\n  w.__isTemplateWith = true;\r\n  return w;\r\n};\r\n\r\n// Spacebars.With implements the conditional logic of rendering\r\n// the `{{else}}` block if the argument is falsy.  It combines\r\n// a Blaze.If with a Blaze.With (the latter only in the truthy\r\n// case, since the else block is evaluated without entering\r\n// a new data context).\r\nSpacebars.With = function (argFunc, contentFunc, elseFunc) {\r\n  var argVar = new Blaze.ReactiveVar;\r\n  var view = Blaze.View('Spacebars_with', function () {\r\n    return Blaze.If(function () { return argVar.get(); },\r\n                    function () { return Blaze.With(function () {\r\n                      return argVar.get(); }, contentFunc); },\r\n                    elseFunc);\r\n  });\r\n  view.onCreated(function () {\r\n    this.autorun(function () {\r\n      argVar.set(argFunc());\r\n\r\n      // This is a hack so that autoruns inside the body\r\n      // of the #with get stopped sooner.  It reaches inside\r\n      // our ReactiveVar to access its dep.\r\n\r\n      Deps.onInvalidate(function () {\r\n        argVar.dep.changed();\r\n      });\r\n\r\n      // Take the case of `{{#with A}}{{B}}{{/with}}`.  The goal\r\n      // is to not re-render `B` if `A` changes to become falsy\r\n      // and `B` is simultaneously invalidated.\r\n      //\r\n      // A series of autoruns are involved:\r\n      //\r\n      // 1. This autorun (argument to Spacebars.With)\r\n      // 2. Argument to Blaze.If\r\n      // 3. Blaze.If view re-render\r\n      // 4. Argument to Blaze.With\r\n      // 5. The template tag `{{B}}`\r\n      //\r\n      // When (3) is invalidated, it immediately stops (4) and (5)\r\n      // because of a Deps.onInvalidate built into materializeView.\r\n      // (When a View's render method is invalidated, it immediately\r\n      // tears down all the subviews, via a Deps.onInvalidate much\r\n      // like this one.\r\n      //\r\n      // Suppose `A` changes to become falsy, and `B` changes at the\r\n      // same time (i.e. without an intervening flush).\r\n      // Without the code above, this happens:\r\n      //\r\n      // - (1) and (5) are invalidated.\r\n      // - (1) runs, invalidating (2) and (4).\r\n      // - (5) runs.\r\n      // - (2) runs, invalidating (3), stopping (4) and (5).\r\n      //\r\n      // With the code above:\r\n      //\r\n      // - (1) and (5) are invalidated, invalidating (2) and (4).\r\n      // - (1) runs.\r\n      // - (2) runs, invalidating (3), stopping (4) and (5).\r\n      //\r\n      // If the re-run of (5) is originally enqueued before (1), all\r\n      // bets are off, but typically that doesn't seem to be the\r\n      // case.  Anyway, doing this is always better than not doing it,\r\n      // because it might save a bunch of DOM from being updated\r\n      // needlessly.\r\n    });\r\n  });\r\n\r\n  return view;\r\n};\r\n"]}