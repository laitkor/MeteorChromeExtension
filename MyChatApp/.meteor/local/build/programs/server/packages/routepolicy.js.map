{"version":3,"file":"\\packages\\routepolicy.js","sources":["routepolicy/routepolicy.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,kE;AACA,qE;AACA,mE;AACA,qC;AACA,E;AACA,sE;AACA,mE;AACA,2C;AACA,E;AACA,+E;AACA,E;AACA,qE;AACA,iE;AACA,+D;AACA,E;AACA,sE;AACA,iE;AACA,mE;AACA,sE;AACA,+D;;AAEA,mE;AACA,mE;AACA,iE;AACA,2B;;AAEA,qB;;AAEA,wE;AACA,kB;AACA,2B;AACA,E;;AAEA,4C;;AAEA,+C;AACA,yD;AACA,I;;AAEA,8B;AACA,yD;AACA,mE;AACA,gB;AACA,I;;AAEA,8C;AACA,oB;;AAEA,oC;AACA,0D;;AAEA,0B;AACA,8C;;AAEA,sD;AACA,8C;AACA,8G;;AAEA,gB;AACA,I;;AAEA,yE;AACA,oB;AACA,iC;AACA,kB;AACA,iD;AACA,+C;AACA,2D;AACA,wD;AACA,6D;AACA,2D;AACA,4B;AACA,kB;AACA,K;AACA,kB;AACA,wE;AACA,yD;AACA,2C;AACA,4C;AACA,8D;AACA,O;AACA,iB;AACA,sE;AACA,4C;AACA,Q;AACA,kB;AACA,I;;AAEA,uC;AACA,oB;AACA,yC;AACA,yD;AACA,mE;AACA,gB;AACA,+B;AACA,0D;AACA,0C;AACA,I;;AAEA,4B;AACA,oB;AACA,8B;AACA,4D;AACA,yE;AACA,iD;AACA,O;AACA,e;AACA,yC;AACA,Q;AACA,kB;AACA,I;;AAEA,mC;AACA,oB;AACA,sB;AACA,2D;AACA,yB;AACA,+B;AACA,O;AACA,2B;AACA,G;AACA,G;;AAEA,2C","sourcesContent":["// In addition to listing specific files to be cached, the browser\r\n// application cache manifest allows URLs to be designated as NETWORK\r\n// (always fetched from the Internet) and FALLBACK (which we use to\r\n// serve app HTML on arbitrary URLs).\r\n//\r\n// The limitation of the manifest file format is that the designations\r\n// are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"\r\n// will also be treated as a network route.\r\n//\r\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:\r\n//\r\n// \"network\": for network routes that should not conflict with static\r\n// resources.  (For example, if \"/sockjs/\" is a network route, we\r\n// shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).\r\n//\r\n// \"static-online\": for static resources which should not be cached in\r\n// the app cache.  This is implemented by also adding them to the\r\n// NETWORK section (as otherwise the browser would receive app HTML\r\n// for them because of the FALLBACK section), but static-online routes\r\n// don't need to be checked for conflict with static resources.\r\n\r\n// The route policy is a singleton in a running application, but we\r\n// can't unit test the real singleton because messing with the real\r\n// routes would break tinytest... so allow policy instances to be\r\n// constructed for testing.\r\n\r\nRoutePolicyTest = {};\r\n\r\nvar RoutePolicyConstructor = RoutePolicyTest.Constructor = function () {\r\n  var self = this;\r\n  self.urlPrefixTypes = {};\r\n};\r\n\r\n_.extend(RoutePolicyConstructor.prototype, {\r\n\r\n  urlPrefixMatches: function (urlPrefix, url) {\r\n    return url.substr(0, urlPrefix.length) === urlPrefix;\r\n  },\r\n\r\n  checkType: function (type) {\r\n    if (! _.contains(['network', 'static-online'], type))\r\n      return 'the route type must be \"network\" or \"static-online\"';\r\n    return null;\r\n  },\r\n\r\n  checkUrlPrefix: function (urlPrefix, type) {\r\n    var self = this;\r\n\r\n    if (urlPrefix.charAt(0) !== '/')\r\n      return 'a route URL prefix must begin with a slash';\r\n\r\n    if (urlPrefix === '/')\r\n      return 'a route URL prefix cannot be /';\r\n\r\n    var existingType = self.urlPrefixTypes[urlPrefix];\r\n    if (existingType && existingType !== type)\r\n      return 'the route URL prefix ' + urlPrefix + ' has already been declared to be of type ' + existingType;\r\n\r\n    return null;\r\n  },\r\n\r\n  checkForConflictWithStatic: function (urlPrefix, type, _testManifest) {\r\n    var self = this;\r\n    if (type === 'static-online')\r\n      return null;\r\n    if (!Package.webapp || !Package.webapp.WebApp\r\n        || !Package.webapp.WebApp.clientProgram\r\n        || !Package.webapp.WebApp.clientProgram.manifest) {\r\n      // Hack: If we don't have a manifest, deal with it\r\n      // gracefully. This lets us load livedata into a nodejs\r\n      // environment that doesn't have a HTTP server (eg, a\r\n      // command-line tool).\r\n      return null;\r\n    }\r\n    var manifest =\r\n          _testManifest || Package.webapp.WebApp.clientProgram.manifest;\r\n    var conflict = _.find(manifest, function (resource) {\r\n      return (resource.type === 'static' &&\r\n              resource.where === 'client' &&\r\n              self.urlPrefixMatches(urlPrefix, resource.url));\r\n    });\r\n    if (conflict)\r\n      return ('static resource ' + conflict.url + ' conflicts with ' +\r\n              type + ' route ' + urlPrefix);\r\n    else\r\n      return null;\r\n  },\r\n\r\n  declare: function (urlPrefix, type) {\r\n    var self = this;\r\n    var problem = self.checkType(type) ||\r\n                  self.checkUrlPrefix(urlPrefix, type) ||\r\n                  self.checkForConflictWithStatic(urlPrefix, type);\r\n    if (problem)\r\n      throw new Error(problem);\r\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\r\n    self.urlPrefixTypes[urlPrefix] = type;\r\n  },\r\n\r\n  classify: function (url) {\r\n    var self = this;\r\n    if (url.charAt(0) !== '/')\r\n      throw new Error('url must be a relative URL: ' + url);\r\n    var prefix = _.find(_.keys(self.urlPrefixTypes), function (_prefix) {\r\n      return self.urlPrefixMatches(_prefix, url);\r\n    });\r\n    if (prefix)\r\n      return self.urlPrefixTypes[prefix];\r\n    else\r\n      return null;\r\n  },\r\n\r\n  urlPrefixesFor: function (type) {\r\n    var self = this;\r\n    var prefixes = [];\r\n    _.each(self.urlPrefixTypes, function (_type, _prefix) {\r\n      if (_type === type)\r\n        prefixes.push(_prefix);\r\n    });\r\n    return prefixes.sort();\r\n  }\r\n});\r\n\r\nRoutePolicy = new RoutePolicyConstructor();\r\n"]}