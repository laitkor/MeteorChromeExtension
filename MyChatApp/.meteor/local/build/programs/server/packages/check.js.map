{"version":3,"file":"\\packages\\check.js","sources":["check/match.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,W;;AAEA,uC;AACA,2B;;AAEA,4D;;AAEA,mC;AACA,qD;AACA,I;AACA,mE;AACA,0E;AACA,sE;AACA,wE;AACA,yE;AACA,8D;AACA,oE;AACA,iB;AACA,+B;AACA,O;AACA,iC;AACA,iB;AACA,iD;AACA,6C;AACA,c;AACA,G;AACA,E;;AAEA,S;AACA,gC;AACA,iC;AACA,I;AACA,mC;AACA,2C;AACA,I;AACA,mB;AACA,+B;AACA,gC;AACA,I;AACA,uC;AACA,wC;AACA,I;AACA,wC;AACA,2B;;AAEA,mE;AACA,6D;AACA,yC;AACA,6E;AACA,gF;AACA,a;AACA,qC;AACA,mB;AACA,gF;AACA,+D;AACA,gE;AACA,K;;AAEA,gF;AACA,8E;AACA,oD;AACA,gF;AACA,4E;AACA,+E;AACA,mC;AACA,S;AACA,mC;AACA,kB;AACA,iB;AACA,mC;AACA,qB;AACA,8B;AACA,c;AACA,K;AACA,I;;AAEA,gF;AACA,gF;AACA,0C;AACA,I;AACA,8E;AACA,4D;AACA,2E;AACA,oC;AACA,O;AACA,2E;AACA,wD;AACA,kB;AACA,G;AACA,E;;AAEA,mC;AACA,yB;AACA,E;;AAEA,gC;AACA,yB;AACA,uE;AACA,yB;AACA,E;;AAEA,kC;AACA,6B;AACA,E;;AAEA,0C;AACA,yB;AACA,E;;AAEA,oB;AACA,qB;AACA,qB;AACA,uB;AACA,uE;AACA,0B;AACA,0B;AACA,E;;AAEA,8C;AACA,oB;AACA,4B;AACA,W;;AAEA,wB;AACA,sD;AACA,iD;AACA,yC;AACA,8C;AACA,e;AACA,yE;AACA,0C;AACA,K;AACA,G;AACA,yB;AACA,uB;AACA,a;AACA,0E;AACA,G;;AAEA,qD;AACA,kC;AACA,+E;AACA,gF;AACA,uE;AACA,kD;AACA,6E;AACA,oD;AACA,2D;AACA,Y;AACA,kD;AACA,8E;AACA,G;;AAEA,yD;AACA,yB;AACA,wC;;AAEA,iE;AACA,iC;AACA,6B;AACA,oE;AACA,4C;AACA,qD;AACA,6E;AACA,K;;AAEA,kD;AACA,W;AACA,+C;AACA,qB;AACA,yC;AACA,mD;AACA,S;AACA,kB;AACA,O;AACA,O;AACA,W;AACA,G;;AAEA,2E;AACA,6D;AACA,iC;AACA,iC;AACA,a;AACA,iC;AACA,2D;AACA,G;;;AAGA,kC;AACA,sD;;AAEA,iC;AACA,sD;AACA,W;AACA,gD;AACA,iC;AACA,e;AACA,qB;AACA,4E;AACA,kB;AACA,0C;AACA,oB;AACA,O;AACA,K;AACA,iC;AACA,6E;AACA,G;;AAEA,uE;AACA,iB;AACA,oC;AACA,iC;AACA,a;AACA,sC;AACA,sD;AACA,G;;AAEA,iC;AACA,2C;AACA,8B;AACA,8B;AACA,G;;AAEA,kC;AACA,qD;;AAEA,2E;AACA,6E;AACA,+D;AACA,gC;AACA,kE;AACA,qB;AACA,uD;AACA,mC;AACA,mD;;AAEA,4B;AACA,4B;AACA,8C;AACA,uC;AACA,iD;AACA,Q;AACA,yC;AACA,K;;AAEA,0C;AACA,S;AACA,yC;AACA,sD;AACA,qC;AACA,gD;AACA,sD;AACA,c;AACA,gC;AACA,+C;AACA,O;AACA,mB;AACA,qC;AACA,+C;AACA,gB;AACA,K;AACA,K;;AAEA,uD;AACA,uD;AACA,K;AACA,E;;AAEA,oD;AACA,kB;AACA,0E;AACA,2B;AACA,4B;AACA,6E;AACA,4E;AACA,+B;AACA,sB;AACA,iC;AACA,E;;AAEA,qC;AACA,8B;AACA,oB;AACA,sC;AACA,a;AACA,8E;AACA,0E;AACA,0B;AACA,mD;AACA,0D;AACA,K;AACA,I;AACA,uC;AACA,oB;AACA,gD;AACA,+E;AACA,4E;AACA,gB;AACA,mC;AACA,+B;AACA,oB;AACA,O;AACA,K;AACA,iB;AACA,I;AACA,uD;AACA,oB;AACA,8B;AACA,+D;AACA,wC;AACA,G;AACA,G;;AAEA,+E;AACA,0E;AACA,yE;AACA,uE;AACA,8E;AACA,8E;AACA,gB;;AAEA,uD;AACA,qB;AACA,yC;AACA,yD;AACA,0B;AACA,+E;AACA,gC;;AAEA,8B;AACA,4B;AACA,oB;AACA,E","sourcesContent":["// XXX docs\r\n\r\n// Things we explicitly do NOT support:\r\n//    - heterogenous arrays\r\n\r\nvar currentArgumentChecker = new Meteor.EnvironmentVariable;\r\n\r\ncheck = function (value, pattern) {\r\n  // Record that check got called, if somebody cared.\r\n  //\r\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\r\n  // from non-Fiber server contexts; the downside is that if you forget to\r\n  // bindEnvironment on some random callback in your method/publisher,\r\n  // it might not find the argumentChecker and you'll get an error about\r\n  // not checking an argument that it looks like you're checking (instead\r\n  // of just getting a \"Node code must run in a Fiber\" error).\r\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\r\n  if (argChecker)\r\n    argChecker.checking(value);\r\n  try {\r\n    checkSubtree(value, pattern);\r\n  } catch (err) {\r\n    if ((err instanceof Match.Error) && err.path)\r\n      err.message += \" in field \" + err.path;\r\n    throw err;\r\n  }\r\n};\r\n\r\nMatch = {\r\n  Optional: function (pattern) {\r\n    return new Optional(pattern);\r\n  },\r\n  OneOf: function (/*arguments*/) {\r\n    return new OneOf(_.toArray(arguments));\r\n  },\r\n  Any: ['__any__'],\r\n  Where: function (condition) {\r\n    return new Where(condition);\r\n  },\r\n  ObjectIncluding: function (pattern) {\r\n    return new ObjectIncluding(pattern);\r\n  },\r\n  // Matches only signed 32-bit integers\r\n  Integer: ['__integer__'],\r\n\r\n  // XXX matchers should know how to describe themselves for errors\r\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {\r\n    this.message = \"Match error: \" + msg;\r\n    // The path of the value that failed to match. Initially empty, this gets\r\n    // populated by catching and rethrowing the exception as it goes back up the\r\n    // stack.\r\n    // E.g.: \"vals[3].entity.created\"\r\n    this.path = \"\";\r\n    // If this gets sent over DDP, don't give full internal details but at least\r\n    // provide something better than 500 Internal server error.\r\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");\r\n  }),\r\n\r\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\r\n  // or false (unless an error other than Match.Error was thrown). It does not\r\n  // interact with _failIfArgumentsAreNotAllChecked.\r\n  // XXX maybe also implement a Match.match which returns more information about\r\n  //     failures but without using exception handling or doing what check()\r\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\r\n  test: function (value, pattern) {\r\n    try {\r\n      checkSubtree(value, pattern);\r\n      return true;\r\n    } catch (e) {\r\n      if (e instanceof Match.Error)\r\n        return false;\r\n      // Rethrow other errors.\r\n      throw e;\r\n    }\r\n  },\r\n\r\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\r\n  // `args` (either directly or in the first level of an array), throws an error\r\n  // (using `description` in the message).\r\n  //\r\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {\r\n    var argChecker = new ArgumentChecker(args, description);\r\n    var result = currentArgumentChecker.withValue(argChecker, function () {\r\n      return f.apply(context, args);\r\n    });\r\n    // If f didn't itself throw, make sure it checked all of its arguments.\r\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\r\n    return result;\r\n  }\r\n};\r\n\r\nvar Optional = function (pattern) {\r\n  this.pattern = pattern;\r\n};\r\n\r\nvar OneOf = function (choices) {\r\n  if (_.isEmpty(choices))\r\n    throw new Error(\"Must provide at least one choice to Match.OneOf\");\r\n  this.choices = choices;\r\n};\r\n\r\nvar Where = function (condition) {\r\n  this.condition = condition;\r\n};\r\n\r\nvar ObjectIncluding = function (pattern) {\r\n  this.pattern = pattern;\r\n};\r\n\r\nvar typeofChecks = [\r\n  [String, \"string\"],\r\n  [Number, \"number\"],\r\n  [Boolean, \"boolean\"],\r\n  // While we don't allow undefined in EJSON, this is good for optional\r\n  // arguments with OneOf.\r\n  [undefined, \"undefined\"]\r\n];\r\n\r\nvar checkSubtree = function (value, pattern) {\r\n  // Match anything!\r\n  if (pattern === Match.Any)\r\n    return;\r\n\r\n  // Basic atomic types.\r\n  // Do not match boxed objects (e.g. String, Boolean)\r\n  for (var i = 0; i < typeofChecks.length; ++i) {\r\n    if (pattern === typeofChecks[i][0]) {\r\n      if (typeof value === typeofChecks[i][1])\r\n        return;\r\n      throw new Match.Error(\"Expected \" + typeofChecks[i][1] + \", got \" +\r\n                            typeof value);\r\n    }\r\n  }\r\n  if (pattern === null) {\r\n    if (value === null)\r\n      return;\r\n    throw new Match.Error(\"Expected null, got \" + EJSON.stringify(value));\r\n  }\r\n\r\n  // Match.Integer is special type encoded with array\r\n  if (pattern === Match.Integer) {\r\n    // There is no consistent and reliable way to check if variable is a 64-bit\r\n    // integer. One of the popular solutions is to get reminder of division by 1\r\n    // but this method fails on really large floats with big precision.\r\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\r\n    // Bitwise operators work consistantly but always cast variable to 32-bit\r\n    // signed integer according to JavaScript specs.\r\n    if (typeof value === \"number\" && (value | 0) === value)\r\n      return\r\n    throw new Match.Error(\"Expected Integer, got \"\r\n                + (value instanceof Object ? EJSON.stringify(value) : value));\r\n  }\r\n\r\n  // \"Object\" is shorthand for Match.ObjectIncluding({});\r\n  if (pattern === Object)\r\n    pattern = Match.ObjectIncluding({});\r\n\r\n  // Array (checked AFTER Any, which is implemented as an Array).\r\n  if (pattern instanceof Array) {\r\n    if (pattern.length !== 1)\r\n      throw Error(\"Bad pattern: arrays must have one type element\" +\r\n                  EJSON.stringify(pattern));\r\n    if (!_.isArray(value) && !_.isArguments(value)) {\r\n      throw new Match.Error(\"Expected array, got \" + EJSON.stringify(value));\r\n    }\r\n\r\n    _.each(value, function (valueElement, index) {\r\n      try {\r\n        checkSubtree(valueElement, pattern[0]);\r\n      } catch (err) {\r\n        if (err instanceof Match.Error) {\r\n          err.path = _prependPath(index, err.path);\r\n        }\r\n        throw err;\r\n      }\r\n    });\r\n    return;\r\n  }\r\n\r\n  // Arbitrary validation checks. The condition can return false or throw a\r\n  // Match.Error (ie, it can internally use check()) to fail.\r\n  if (pattern instanceof Where) {\r\n    if (pattern.condition(value))\r\n      return;\r\n    // XXX this error is terrible\r\n    throw new Match.Error(\"Failed Match.Where validation\");\r\n  }\r\n\r\n\r\n  if (pattern instanceof Optional)\r\n    pattern = Match.OneOf(undefined, pattern.pattern);\r\n\r\n  if (pattern instanceof OneOf) {\r\n    for (var i = 0; i < pattern.choices.length; ++i) {\r\n      try {\r\n        checkSubtree(value, pattern.choices[i]);\r\n        // No error? Yay, return.\r\n        return;\r\n      } catch (err) {\r\n        // Other errors should be thrown. Match errors just mean try another\r\n        // choice.\r\n        if (!(err instanceof Match.Error))\r\n          throw err;\r\n      }\r\n    }\r\n    // XXX this error is terrible\r\n    throw new Match.Error(\"Failed Match.OneOf or Match.Optional validation\");\r\n  }\r\n\r\n  // A function that isn't something we special-case is assumed to be a\r\n  // constructor.\r\n  if (pattern instanceof Function) {\r\n    if (value instanceof pattern)\r\n      return;\r\n    // XXX what if .name isn't defined\r\n    throw new Match.Error(\"Expected \" + pattern.name);\r\n  }\r\n\r\n  var unknownKeysAllowed = false;\r\n  if (pattern instanceof ObjectIncluding) {\r\n    unknownKeysAllowed = true;\r\n    pattern = pattern.pattern;\r\n  }\r\n\r\n  if (typeof pattern !== \"object\")\r\n    throw Error(\"Bad pattern: unknown pattern type\");\r\n\r\n  // An object, with required and optional keys. Note that this does NOT do\r\n  // structural matches against objects of special types that happen to match\r\n  // the pattern: this really needs to be a plain old {Object}!\r\n  if (typeof value !== 'object')\r\n    throw new Match.Error(\"Expected object, got \" + typeof value);\r\n  if (value === null)\r\n    throw new Match.Error(\"Expected object, got null\");\r\n  if (value.constructor !== Object)\r\n    throw new Match.Error(\"Expected plain object\");\r\n\r\n  var requiredPatterns = {};\r\n  var optionalPatterns = {};\r\n  _.each(pattern, function (subPattern, key) {\r\n    if (subPattern instanceof Optional)\r\n      optionalPatterns[key] = subPattern.pattern;\r\n    else\r\n      requiredPatterns[key] = subPattern;\r\n  });\r\n\r\n  _.each(value, function (subValue, key) {\r\n    try {\r\n      if (_.has(requiredPatterns, key)) {\r\n        checkSubtree(subValue, requiredPatterns[key]);\r\n        delete requiredPatterns[key];\r\n      } else if (_.has(optionalPatterns, key)) {\r\n        checkSubtree(subValue, optionalPatterns[key]);\r\n      } else {\r\n        if (!unknownKeysAllowed)\r\n          throw new Match.Error(\"Unknown key\");\r\n      }\r\n    } catch (err) {\r\n      if (err instanceof Match.Error)\r\n        err.path = _prependPath(key, err.path);\r\n      throw err;\r\n    }\r\n  });\r\n\r\n  _.each(requiredPatterns, function (subPattern, key) {\r\n    throw new Match.Error(\"Missing key '\" + key + \"'\");\r\n  });\r\n};\r\n\r\nvar ArgumentChecker = function (args, description) {\r\n  var self = this;\r\n  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\r\n  // against its contents.)\r\n  self.args = _.clone(args);\r\n  // Since the common case will be to check arguments in order, and we splice\r\n  // out arguments when we check them, make it so we splice out from the end\r\n  // rather than the beginning.\r\n  self.args.reverse();\r\n  self.description = description;\r\n};\r\n\r\n_.extend(ArgumentChecker.prototype, {\r\n  checking: function (value) {\r\n    var self = this;\r\n    if (self._checkingOneValue(value))\r\n      return;\r\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\r\n    // or check([foo, bar], [String]) to count... but only if value wasn't\r\n    // itself an argument.\r\n    if (_.isArray(value) || _.isArguments(value)) {\r\n      _.each(value, _.bind(self._checkingOneValue, self));\r\n    }\r\n  },\r\n  _checkingOneValue: function (value) {\r\n    var self = this;\r\n    for (var i = 0; i < self.args.length; ++i) {\r\n      // Is this value one of the arguments? (This can have a false positive if\r\n      // the argument is an interned primitive, but it's still a good enough\r\n      // check.)\r\n      if (value === self.args[i]) {\r\n        self.args.splice(i, 1);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  },\r\n  throwUnlessAllArgumentsHaveBeenChecked: function () {\r\n    var self = this;\r\n    if (!_.isEmpty(self.args))\r\n      throw new Error(\"Did not check() all arguments during \" +\r\n                      self.description);\r\n  }\r\n});\r\n\r\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",\r\n  \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",\r\n  \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",\r\n  \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",\r\n  \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",\r\n  \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",\r\n  \"instanceof\"];\r\n\r\n// Assumes the base of path is already escaped properly\r\n// returns key + base\r\nvar _prependPath = function (key, base) {\r\n  if ((typeof key) === \"number\" || key.match(/^[0-9]+$/))\r\n    key = \"[\" + key + \"]\";\r\n  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))\r\n    key = JSON.stringify([key]);\r\n\r\n  if (base && base[0] !== \"[\")\r\n    return key + '.' + base;\r\n  return key + base;\r\n};\r\n\r\n"]}