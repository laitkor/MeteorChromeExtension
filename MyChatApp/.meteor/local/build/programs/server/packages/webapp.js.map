{"version":3,"file":"\\packages\\webapp.js","sources":["webapp/webapp_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8B;;AAEA,2B;AACA,+B;AACA,2B;AACA,+B;AACA,6B;AACA,mC;;AAEA,qC;AACA,yC;AACA,+B;;AAEA,kC;AACA,mC;;AAEA,Y;AACA,qB;;AAEA,uB;;AAEA,oE;AACA,sE;AACA,Y;AACA,6E;AACA,qE;;AAEA,iC;AACA,yB;;AAEA,4C;AACA,uB;AACA,K;;AAEA,yB;;AAEA,2B;AACA,sB;AACA,8B;AACA,2D;AACA,sB;AACA,K;AACA,W;AACA,E;;;AAGA,gC;AACA,uC;AACA,wB;AACA,4B;AACA,E;;AAEA,yB;AACA,E;AACA,iE;AACA,kE;AACA,+C;AACA,E;AACA,wE;AACA,+D;AACA,sE;AACA,kE;AACA,W;AACA,E;AACA,kD;AACA,uE;AACA,E;AACA,uE;AACA,iE;AACA,gE;AACA,E;AACA,6D;AACA,qD;AACA,E;AACA,8E;AACA,8E;AACA,8E;AACA,sB;AACA,E;AACA,uE;AACA,qE;AACA,8C;AACA,E;AACA,mE;AACA,W;;;AAGA,yC;AACA,iC;AACA,8B;AACA,oC;AACA,4C;AACA,qE;AACA,G;AACA,wB;AACA,E;;AAEA,kD;AACA,oD;AACA,U;AACA,sC;AACA,4B;AACA,4B;AACA,2B;AACA,I;AACA,E;;AAEA,qD;AACA,kD;;AAEA,2C;AACA,U;AACA,wD;AACA,iC;AACA,I;AACA,E;;AAEA,8E;AACA,gF;AACA,sD;AACA,4B;AACA,4C;AACA,+B;AACA,oD;AACA,mC;AACA,4B;AACA,a;AACA,uC;AACA,oE;AACA,6C;AACA,K;AACA,4B;AACA,E;AACA,+C;AACA,gC;AACA,E;;AAEA,+B;AACA,6B;AACA,sD;AACA,iB;;AAEA,kE;AACA,kE;AACA,oE;AACA,oE;AACA,8D;AACA,kD;AACA,8B;AACA,iB;;AAEA,iE;AACA,gC;AACA,iB;;AAEA,wD;AACA,c;AACA,E;;;AAGA,iE;AACA,qE;AACA,gB;AACA,E;AACA,+D;AACA,mE;AACA,2D;AACA,gB;;AAEA,uC;AACA,uC;AACA,iE;AACA,6D;AACA,uE;AACA,iC;AACA,iC;AACA,K;AACA,K;AACA,4B;AACA,E;;;AAGA,sE;AACA,+D;AACA,E;AACA,mE;AACA,sE;AACA,E;AACA,oE;AACA,sD;AACA,oE;AACA,oE;AACA,6C;AACA,qD;AACA,E;AACA,4D;AACA,oE;AACA,oB;;AAEA,4B;AACA,4C;AACA,G;;;;AAIA,4E;AACA,wE;AACA,yE;AACA,6E;AACA,iC;AACA,gE;AACA,oE;AACA,sC;AACA,gF;AACA,kC;AACA,gD;AACA,sE;AACA,mD;AACA,mC;AACA,gC;AACA,yC;AACA,K;AACA,iE;AACA,E;;AAEA,4C;AACA,2B;AACA,+B;AACA,6B;;AAEA,qE;AACA,+D;AACA,oE;AACA,qB;AACA,yC;AACA,kD;;AAEA,sE;AACA,mE;AACA,0D;AACA,uC;AACA,+C;AACA,kC;AACA,K;;AAEA,qD;AACA,oC;AACA,qC;AACA,kE;AACA,4B;;AAEA,+D;AACA,iE;AACA,G;AACA,6C;AACA,E;;AAEA,qD;AACA,qC;AACA,e;AACA,oE;AACA,4C;AACA,sE;AACA,4E;AACA,oD;AACA,W;AACA,W;AACA,G;AACA,sD;AACA,wC;AACA,oC;;AAEA,O;AACA,4C;AACA,e;AACA,W;AACA,W;AACA,G;;AAEA,oC;AACA,wB;AACA,6D;AACA,O;AACA,iB;AACA,c;AACA,I;;AAEA,iD;AACA,iD;AACA,kD;AACA,mE;AACA,W;AACA,mD;AACA,wD;AACA,gD;AACA,W;AACA,G;;AAEA,sC;AACA,W;AACA,W;AACA,G;;AAEA,4E;AACA,2E;AACA,Y;;AAEA,mC;;AAEA,kE;AACA,8D;AACA,kC;AACA,I;AACA,6E;AACA,8E;AACA,kE;AACA,8E;AACA,0E;AACA,0E;AACA,gD;AACA,6B;AACA,mC;AACA,8B;;AAEA,kE;AACA,uE;AACA,oC;AACA,I;AACA,6E;AACA,6C;AACA,I;AACA,yE;AACA,Y;AACA,gE;AACA,gE;AACA,gI;AACA,kE;AACA,qE;AACA,mE;AACA,4D;AACA,+D;AACA,oE;AACA,6D;AACA,I;AACA,yE;AACA,0E;AACA,I;AACA,4E;AACA,4C;AACA,0D;AACA,yE;AACA,sD;AACA,wB;AACA,oD;;AAEA,2B;AACA,2E;AACA,mC;AACA,6D;AACA,G;;AAEA,4C;AACA,mB;AACA,yE;AACA,iC;AACA,oD;AACA,yB;AACA,gB;AACA,M;AACA,kC;AACA,qD;AACA,yB;AACA,gB;AACA,M;AACA,e;AACA,E;;AAEA,mC;AACA,2B;AACA,wD;AACA,gE;AACA,yE;AACA,+C;AACA,uE;;AAEA,mD;AACA,8D;AACA,uD;;AAEA,c;AACA,sB;;AAEA,iD;AACA,8B;;AAEA,wE;AACA,4C;AACA,qC;AACA,8B;;AAEA,6C;AACA,8C;AACA,oE;AACA,oD;AACA,gC;AACA,6E;AACA,+D;AACA,gF;AACA,4C;AACA,mF;AACA,6D;AACA,a;AACA,2E;AACA,a;AACA,4B;AACA,8B;AACA,qC;AACA,qB;AACA,Y;AACA,a;AACA,K;AACA,K;;AAEA,0E;AACA,6B;AACA,2B;;AAEA,4C;AACA,2D;AACA,I;;AAEA,uB;AACA,+C;AACA,8C;AACA,gD;AACA,wB;AACA,kC;AACA,sC;AACA,wC;AACA,uB;AACA,Q;;AAEA,2B;AACA,2E;AACA,qC;AACA,2D;AACA,+B;AACA,yB;AACA,U;AACA,O;AACA,K;AACA,K;;AAEA,wB;AACA,4C;;;AAGA,0C;AACA,iD;AACA,qC;AACA,kD;AACA,+B;AACA,0B;AACA,uB;AACA,K;;AAEA,2E;AACA,kD;AACA,wC;AACA,iC;;AAEA,oC;AACA,+E;AACA,+E;AACA,mC;AACA,0C;AACA,6E;AACA,gB;AACA,a;AACA,K;AACA,gE;AACA,gC;AACA,K;;AAEA,qC;AACA,0B;AACA,oB;;AAEA,yB;AACA,yE;AACA,6B;AACA,6E;;AAEA,mB;AACA,iD;AACA,M;AACA,qB;AACA,sC;;AAEA,gD;;AAEA,wE;AACA,6E;AACA,gF;AACA,8D;AACA,0D;AACA,kC;AACA,8D;AACA,gB;AACA,uB;AACA,K;;AAEA,oB;AACA,S;AACA,4C;AACA,iB;AACA,gD;AACA,kC;AACA,gB;AACA,uB;AACA,K;;AAEA,gC;AACA,2B;AACA,c;AACA,qB;AACA,K;;AAEA,gE;AACA,+B;AACA,uB;AACA,c;AACA,K;;;AAGA,0C;AACA,gC;;AAEA,0E;AACA,+E;AACA,mC;AACA,8C;;AAEA,sE;AACA,gF;AACA,S;AACA,qE;;;AAGA,4E;AACA,0B;AACA,2D;AACA,wB;AACA,mE;AACA,4E;AACA,kB;AACA,sC;;AAEA,yD;AACA,kB;AACA,a;AACA,qE;AACA,qB;AACA,6D;AACA,0B;AACA,S;AACA,O;AACA,sB;;AAEA,uC;;AAEA,8C;AACA,mC;AACA,wF;AACA,sB;AACA,a;;AAEA,qB;AACA,qB;AACA,oB;AACA,M;;AAEA,iB;AACA,oB;AACA,2C;AACA,2C;AACA,2B;AACA,sD;AACA,oB;AACA,mC;AACA,8E;AACA,oB;AACA,M;AACA,mB;AACA,wC;AACA,mC;AACA,M;AACA,+B;AACA,+B;AACA,qC;AACA,U;AACA,Y;AACA,M;AACA,2E;AACA,8E;AACA,6D;AACA,oC;AACA,K;;AAEA,2E;AACA,gF;AACA,2B;AACA,0B;AACA,8E;AACA,8D;AACA,mE;AACA,2E;AACA,8E;AACA,4C;AACA,2D;;AAEA,2B;AACA,sE;AACA,iE;AACA,iB;AACA,c;AACA,a;AACA,e;AACA,e;AACA,gC;AACA,2B;AACA,uC;AACA,kB;AACA,+B;AACA,8B;AACA,Y;AACA,S;AACA,Q;AACA,qE;AACA,8E;AACA,+C;AACA,4D;AACA,M;;AAEA,2D;AACA,2D;AACA,sD;AACA,O;AACA,0D;AACA,qD;AACA,O;AACA,iC;AACA,mD;AACA,mD;AACA,O;AACA,iC;AACA,mD;AACA,mD;AACA,O;AACA,O;;AAEA,uE;AACA,0D;AACA,mD;;AAEA,8E;AACA,0D;AACA,kD;;AAEA,+D;AACA,oD;AACA,mC;AACA,oC;AACA,6E;AACA,2B;AACA,0D;AACA,uB;;AAEA,qE;AACA,yB;AACA,8B;AACA,mD;AACA,sE;AACA,+E;AACA,uD;AACA,oD;AACA,oB;AACA,mB;AACA,qC;AACA,8D;AACA,8B;AACA,wE;AACA,wE;AACA,4C;AACA,0C;AACA,2D;AACA,2D;AACA,yC;AACA,8C;AACA,4C;AACA,mB;AACA,+B;AACA,sD;AACA,mD;AACA,sC;AACA,oB;AACA,wB;AACA,kD;AACA,iB;AACA,uD;AACA,kC;AACA,sD;AACA,6C;AACA,+B;AACA,e;AACA,a;AACA,Y;AACA,S;AACA,S;;AAEA,2C;AACA,kC;AACA,+C;;AAEA,qB;AACA,2C;AACA,kC;AACA,Q;;AAEA,yB;AACA,sB;AACA,oB;AACA,I;AACA,E;;;AAGA,U;AACA,sD;AACA,kD;AACA,sD;AACA,wD;AACA,yC;AACA,iC;AACA,6C;AACA,4B;AACA,wC;AACA,8B;AACA,2C;AACA,8B;AACA,2C;AACA,8B;AACA,2C;;AAEA,uC;AACA,mE;AACA,a;AACA,gC;AACA,2C;AACA,+B;AACA,I;AACA,6B;;AAEA,uC;;AAEA,kE;AACA,sB;AACA,c;AACA,qE;AACA,oE;AACA,oE;AACA,sE;AACA,kE;AACA,qE;AACA,gE;AACA,2C;AACA,qB;AACA,oC;AACA,O;AACA,U;AACA,0D;AACA,kC;AACA,sB;AACA,O;AACA,M;AACA,G;;AAEA,gC;AACA,oC;AACA,qC;;AAEA,sB;AACA,yB;AACA,mC;AACA,oC;AACA,6B;AACA,I;AACA,kC;AACA,kB;AACA,2B;AACA,c;AACA,kB;AACA,oB;AACA,sB;AACA,M;AACA,I;;AAEA,iE;AACA,oC;AACA,oD;AACA,yD;AACA,oD;;AAEA,6D;AACA,kE;AACA,sE;AACA,oE;AACA,iE;AACA,kE;AACA,iE;AACA,kE;AACA,sE;AACA,a;;AAEA,8D;AACA,mE;AACA,kE;AACA,oE;AACA,mE;AACA,yB;;AAEA,mC;AACA,sE;AACA,0E;AACA,iE;AACA,iC;AACA,0B;AACA,0B;AACA,+B;AACA,gD;AACA,+B;AACA,gC;AACA,oD;AACA,wB;AACA,iE;AACA,O;AACA,K;AACA,qB;;AAEA,mE;AACA,kD;;;AAGA,0C;AACA,kC;AACA,oE;AACA,sE;AACA,oE;AACA,sE;AACA,gC;AACA,wC;AACA,0C;;AAEA,oD;AACA,sC;AACA,4B;AACA,4B;AACA,6C;AACA,Y;AACA,iE;AACA,2D;AACA,2C;AACA,0C;AACA,wD;AACA,sD;AACA,K;;AAEA,oB;AACA,6B;AACA,iB;AACA,iB;AACA,yB;AACA,oC;AACA,U;AACA,kB;AACA,0B;AACA,4B;AACA,4B;AACA,sD;AACA,U;AACA,qC;AACA,yB;AACA,K;;AAEA,qB;AACA,8B;AACA,iB;AACA,iB;AACA,mC;AACA,6B;AACA,wC;AACA,U;AACA,kB;AACA,0B;AACA,4B;AACA,4B;AACA,uC;AACA,U;AACA,sC;AACA,yB;;AAEA,iE;AACA,oE;AACA,yD;AACA,4C;AACA,gC;AACA,mB;AACA,mB;AACA,qC;AACA,6B;AACA,2C;AACA,qB;AACA,Y;AACA,oB;AACA,4B;AACA,8B;AACA,8B;AACA,yC;AACA,Y;AACA,wC;AACA,2B;AACA,O;AACA,K;AACA,K;;AAEA,oB;AACA,kB;AACA,E;;AAEA,yD;AACA,E;AACA,kE;AACA,2C;AACA,E;AACA,sE;AACA,mE;AACA,oE;AACA,gE;AACA,gC;AACA,E;AACA,mB;AACA,8C;AACA,2B;AACA,6D;AACA,yD;AACA,a;AACA,8D;AACA,qD;AACA,Y;AACA,mE;AACA,iE;AACA,a;AACA,E;AACA,qE;AACA,E;AACA,iE;AACA,mE;AACA,oE;AACA,E;AACA,sE;AACA,sE;AACA,qE;AACA,kE;AACA,S;AACA,E;AACA,qE;AACA,sE;AACA,kE;AACA,uD;AACA,kE;AACA,oE;AACA,sC;AACA,E;AACA,sE;AACA,0D;AACA,sE;AACA,+B;AACA,E;AACA,mE;AACA,mE;AACA,iE;AACA,Q;AACA,E;AACA,kB;AACA,kE;AACA,oE;AACA,gB;AACA,4D;AACA,kE;AACA,sE;AACA,qE;AACA,iE;AACA,iB;AACA,gB;AACA,oD;AACA,sB;AACA,c;AACA,c;AACA,oB;;AAEA,Y;AACA,2C;AACA,8C;;AAEA,+C;AACA,E;;AAEA,sC;AACA,6B;;AAEA,kB;;;AAGA,gC;;AAEA,oD;AACA,8B;AACA,E;;AAEA,4D;AACA,+B;AACA,E;;AAEA,2D;AACA,8B;AACA,E;;AAEA,oE;AACA,wE;AACA,qE;AACA,sC;AACA,4B;AACA,mD;AACA,8D;AACA,E;;AAEA,qB;AACA,gD;AACA,wD","sourcesContent":["////////// Requires //////////\r\n\r\nvar fs = Npm.require(\"fs\");\r\nvar http = Npm.require(\"http\");\r\nvar os = Npm.require(\"os\");\r\nvar path = Npm.require(\"path\");\r\nvar url = Npm.require(\"url\");\r\nvar crypto = Npm.require(\"crypto\");\r\n\r\nvar connect = Npm.require('connect');\r\nvar useragent = Npm.require('useragent');\r\nvar send = Npm.require('send');\r\n\r\nvar SHORT_SOCKET_TIMEOUT = 5*1000;\r\nvar LONG_SOCKET_TIMEOUT = 120*1000;\r\n\r\nWebApp = {};\r\nWebAppInternals = {};\r\n\r\nvar bundledJsCssPrefix;\r\n\r\n// Keepalives so that when the outer server dies unceremoniously and\r\n// doesn't kill us, we quit ourselves. A little gross, but better than\r\n// pidfiles.\r\n// XXX This should really be part of the boot script, not the webapp package.\r\n//     Or we should just get rid of it, and rely on containerization.\r\n\r\nvar initKeepalive = function () {\r\n  var keepaliveCount = 0;\r\n\r\n  process.stdin.on('data', function (data) {\r\n    keepaliveCount = 0;\r\n  });\r\n\r\n  process.stdin.resume();\r\n\r\n  setInterval(function () {\r\n    keepaliveCount ++;\r\n    if (keepaliveCount >= 3) {\r\n      console.log(\"Failed to receive keepalive! Exiting.\");\r\n      process.exit(1);\r\n    }\r\n  }, 3000);\r\n};\r\n\r\n\r\nvar sha1 = function (contents) {\r\n  var hash = crypto.createHash('sha1');\r\n  hash.update(contents);\r\n  return hash.digest('hex');\r\n};\r\n\r\n// #BrowserIdentification\r\n//\r\n// We have multiple places that want to identify the browser: the\r\n// unsupported browser page, the appcache package, and, eventually\r\n// delivering browser polyfills only as needed.\r\n//\r\n// To avoid detecting the browser in multiple places ad-hoc, we create a\r\n// Meteor \"browser\" object. It uses but does not expose the npm\r\n// useragent module (we could choose a different mechanism to identify\r\n// the browser in the future if we wanted to).  The browser object\r\n// contains\r\n//\r\n// * `name`: the name of the browser in camel case\r\n// * `major`, `minor`, `patch`: integers describing the browser version\r\n//\r\n// Also here is an early version of a Meteor `request` object, intended\r\n// to be a high-level description of the request without exposing\r\n// details of connect's low-level `req`.  Currently it contains:\r\n//\r\n// * `browser`: browser identification object described above\r\n// * `url`: parsed url, including parsed query params\r\n//\r\n// As a temporary hack there is a `categorizeRequest` function on WebApp which\r\n// converts a connect `req` to a Meteor `request`. This can go away once smart\r\n// packages such as appcache are being passed a `request` object directly when\r\n// they serve content.\r\n//\r\n// This allows `request` to be used uniformly: it is passed to the html\r\n// attributes hook, and the appcache package can use it when deciding\r\n// whether to generate a 404 for the manifest.\r\n//\r\n// Real routing / server side rendering will probably refactor this\r\n// heavily.\r\n\r\n\r\n// e.g. \"Mobile Safari\" => \"mobileSafari\"\r\nvar camelCase = function (name) {\r\n  var parts = name.split(' ');\r\n  parts[0] = parts[0].toLowerCase();\r\n  for (var i = 1;  i < parts.length;  ++i) {\r\n    parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].substr(1);\r\n  }\r\n  return parts.join('');\r\n};\r\n\r\nvar identifyBrowser = function (userAgentString) {\r\n  var userAgent = useragent.lookup(userAgentString);\r\n  return {\r\n    name: camelCase(userAgent.family),\r\n    major: +userAgent.major,\r\n    minor: +userAgent.minor,\r\n    patch: +userAgent.patch\r\n  };\r\n};\r\n\r\n// XXX Refactor as part of implementing real routing.\r\nWebAppInternals.identifyBrowser = identifyBrowser;\r\n\r\nWebApp.categorizeRequest = function (req) {\r\n  return {\r\n    browser: identifyBrowser(req.headers['user-agent']),\r\n    url: url.parse(req.url, true)\r\n  };\r\n};\r\n\r\n// HTML attribute hooks: functions to be called to determine any attributes to\r\n// be added to the '<html>' tag. Each function is passed a 'request' object (see\r\n// #BrowserIdentification) and should return a string,\r\nvar htmlAttributeHooks = [];\r\nvar getHtmlAttributes = function (request) {\r\n  var combinedAttributes  = {};\r\n  _.each(htmlAttributeHooks || [], function (hook) {\r\n    var attributes = hook(request);\r\n    if (attributes === null)\r\n      return;\r\n    if (typeof attributes !== 'object')\r\n      throw Error(\"HTML attribute hook must return null or object\");\r\n    _.extend(combinedAttributes, attributes);\r\n  });\r\n  return combinedAttributes;\r\n};\r\nWebApp.addHtmlAttributeHook = function (hook) {\r\n  htmlAttributeHooks.push(hook);\r\n};\r\n\r\n// Serve app HTML for this URL?\r\nvar appUrl = function (url) {\r\n  if (url === '/favicon.ico' || url === '/robots.txt')\r\n    return false;\r\n\r\n  // NOTE: app.manifest is not a web standard like favicon.ico and\r\n  // robots.txt. It is a file name we have chosen to use for HTML5\r\n  // appcache URLs. It is included here to prevent using an appcache\r\n  // then removing it from poisoning an app permanently. Eventually,\r\n  // once we have server side routing, this won't be needed as\r\n  // unknown URLs with return a 404 automatically.\r\n  if (url === '/app.manifest')\r\n    return false;\r\n\r\n  // Avoid serving app HTML for declared routes such as /sockjs/.\r\n  if (RoutePolicy.classify(url))\r\n    return false;\r\n\r\n  // we currently return app HTML on all URLs by default\r\n  return true;\r\n};\r\n\r\n\r\n// Calculate a hash of all the client resources downloaded by the\r\n// browser, including the application HTML, runtime config, code, and\r\n// static files.\r\n//\r\n// This hash *must* change if any resources seen by the browser\r\n// change, and ideally *doesn't* change for any server-only changes\r\n// (but the second is a performance enhancement, not a hard\r\n// requirement).\r\n\r\nvar calculateClientHash = function () {\r\n  var hash = crypto.createHash('sha1');\r\n  hash.update(JSON.stringify(__meteor_runtime_config__), 'utf8');\r\n  _.each(WebApp.clientProgram.manifest, function (resource) {\r\n    if (resource.where === 'client' || resource.where === 'internal') {\r\n      hash.update(resource.path);\r\n      hash.update(resource.hash);\r\n    }\r\n  });\r\n  return hash.digest('hex');\r\n};\r\n\r\n\r\n// We need to calculate the client hash after all packages have loaded\r\n// to give them a chance to populate __meteor_runtime_config__.\r\n//\r\n// Calculating the hash during startup means that packages can only\r\n// populate __meteor_runtime_config__ during load, not during startup.\r\n//\r\n// Calculating instead it at the beginning of main after all startup\r\n// hooks had run would allow packages to also populate\r\n// __meteor_runtime_config__ during startup, but that's too late for\r\n// autoupdate because it needs to have the client hash at startup to\r\n// insert the auto update version itself into\r\n// __meteor_runtime_config__ to get it to the client.\r\n//\r\n// An alternative would be to give autoupdate a \"post-start,\r\n// pre-listen\" hook to allow it to insert the auto update version at\r\n// the right moment.\r\n\r\nMeteor.startup(function () {\r\n  WebApp.clientHash = calculateClientHash();\r\n});\r\n\r\n\r\n\r\n// When we have a request pending, we want the socket timeout to be long, to\r\n// give ourselves a while to serve it, and to allow sockjs long polls to\r\n// complete.  On the other hand, we want to close idle sockets relatively\r\n// quickly, so that we can shut down relatively promptly but cleanly, without\r\n// cutting off anyone's response.\r\nWebApp._timeoutAdjustmentRequestCallback = function (req, res) {\r\n  // this is really just req.socket.setTimeout(LONG_SOCKET_TIMEOUT);\r\n  req.setTimeout(LONG_SOCKET_TIMEOUT);\r\n  // Insert our new finish listener to run BEFORE the existing one which removes\r\n  // the response from the socket.\r\n  var finishListeners = res.listeners('finish');\r\n  // XXX Apparently in Node 0.12 this event is now called 'prefinish'.\r\n  // https://github.com/joyent/node/commit/7c9b6070\r\n  res.removeAllListeners('finish');\r\n  res.on('finish', function () {\r\n    res.setTimeout(SHORT_SOCKET_TIMEOUT);\r\n  });\r\n  _.each(finishListeners, function (l) { res.on('finish', l); });\r\n};\r\n\r\n// Will be updated by main before we listen.\r\nvar boilerplateFunc = null;\r\nvar boilerplateBaseData = null;\r\nvar memoizedBoilerplate = {};\r\n\r\n// Given a request (as returned from `categorizeRequest`), return the\r\n// boilerplate HTML to serve for that request. Memoizes on HTML\r\n// attributes (used by, eg, appcache) and whether inline scripts are\r\n// currently allowed.\r\nvar getBoilerplate = function (request) {\r\n  var htmlAttributes = getHtmlAttributes(request);\r\n\r\n  // The only thing that changes from request to request (for now) are\r\n  // the HTML attributes (used by, eg, appcache) and whether inline\r\n  // scripts are allowed, so we can memoize based on that.\r\n  var boilerplateKey = JSON.stringify({\r\n    inlineScriptsAllowed: inlineScriptsAllowed,\r\n    htmlAttributes: htmlAttributes\r\n  });\r\n\r\n  if (! _.has(memoizedBoilerplate, boilerplateKey)) {\r\n    var boilerplateData = _.extend({\r\n      htmlAttributes: htmlAttributes,\r\n      inlineScriptsAllowed: WebAppInternals.inlineScriptsAllowed()\r\n    }, boilerplateBaseData);\r\n\r\n    memoizedBoilerplate[boilerplateKey] = \"<!DOCTYPE html>\\n\" +\r\n      Blaze.toHTML(Blaze.With(boilerplateData, boilerplateFunc));\r\n  }\r\n  return memoizedBoilerplate[boilerplateKey];\r\n};\r\n\r\n// Serve static files from the manifest or added with\r\n// `addStaticJs`. Exported for tests.\r\n// Options are:\r\n//   - staticFiles: object mapping pathname of file in manifest -> {\r\n//     path, cacheable, sourceMapUrl, type }\r\n//   - clientDir: root directory for static files from client manifest\r\nWebAppInternals.staticFilesMiddleware = function (options, req, res, next) {\r\n  if ('GET' != req.method && 'HEAD' != req.method) {\r\n    next();\r\n    return;\r\n  }\r\n  var pathname = connect.utils.parseUrl(req).pathname;\r\n  var staticFiles = options.staticFiles;\r\n  var clientDir = options.clientDir;\r\n\r\n  try {\r\n    pathname = decodeURIComponent(pathname);\r\n  } catch (e) {\r\n    next();\r\n    return;\r\n  }\r\n\r\n  var serveStaticJs = function (s) {\r\n    res.writeHead(200, {\r\n      'Content-type': 'application/javascript; charset=UTF-8'\r\n    });\r\n    res.write(s);\r\n    res.end();\r\n  };\r\n\r\n  if (pathname === \"/meteor_runtime_config.js\" &&\r\n      ! WebAppInternals.inlineScriptsAllowed()) {\r\n    serveStaticJs(\"__meteor_runtime_config__ = \" +\r\n                  JSON.stringify(__meteor_runtime_config__) + \";\");\r\n    return;\r\n  } else if (_.has(additionalStaticJs, pathname) &&\r\n             ! WebAppInternals.inlineScriptsAllowed()) {\r\n    serveStaticJs(additionalStaticJs[pathname]);\r\n    return;\r\n  }\r\n\r\n  if (!_.has(staticFiles, pathname)) {\r\n    next();\r\n    return;\r\n  }\r\n\r\n  // We don't need to call pause because, unlike 'static', once we call into\r\n  // 'send' and yield to the event loop, we never call another handler with\r\n  // 'next'.\r\n\r\n  var info = staticFiles[pathname];\r\n\r\n  // Cacheable files are files that should never change. Typically\r\n  // named by their hash (eg meteor bundled js and css files).\r\n  // We cache them ~forever (1yr).\r\n  //\r\n  // We cache non-cacheable files anyway. This isn't really correct, as users\r\n  // can change the files and changes won't propagate immediately. However, if\r\n  // we don't cache them, browsers will 'flicker' when rerendering\r\n  // images. Eventually we will probably want to rewrite URLs of static assets\r\n  // to include a query parameter to bust caches. That way we can both get\r\n  // good caching behavior and allow users to change assets without delay.\r\n  // https://github.com/meteor/meteor/issues/773\r\n  var maxAge = info.cacheable\r\n        ? 1000 * 60 * 60 * 24 * 365\r\n        : 1000 * 60 * 60 * 24;\r\n\r\n  // Set the X-SourceMap header, which current Chrome understands.\r\n  // (The files also contain '//#' comments which FF 24 understands and\r\n  // Chrome doesn't understand yet.)\r\n  //\r\n  // Eventually we should set the SourceMap header but the current version of\r\n  // Chrome and no version of FF supports it.\r\n  //\r\n  // To figure out if your version of Chrome should support the SourceMap\r\n  // header,\r\n  //   - go to chrome://version. Let's say the Chrome version is\r\n  //      28.0.1500.71 and the Blink version is 537.36 (@153022)\r\n  //   - go to http://src.chromium.org/viewvc/blink/branches/chromium/1500/Source/core/inspector/InspectorPageAgent.cpp?view=log\r\n  //     where the \"1500\" is the third part of your Chrome version\r\n  //   - find the first revision that is no greater than the \"153022\"\r\n  //     number.  That's probably the first one and it probably has\r\n  //     a message of the form \"Branch 1500 - blink@r149738\"\r\n  //   - If *that* revision number (149738) is at least 151755,\r\n  //     then Chrome should support SourceMap (not just X-SourceMap)\r\n  // (The change is https://codereview.chromium.org/15832007)\r\n  //\r\n  // You also need to enable source maps in Chrome: open dev tools, click\r\n  // the gear in the bottom right corner, and select \"enable source maps\".\r\n  //\r\n  // Firefox 23+ supports source maps but doesn't support either header yet,\r\n  // so we include the '//#' comment for it:\r\n  //   https://bugzilla.mozilla.org/show_bug.cgi?id=765993\r\n  // In FF 23 you need to turn on `devtools.debugger.source-maps-enabled`\r\n  // in `about:config` (it is on by default in FF 24).\r\n  if (info.sourceMapUrl)\r\n    res.setHeader('X-SourceMap', info.sourceMapUrl);\r\n\r\n  if (info.type === \"js\") {\r\n    res.setHeader(\"Content-Type\", \"application/javascript; charset=UTF-8\");\r\n  } else if (info.type === \"css\") {\r\n    res.setHeader(\"Content-Type\", \"text/css; charset=UTF-8\");\r\n  }\r\n\r\n  send(req, path.join(clientDir, info.path))\r\n    .maxage(maxAge)\r\n    .hidden(true)  // if we specified a dotfile in the manifest, serve it\r\n    .on('error', function (err) {\r\n      Log.error(\"Error serving static file \" + err);\r\n      res.writeHead(500);\r\n      res.end();\r\n    })\r\n    .on('directory', function () {\r\n      Log.error(\"Unexpected directory \" + info.path);\r\n      res.writeHead(500);\r\n      res.end();\r\n    })\r\n    .pipe(res);\r\n};\r\n\r\nvar runWebAppServer = function () {\r\n  var shuttingDown = false;\r\n  // read the control for the client we'll be serving up\r\n  var clientJsonPath = path.join(__meteor_bootstrap__.serverDir,\r\n                                 __meteor_bootstrap__.configJson.client);\r\n  var clientDir = path.dirname(clientJsonPath);\r\n  var clientJson = JSON.parse(fs.readFileSync(clientJsonPath, 'utf8'));\r\n\r\n  if (clientJson.format !== \"browser-program-pre1\")\r\n    throw new Error(\"Unsupported format for client assets: \" +\r\n                    JSON.stringify(clientJson.format));\r\n\r\n  // webserver\r\n  var app = connect();\r\n\r\n  // Auto-compress any json, javascript, or text.\r\n  app.use(connect.compress());\r\n\r\n  // Packages and apps can add handlers that run before any other Meteor\r\n  // handlers via WebApp.rawConnectHandlers.\r\n  var rawConnectHandlers = connect();\r\n  app.use(rawConnectHandlers);\r\n\r\n  // Strip off the path prefix, if it exists.\r\n  app.use(function (request, response, next) {\r\n    var pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\r\n    var url = Npm.require('url').parse(request.url);\r\n    var pathname = url.pathname;\r\n    // check if the path in the url starts with the path prefix (and the part\r\n    // after the path prefix must start with a / if it exists.)\r\n    if (pathPrefix && pathname.substring(0, pathPrefix.length) === pathPrefix &&\r\n       (pathname.length == pathPrefix.length\r\n        || pathname.substring(pathPrefix.length, pathPrefix.length + 1) === \"/\")) {\r\n      request.url = request.url.substring(pathPrefix.length);\r\n      next();\r\n    } else if (pathname === \"/favicon.ico\" || pathname === \"/robots.txt\") {\r\n      next();\r\n    } else if (pathPrefix) {\r\n      response.writeHead(404);\r\n      response.write(\"Unknown path\");\r\n      response.end();\r\n    } else {\r\n      next();\r\n    }\r\n  });\r\n\r\n  // Parse the query string into res.query. Used by oauth_server, but it's\r\n  // generally pretty handy..\r\n  app.use(connect.query());\r\n\r\n  var getItemPathname = function (itemUrl) {\r\n    return decodeURIComponent(url.parse(itemUrl).pathname);\r\n  };\r\n\r\n  var staticFiles = {};\r\n  _.each(clientJson.manifest, function (item) {\r\n    if (item.url && item.where === \"client\") {\r\n      staticFiles[getItemPathname(item.url)] = {\r\n        path: item.path,\r\n        cacheable: item.cacheable,\r\n        // Link from source to its map\r\n        sourceMapUrl: item.sourceMapUrl,\r\n        type: item.type\r\n      };\r\n\r\n      if (item.sourceMap) {\r\n        // Serve the source map too, under the specified URL. We assume all\r\n        // source maps are cacheable.\r\n        staticFiles[getItemPathname(item.sourceMapUrl)] = {\r\n          path: item.sourceMap,\r\n          cacheable: true\r\n        };\r\n      }\r\n    }\r\n  });\r\n\r\n  // Exported for tests.\r\n  WebAppInternals.staticFiles = staticFiles;\r\n\r\n\r\n  // Serve static files from the manifest.\r\n  // This is inspired by the 'static' middleware.\r\n  app.use(function (req, res, next) {\r\n    return WebAppInternals.staticFilesMiddleware({\r\n      staticFiles: staticFiles,\r\n      clientDir: clientDir\r\n    }, req, res, next);\r\n  });\r\n\r\n  // Packages and apps can add handlers to this via WebApp.connectHandlers.\r\n  // They are inserted before our default handler.\r\n  var packageAndAppHandlers = connect();\r\n  app.use(packageAndAppHandlers);\r\n\r\n  var suppressConnectErrors = false;\r\n  // connect knows it is an error handler because it has 4 arguments instead of\r\n  // 3. go figure.  (It is not smart enough to find such a thing if it's hidden\r\n  // inside packageAndAppHandlers.)\r\n  app.use(function (err, req, res, next) {\r\n    if (!err || !suppressConnectErrors || !req.headers['x-suppress-error']) {\r\n      next(err);\r\n      return;\r\n    }\r\n    res.writeHead(err.status, { 'Content-Type': 'text/plain' });\r\n    res.end(\"An error message\");\r\n  });\r\n\r\n  app.use(function (req, res, next) {\r\n    if (! appUrl(req.url))\r\n      return next();\r\n\r\n    if (!boilerplateFunc)\r\n      throw new Error(\"boilerplateFunc should be set before listening!\");\r\n    if (!boilerplateBaseData)\r\n      throw new Error(\"boilerplateBaseData should be set before listening!\");\r\n\r\n    var headers = {\r\n      'Content-Type':  'text/html; charset=utf-8'\r\n    };\r\n    if (shuttingDown)\r\n      headers['Connection'] = 'Close';\r\n\r\n    var request = WebApp.categorizeRequest(req);\r\n\r\n    if (request.url.query && request.url.query['meteor_css_resource']) {\r\n      // In this case, we're requesting a CSS resource in the meteor-specific\r\n      // way, but we don't have it.  Serve a static css file that indicates that\r\n      // we didn't have it, so we can detect that and refresh.\r\n      headers['Content-Type'] = 'text/css; charset=utf-8';\r\n      res.writeHead(200, headers);\r\n      res.write(\".meteor-css-not-found-error { width: 0px;}\");\r\n      res.end();\r\n      return undefined;\r\n    }\r\n\r\n    var boilerplate;\r\n    try {\r\n      boilerplate = getBoilerplate(request);\r\n    } catch (e) {\r\n      Log.error(\"Error running template: \" + e);\r\n      res.writeHead(500, headers);\r\n      res.end();\r\n      return undefined;\r\n    }\r\n\r\n    res.writeHead(200, headers);\r\n    res.write(boilerplate);\r\n    res.end();\r\n    return undefined;\r\n  });\r\n\r\n  // Return 404 by default, if no other handlers serve this URL.\r\n  app.use(function (req, res) {\r\n    res.writeHead(404);\r\n    res.end();\r\n  });\r\n\r\n\r\n  var httpServer = http.createServer(app);\r\n  var onListeningCallbacks = [];\r\n\r\n  // After 5 seconds w/o data on a socket, kill it.  On the other hand, if\r\n  // there's an outstanding request, give it a higher timeout instead (to avoid\r\n  // killing long-polling requests)\r\n  httpServer.setTimeout(SHORT_SOCKET_TIMEOUT);\r\n\r\n  // Do this here, and then also in livedata/stream_server.js, because\r\n  // stream_server.js kills all the current request handlers when installing its\r\n  // own.\r\n  httpServer.on('request', WebApp._timeoutAdjustmentRequestCallback);\r\n\r\n\r\n  // For now, handle SIGHUP here.  Later, this should be in some centralized\r\n  // Meteor shutdown code.\r\n  process.on('SIGHUP', Meteor.bindEnvironment(function () {\r\n    shuttingDown = true;\r\n    // tell others with websockets open that we plan to close this.\r\n    // XXX: Eventually, this should be done with a standard meteor shut-down\r\n    // logic path.\r\n    httpServer.emit('meteor-closing');\r\n\r\n    httpServer.close(Meteor.bindEnvironment(function () {\r\n      if (proxy) {\r\n        try {\r\n          proxy.call('removeBindingsForJob', process.env.GALAXY_JOB);\r\n        } catch (e) {\r\n          Log.error(\"Error removing bindings: \" + e.message);\r\n          process.exit(1);\r\n        }\r\n      }\r\n      process.exit(0);\r\n\r\n    }, \"On http server close failed\"));\r\n\r\n    // Ideally we will close before this hits.\r\n    Meteor.setTimeout(function () {\r\n      Log.warn(\"Closed by SIGHUP but one or more HTTP requests may not have finished.\");\r\n      process.exit(1);\r\n    }, 5000);\r\n\r\n  }, function (err) {\r\n    console.log(err);\r\n    process.exit(1);\r\n  }));\r\n\r\n  // start up app\r\n  _.extend(WebApp, {\r\n    connectHandlers: packageAndAppHandlers,\r\n    rawConnectHandlers: rawConnectHandlers,\r\n    httpServer: httpServer,\r\n    // metadata about the client program that we serve\r\n    clientProgram: {\r\n      manifest: clientJson.manifest\r\n      // XXX do we need a \"root: clientDir\" field here? it used to be here but\r\n      // was unused.\r\n    },\r\n    // For testing.\r\n    suppressConnectErrors: function () {\r\n      suppressConnectErrors = true;\r\n    },\r\n    onListening: function (f) {\r\n      if (onListeningCallbacks)\r\n        onListeningCallbacks.push(f);\r\n      else\r\n        f();\r\n    },\r\n    // Hack: allow http tests to call connect.basicAuth without making them\r\n    // Npm.depends on another copy of connect. (That would be fine if we could\r\n    // have test-only NPM dependencies but is overkill here.)\r\n    __basicAuth__: connect.basicAuth\r\n  });\r\n\r\n  // Let the rest of the packages (and Meteor.startup hooks) insert connect\r\n  // middlewares and update __meteor_runtime_config__, then keep going to set up\r\n  // actually serving HTML.\r\n  main = function (argv) {\r\n    // main happens post startup hooks, so we don't need a Meteor.startup() to\r\n    // ensure this happens after the galaxy package is loaded.\r\n    var AppConfig = Package[\"application-configuration\"].AppConfig;\r\n    // We used to use the optimist npm package to parse argv here, but it's\r\n    // overkill (and no longer in the dev bundle). Just assume any instance of\r\n    // '--keepalive' is a use of the option.\r\n    var expectKeepalives = _.contains(argv, '--keepalive');\r\n\r\n    boilerplateBaseData = {\r\n      // 'htmlAttributes' and 'inlineScriptsAllowed' are set at render\r\n      // time, because they are allowed to change from request to\r\n      // request.\r\n      css: [],\r\n      js: [],\r\n      head: '',\r\n      body: '',\r\n      additionalStaticJs: _.map(\r\n        additionalStaticJs,\r\n        function (contents, pathname) {\r\n          return {\r\n            pathname: pathname,\r\n            contents: contents\r\n          };\r\n        }\r\n      ),\r\n      meteorRuntimeConfig: JSON.stringify(__meteor_runtime_config__),\r\n      rootUrlPathPrefix: __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '',\r\n      bundledJsCssPrefix: bundledJsCssPrefix ||\r\n        __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || ''\r\n    };\r\n\r\n    _.each(WebApp.clientProgram.manifest, function (item) {\r\n      if (item.type === 'css' && item.where === 'client') {\r\n        boilerplateBaseData.css.push({url: item.url});\r\n      }\r\n      if (item.type === 'js' && item.where === 'client') {\r\n        boilerplateBaseData.js.push({url: item.url});\r\n      }\r\n      if (item.type === 'head') {\r\n        boilerplateBaseData.head = fs.readFileSync(\r\n          path.join(clientDir, item.path), 'utf8');\r\n      }\r\n      if (item.type === 'body') {\r\n        boilerplateBaseData.body = fs.readFileSync(\r\n          path.join(clientDir, item.path), 'utf8');\r\n      }\r\n    });\r\n\r\n    var boilerplateTemplateSource = Assets.getText(\"boilerplate.html\");\r\n    var boilerplateRenderCode = SpacebarsCompiler.compile(\r\n      boilerplateTemplateSource, { isBody: true });\r\n\r\n    // Note that we are actually depending on eval's local environment capture\r\n    // so that UI and HTML are visible to the eval'd code.\r\n    boilerplateFunc = eval(boilerplateRenderCode);\r\n\r\n    // only start listening after all the startup code has run.\r\n    var localPort = parseInt(process.env.PORT) || 0;\r\n    var host = process.env.BIND_IP;\r\n    var localIp = host || '0.0.0.0';\r\n    httpServer.listen(localPort, localIp, Meteor.bindEnvironment(function() {\r\n      if (expectKeepalives)\r\n        console.log(\"LISTENING\"); // must match run-app.js\r\n      var proxyBinding;\r\n\r\n      AppConfig.configurePackage('webapp', function (configuration) {\r\n        if (proxyBinding)\r\n          proxyBinding.stop();\r\n        if (configuration && configuration.proxy) {\r\n          // TODO: We got rid of the place where this checks the app's\r\n          // configuration, because this wants to be configured for some things\r\n          // on a per-job basis.  Discuss w/ teammates.\r\n          proxyBinding = AppConfig.configureService(\r\n            \"proxy\",\r\n            \"pre0\",\r\n            function (proxyService) {\r\n              if (proxyService && ! _.isEmpty(proxyService)) {\r\n                var proxyConf;\r\n                // XXX Figure out a per-job way to specify bind location\r\n                // (besides hardcoding the location for ADMIN_APP jobs).\r\n                if (process.env.ADMIN_APP) {\r\n                  var bindPathPrefix = \"\";\r\n                  if (process.env.GALAXY_APP !== \"panel\") {\r\n                    bindPathPrefix = \"/\" + bindPathPrefix +\r\n                      encodeURIComponent(\r\n                        process.env.GALAXY_APP\r\n                      ).replace(/\\./g, '_');\r\n                  }\r\n                  proxyConf = {\r\n                    bindHost: process.env.GALAXY_NAME,\r\n                    bindPathPrefix: bindPathPrefix,\r\n                    requiresAuth: true\r\n                  };\r\n                } else {\r\n                  proxyConf = configuration.proxy;\r\n                }\r\n                Log(\"Attempting to bind to proxy at \" +\r\n                    proxyService);\r\n                WebAppInternals.bindToProxy(_.extend({\r\n                  proxyEndpoint: proxyService\r\n                }, proxyConf));\r\n              }\r\n            }\r\n          );\r\n        }\r\n      });\r\n\r\n      var callbacks = onListeningCallbacks;\r\n      onListeningCallbacks = null;\r\n      _.each(callbacks, function (x) { x(); });\r\n\r\n    }, function (e) {\r\n      console.error(\"Error listening:\", e);\r\n      console.error(e && e.stack);\r\n    }));\r\n\r\n    if (expectKeepalives)\r\n      initKeepalive();\r\n    return 'DAEMON';\r\n  };\r\n};\r\n\r\n\r\nvar proxy;\r\nWebAppInternals.bindToProxy = function (proxyConfig) {\r\n  var securePort = proxyConfig.securePort || 4433;\r\n  var insecurePort = proxyConfig.insecurePort || 8080;\r\n  var bindPathPrefix = proxyConfig.bindPathPrefix || \"\";\r\n  // XXX also support galaxy-based lookup\r\n  if (!proxyConfig.proxyEndpoint)\r\n    throw new Error(\"missing proxyEndpoint\");\r\n  if (!proxyConfig.bindHost)\r\n    throw new Error(\"missing bindHost\");\r\n  if (!process.env.GALAXY_JOB)\r\n    throw new Error(\"missing $GALAXY_JOB\");\r\n  if (!process.env.GALAXY_APP)\r\n    throw new Error(\"missing $GALAXY_APP\");\r\n  if (!process.env.LAST_START)\r\n    throw new Error(\"missing $LAST_START\");\r\n\r\n  // XXX rename pid argument to bindTo.\r\n  // XXX factor out into a 'getPid' function in a 'galaxy' package?\r\n  var pid = {\r\n    job: process.env.GALAXY_JOB,\r\n    lastStarted: +(process.env.LAST_START),\r\n    app: process.env.GALAXY_APP\r\n  };\r\n  var myHost = os.hostname();\r\n\r\n  WebAppInternals.usingDdpProxy = true;\r\n\r\n  // This is run after packages are loaded (in main) so we can use\r\n  // Follower.connect.\r\n  if (proxy) {\r\n    // XXX the concept here is that our configuration has changed and\r\n    // we have connected to an entirely new follower set, which does\r\n    // not have the state that we set up on the follower set that we\r\n    // were previously connected to, and so we need to recreate all of\r\n    // our bindings -- analogous to getting a SIGHUP and rereading\r\n    // your configuration file. so probably this should actually tear\r\n    // down the connection and make a whole new one, rather than\r\n    // hot-reconnecting to a different URL.\r\n    proxy.reconnect({\r\n      url: proxyConfig.proxyEndpoint\r\n    });\r\n  } else {\r\n    proxy = Package[\"follower-livedata\"].Follower.connect(\r\n      proxyConfig.proxyEndpoint, {\r\n        group: \"proxy\"\r\n      }\r\n    );\r\n  }\r\n\r\n  var route = process.env.ROUTE;\r\n  var ourHost = route.split(\":\")[0];\r\n  var ourPort = +route.split(\":\")[1];\r\n\r\n  var outstanding = 0;\r\n  var startedAll = false;\r\n  var checkComplete = function () {\r\n    if (startedAll && ! outstanding)\r\n      Log(\"Bound to proxy.\");\r\n  };\r\n  var makeCallback = function () {\r\n    outstanding++;\r\n    return function (err) {\r\n      if (err)\r\n        throw err;\r\n      outstanding--;\r\n      checkComplete();\r\n    };\r\n  };\r\n\r\n  // for now, have our (temporary) requiresAuth flag apply to all\r\n  // routes created by this process.\r\n  var requiresDdpAuth = !! proxyConfig.requiresAuth;\r\n  var requiresHttpAuth = (!! proxyConfig.requiresAuth) &&\r\n        (pid.app !== \"panel\" && pid.app !== \"auth\");\r\n\r\n  // XXX a current limitation is that we treat securePort and\r\n  // insecurePort as a global configuration parameter -- we assume\r\n  // that if the proxy wants us to ask for 8080 to get port 80 traffic\r\n  // on our default hostname, that's the same port that we would use\r\n  // to get traffic on some other hostname that our proxy listens\r\n  // for. Likewise, we assume that if the proxy can receive secure\r\n  // traffic for our domain, it can assume secure traffic for any\r\n  // domain! Hopefully this will get cleaned up before too long by\r\n  // pushing that logic into the proxy service, so we can just ask for\r\n  // port 80.\r\n\r\n  // XXX BUG: if our configuration changes, and bindPathPrefix\r\n  // changes, it appears that we will not remove the routes derived\r\n  // from the old bindPathPrefix from the proxy (until the process\r\n  // exits). It is not actually normal for bindPathPrefix to change,\r\n  // certainly not without a process restart for other reasons, but\r\n  // it'd be nice to fix.\r\n\r\n  _.each(routes, function (route) {\r\n    var parsedUrl = url.parse(route.url, /* parseQueryString */ false,\r\n                              /* slashesDenoteHost aka workRight */ true);\r\n    if (parsedUrl.protocol || parsedUrl.port || parsedUrl.search)\r\n      throw new Error(\"Bad url\");\r\n    parsedUrl.host = null;\r\n    parsedUrl.path = null;\r\n    if (! parsedUrl.hostname) {\r\n      parsedUrl.hostname = proxyConfig.bindHost;\r\n      if (! parsedUrl.pathname)\r\n        parsedUrl.pathname = \"\";\r\n      if (! parsedUrl.pathname.indexOf(\"/\") !== 0) {\r\n        // Relative path\r\n        parsedUrl.pathname = bindPathPrefix + parsedUrl.pathname;\r\n      }\r\n    }\r\n    var version = \"\";\r\n\r\n    var AppConfig = Package[\"application-configuration\"].AppConfig;\r\n    version = AppConfig.getStarForThisJob() || \"\";\r\n\r\n\r\n    var parsedDdpUrl = _.clone(parsedUrl);\r\n    parsedDdpUrl.protocol = \"ddp\";\r\n    // Node has a hardcoded list of protocols that get '://' instead\r\n    // of ':'. ddp needs to be added to that whitelist. Until then, we\r\n    // can set the undocumented attribute 'slashes' to get the right\r\n    // behavior. It's not clear whether than is by design or accident.\r\n    parsedDdpUrl.slashes = true;\r\n    parsedDdpUrl.port = '' + securePort;\r\n    var ddpUrl = url.format(parsedDdpUrl);\r\n\r\n    var proxyToHost, proxyToPort, proxyToPathPrefix;\r\n    if (! _.has(route, 'forwardTo')) {\r\n      proxyToHost = ourHost;\r\n      proxyToPort = ourPort;\r\n      proxyToPathPrefix = parsedUrl.pathname;\r\n    } else {\r\n      var parsedFwdUrl = url.parse(route.forwardTo, false, true);\r\n      if (! parsedFwdUrl.hostname || parsedFwdUrl.protocol)\r\n        throw new Error(\"Bad forward url\");\r\n      proxyToHost = parsedFwdUrl.hostname;\r\n      proxyToPort = parseInt(parsedFwdUrl.port || \"80\");\r\n      proxyToPathPrefix = parsedFwdUrl.pathname || \"\";\r\n    }\r\n\r\n    if (route.ddp) {\r\n      proxy.call('bindDdp', {\r\n        pid: pid,\r\n        bindTo: {\r\n          ddpUrl: ddpUrl,\r\n          insecurePort: insecurePort\r\n        },\r\n        proxyTo: {\r\n          tags: [version],\r\n          host: proxyToHost,\r\n          port: proxyToPort,\r\n          pathPrefix: proxyToPathPrefix + '/websocket'\r\n        },\r\n        requiresAuth: requiresDdpAuth\r\n      }, makeCallback());\r\n    }\r\n\r\n    if (route.http) {\r\n      proxy.call('bindHttp', {\r\n        pid: pid,\r\n        bindTo: {\r\n          host: parsedUrl.hostname,\r\n          port: insecurePort,\r\n          pathPrefix: parsedUrl.pathname\r\n        },\r\n        proxyTo: {\r\n          tags: [version],\r\n          host: proxyToHost,\r\n          port: proxyToPort,\r\n          pathPrefix: proxyToPathPrefix\r\n        },\r\n        requiresAuth: requiresHttpAuth\r\n      }, makeCallback());\r\n\r\n      // Only make the secure binding if we've been told that the\r\n      // proxy knows how terminate secure connections for us (has an\r\n      // appropriate cert, can bind the necessary port..)\r\n      if (proxyConfig.securePort !== null) {\r\n        proxy.call('bindHttp', {\r\n          pid: pid,\r\n          bindTo: {\r\n            host: parsedUrl.hostname,\r\n            port: securePort,\r\n            pathPrefix: parsedUrl.pathname,\r\n            ssl: true\r\n          },\r\n          proxyTo: {\r\n            tags: [version],\r\n            host: proxyToHost,\r\n            port: proxyToPort,\r\n            pathPrefix: proxyToPathPrefix\r\n          },\r\n          requiresAuth: requiresHttpAuth\r\n        }, makeCallback());\r\n      }\r\n    }\r\n  });\r\n\r\n  startedAll = true;\r\n  checkComplete();\r\n};\r\n\r\n// (Internal, unsupported interface -- subject to change)\r\n//\r\n// Listen for HTTP and/or DDP traffic and route it somewhere. Only\r\n// takes effect when using a proxy service.\r\n//\r\n// 'url' is the traffic that we want to route, interpreted relative to\r\n// the default URL where this app has been told to serve itself. It\r\n// may not have a scheme or port, but it may have a host and a path,\r\n// and if no host is provided the path need not be absolute. The\r\n// following cases are possible:\r\n//\r\n//   //somehost.com\r\n//     All incoming traffic for 'somehost.com'\r\n//   //somehost.com/foo/bar\r\n//     All incoming traffic for 'somehost.com', but only when\r\n//     the first two path components are 'foo' and 'bar'.\r\n//   /foo/bar\r\n//     Incoming traffic on our default host, but only when the\r\n//     first two path components are 'foo' and 'bar'.\r\n//   foo/bar\r\n//     Incoming traffic on our default host, but only when the path\r\n//     starts with our default path prefix, followed by 'foo' and\r\n//     'bar'.\r\n//\r\n// (Yes, these scheme-less URLs that start with '//' are legal URLs.)\r\n//\r\n// You can select either DDP traffic, HTTP traffic, or both. Both\r\n// secure and insecure traffic will be gathered (assuming the proxy\r\n// service is capable, eg, has appropriate certs and port mappings).\r\n//\r\n// With no 'forwardTo' option, the traffic is received by this process\r\n// for service by the hooks in this 'webapp' package. The original URL\r\n// is preserved (that is, if you bind \"/a\", and a user visits \"/a/b\",\r\n// the app receives a request with a path of \"/a/b\", not a path of\r\n// \"/b\").\r\n//\r\n// With 'forwardTo', the process is instead sent to some other remote\r\n// host. The URL is adjusted by stripping the path components in 'url'\r\n// and putting the path components in the 'forwardTo' URL in their\r\n// place. For example, if you forward \"//somehost/a\" to\r\n// \"//otherhost/x\", and the user types \"//somehost/a/b\" into their\r\n// browser, then otherhost will receive a request with a Host header\r\n// of \"somehost\" and a path of \"/x/b\".\r\n//\r\n// The routing continues until this process exits. For now, all of the\r\n// routes must be set up ahead of time, before the initial\r\n// registration with the proxy. Calling addRoute from the top level of\r\n// your JS should do the trick.\r\n//\r\n// When multiple routes are present that match a given request, the\r\n// most specific route wins. When routes with equal specificity are\r\n// present, the proxy service will distribute the traffic between\r\n// them.\r\n//\r\n// options may be:\r\n// - ddp: if true, the default, include DDP traffic. This includes\r\n//   both secure and insecure traffic, and both websocket and sockjs\r\n//   transports.\r\n// - http: if true, the default, include HTTP/HTTPS traffic.\r\n// - forwardTo: if provided, should be a URL with a host, optional\r\n//   path and port, and no scheme (the scheme will be derived from the\r\n//   traffic type; for now it will always be a http or ws connection,\r\n//   never https or wss, but we could add a forwardSecure flag to\r\n//   re-encrypt).\r\nvar routes = [];\r\nWebAppInternals.addRoute = function (url, options) {\r\n  options = _.extend({\r\n    ddp: true,\r\n    http: true\r\n  }, options || {});\r\n\r\n  if (proxy)\r\n    // In the future, lift this restriction\r\n    throw new Error(\"Too late to add routes\");\r\n\r\n  routes.push(_.extend({ url: url }, options));\r\n};\r\n\r\n// Receive traffic on our default URL.\r\nWebAppInternals.addRoute(\"\");\r\n\r\nrunWebAppServer();\r\n\r\n\r\nvar inlineScriptsAllowed = true;\r\n\r\nWebAppInternals.inlineScriptsAllowed = function () {\r\n  return inlineScriptsAllowed;\r\n};\r\n\r\nWebAppInternals.setInlineScriptsAllowed = function (value) {\r\n  inlineScriptsAllowed = value;\r\n};\r\n\r\nWebAppInternals.setBundledJsCssPrefix = function (prefix) {\r\n  bundledJsCssPrefix = prefix;\r\n};\r\n\r\n// Packages can call `WebAppInternals.addStaticJs` to specify static\r\n// JavaScript to be included in the app. This static JS will be inlined,\r\n// unless inline scripts have been disabled, in which case it will be\r\n// served under `/<sha1 of contents>`.\r\nvar additionalStaticJs = {};\r\nWebAppInternals.addStaticJs = function (contents) {\r\n  additionalStaticJs[\"/\" + sha1(contents) + \".js\"] = contents;\r\n};\r\n\r\n// Exported for tests\r\nWebAppInternals.getBoilerplate = getBoilerplate;\r\nWebAppInternals.additionalStaticJs = additionalStaticJs;\r\n"]}