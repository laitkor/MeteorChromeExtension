{"version":3,"file":"\\packages\\binary-heap.js","sources":["binary-heap/max-heap.js","binary-heap/min-max-heap.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,sB;AACA,6D;AACA,a;AACA,kE;AACA,iB;AACA,iD;AACA,0C;AACA,8B;AACA,6E;AACA,gE;AACA,0C;AACA,iC;AACA,qF;AACA,kB;;AAEA,wE;AACA,gF;AACA,gE;AACA,gC;;AAEA,wD;;AAEA,8E;AACA,mB;AACA,oC;;AAEA,4E;AACA,gF;AACA,+E;AACA,0C;AACA,kB;;AAEA,yE;AACA,6E;AACA,iC;AACA,kC;AACA,yC;AACA,E;;AAEA,6B;AACA,mE;AACA,kC;AACA,oB;;AAEA,2C;AACA,0C;AACA,O;;AAEA,kC;AACA,iC;AACA,O;;AAEA,sB;AACA,a;;AAEA,kE;AACA,yD;AACA,wB;AACA,I;;AAEA,6B;AACA,oB;;AAEA,6C;AACA,mC;AACA,qC;AACA,wB;;AAEA,+B;AACA,gD;AACA,O;AACA,gC;AACA,iD;AACA,O;;AAEA,0B;AACA,c;;AAEA,+B;AACA,oB;AACA,K;AACA,I;;AAEA,2B;AACA,oB;;AAEA,qB;AACA,kC;AACA,gD;AACA,+B;AACA,qB;AACA,c;AACA,c;AACA,O;AACA,K;AACA,I;;AAEA,oC;AACA,oB;AACA,iC;AACA,iC;AACA,+D;AACA,I;;AAEA,iE;AACA,wB;AACA,oB;AACA,iC;AACA,I;;AAEA,gC;AACA,oB;AACA,gC;AACA,gC;;AAEA,qC;AACA,qC;;AAEA,4B;AACA,4B;AACA,I;;AAEA,sB;AACA,oB;AACA,uB;AACA,kB;AACA,4C;AACA,I;AACA,6B;AACA,oB;;AAEA,uB;AACA,iC;AACA,e;;AAEA,sC;AACA,oC;;AAEA,qC;AACA,oE;AACA,wB;AACA,oE;AACA,0B;AACA,Y;AACA,+C;AACA,gD;AACA,0C;AACA,K;AACA,I;AACA,yB;AACA,oB;;AAEA,uB;AACA,uC;AACA,sC;;AAEA,yB;AACA,8B;AACA,yB;AACA,iC;;AAEA,2C;AACA,0B;AACA,4B;AACA,c;AACA,yB;AACA,iC;AACA,O;AACA,K;AACA,I;AACA,sB;AACA,oB;AACA,iC;AACA,I;AACA,wB;AACA,oB;AACA,wB;AACA,I;AACA,sB;AACA,oB;AACA,oB;AACA,0B;AACA,I;AACA,+C;AACA,gC;AACA,oB;AACA,uC;AACA,yC;AACA,O;AACA,I;AACA,qB;AACA,oB;AACA,6B;AACA,I;AACA,kC;AACA,oB;AACA,qB;AACA,0B;AACA,sB;AACA,e;AACA,I;AACA,sB;AACA,oB;AACA,0D;AACA,iB;AACA,I;;AAEA,6B;AACA,oB;AACA,iD;AACA,I;;AAEA,2B;AACA,oB;AACA,+C;AACA,2D;AACA,iE;AACA,6D;AACA,uD;AACA,G;AACA,G;;AAEA,+C;AACA,gD;AACA,+C;;;;;;;;;;;;;;;;;;;;AChOA,qE;AACA,+C;AACA,E;AACA,gF;AACA,S;AACA,E;AACA,yE;AACA,0E;AACA,+D;AACA,gF;AACA,qB;AACA,+D;AACA,6C;AACA,kB;;AAEA,0C;AACA,+C;AACA,6B;AACA,c;AACA,E;;AAEA,sC;;AAEA,gC;AACA,6B;AACA,oB;AACA,iD;AACA,iC;AACA,I;AACA,yB;AACA,oB;AACA,oD;AACA,6B;AACA,I;AACA,sB;AACA,oB;AACA,mD;AACA,0B;AACA,I;AACA,kC;AACA,oB;AACA,wD;AACA,6C;AACA,I;AACA,sB;AACA,oB;AACA,6D;AACA,iB;AACA,I;AACA,6B;AACA,oB;AACA,wC;AACA,G;AACA,G","sourcesContent":["// Constructor of Heap\r\n// - comparator - Function - given two items returns a number\r\n// - options:\r\n//   - initData - Array - Optional - the initial data in a format:\r\n//        Object:\r\n//          - id - String - unique id of the item\r\n//          - value - Any - the data value\r\n//      each value is retained\r\n//   - IdMap - Constructor - Optional - custom IdMap class to store id->index\r\n//       mappings internally. Standard IdMap is used by default.\r\nMaxHeap = function (comparator, options) {\r\n  if (! _.isFunction(comparator))\r\n    throw new Error('Passed comparator is invalid, should be a comparison function');\r\n  var self = this;\r\n\r\n  // a C-style comparator that is given two values and returns a number,\r\n  // negative if the first value is less than the second, positive if the second\r\n  // value is greater than the first and zero if they are equal.\r\n  self._comparator = comparator;\r\n\r\n  options = _.defaults(options || {}, { IdMap: IdMap });\r\n\r\n  // _heapIdx maps an id to an index in the Heap array the corresponding value\r\n  // is located on.\r\n  self._heapIdx = new options.IdMap;\r\n\r\n  // The Heap data-structure implemented as a 0-based contiguous array where\r\n  // every item on index idx is a node in a complete binary tree. Every node can\r\n  // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every\r\n  // node has a parent on index (idx-1)/2;\r\n  self._heap = [];\r\n\r\n  // If the initial array is passed, we can build the heap in linear time\r\n  // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if\r\n  // we push elements one by one.\r\n  if (_.isArray(options.initData))\r\n    self._initFromData(options.initData);\r\n};\r\n\r\n_.extend(MaxHeap.prototype, {\r\n  // Builds a new heap in-place in linear time based on passed data\r\n  _initFromData: function (data) {\r\n    var self = this;\r\n\r\n    self._heap = _.map(data, function (o) {\r\n      return { id: o.id, value: o.value };\r\n    });\r\n\r\n    _.each(data, function (o, i) {\r\n      self._heapIdx.set(o.id, i);\r\n    });\r\n\r\n    if (! data.length)\r\n      return;\r\n\r\n    // start from the first non-leaf - the parent of the last leaf\r\n    for (var i = parentIdx(data.length - 1); i >= 0; i--)\r\n      self._downHeap(i);\r\n  },\r\n\r\n  _downHeap: function (idx) {\r\n    var self = this;\r\n\r\n    while (leftChildIdx(idx) < self.size()) {\r\n      var left = leftChildIdx(idx);\r\n      var right = rightChildIdx(idx);\r\n      var largest = idx;\r\n\r\n      if (left < self.size()) {\r\n        largest = self._maxIndex(largest, left);\r\n      }\r\n      if (right < self.size()) {\r\n        largest = self._maxIndex(largest, right);\r\n      }\r\n\r\n      if (largest === idx)\r\n        break;\r\n\r\n      self._swap(largest, idx);\r\n      idx = largest;\r\n    }\r\n  },\r\n\r\n  _upHeap: function (idx) {\r\n    var self = this;\r\n\r\n    while (idx > 0) {\r\n      var parent = parentIdx(idx);\r\n      if (self._maxIndex(parent, idx) === idx) {\r\n        self._swap(parent, idx)\r\n        idx = parent;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n\r\n  _maxIndex: function (idxA, idxB) {\r\n    var self = this;\r\n    var valueA = self._get(idxA);\r\n    var valueB = self._get(idxB);\r\n    return self._comparator(valueA, valueB) >= 0 ? idxA : idxB;\r\n  },\r\n\r\n  // Internal: gets raw data object placed on idxth place in heap\r\n  _get: function (idx) {\r\n    var self = this;\r\n    return self._heap[idx].value;\r\n  },\r\n\r\n  _swap: function (idxA, idxB) {\r\n    var self = this;\r\n    var recA = self._heap[idxA];\r\n    var recB = self._heap[idxB];\r\n\r\n    self._heapIdx.set(recA.id, idxB);\r\n    self._heapIdx.set(recB.id, idxA);\r\n\r\n    self._heap[idxA] = recB;\r\n    self._heap[idxB] = recA;\r\n  },\r\n\r\n  get: function (id) {\r\n    var self = this;\r\n    if (! self.has(id))\r\n      return null;\r\n    return self._get(self._heapIdx.get(id));\r\n  },\r\n  set: function (id, value) {\r\n    var self = this;\r\n\r\n    if (self.has(id)) {\r\n      if (self.get(id) === value)\r\n        return;\r\n\r\n      var idx = self._heapIdx.get(id);\r\n      self._heap[idx].value = value;\r\n\r\n      // Fix the new value's position\r\n      // Either bubble new value up if it is greater than its parent\r\n      self._upHeap(idx);\r\n      // or bubble it down if it is smaller than one of its children\r\n      self._downHeap(idx);\r\n    } else {\r\n      self._heapIdx.set(id, self._heap.length);\r\n      self._heap.push({ id: id, value: value });\r\n      self._upHeap(self._heap.length - 1);\r\n    }\r\n  },\r\n  remove: function (id) {\r\n    var self = this;\r\n\r\n    if (self.has(id)) {\r\n      var last = self._heap.length - 1;\r\n      var idx = self._heapIdx.get(id);\r\n\r\n      if (idx !== last) {\r\n        self._swap(idx, last);\r\n        self._heap.pop();\r\n        self._heapIdx.remove(id);\r\n\r\n        // Fix the swapped value's position\r\n        self._upHeap(idx);\r\n        self._downHeap(idx);\r\n      } else {\r\n        self._heap.pop();\r\n        self._heapIdx.remove(id);\r\n      }\r\n    }\r\n  },\r\n  has: function (id) {\r\n    var self = this;\r\n    return self._heapIdx.has(id);\r\n  },\r\n  empty: function (id) {\r\n    var self = this;\r\n    return !self.size();\r\n  },\r\n  clear: function () {\r\n    var self = this;\r\n    self._heap = [];\r\n    self._heapIdx.clear();\r\n  },\r\n  // iterate over values in no particular order\r\n  forEach: function (iterator) {\r\n    var self = this;\r\n    _.each(self._heap, function (obj) {\r\n      return iterator(obj.value, obj.id);\r\n    });\r\n  },\r\n  size: function () {\r\n    var self = this;\r\n    return self._heap.length;\r\n  },\r\n  setDefault: function (id, def) {\r\n    var self = this;\r\n    if (self.has(id))\r\n      return self.get(id);\r\n    self.set(id, def);\r\n    return def;\r\n  },\r\n  clone: function () {\r\n    var self = this;\r\n    var clone = new MaxHeap(self._comparator, self._heap);\r\n    return clone;\r\n  },\r\n\r\n  maxElementId: function () {\r\n    var self = this;\r\n    return self.size() ? self._heap[0].id : null;\r\n  },\r\n\r\n  _selfCheck: function () {\r\n    var self = this;\r\n    for (var i = 1; i < self._heap.length; i++)\r\n      if (self._maxIndex(parentIdx(i), i) !== parentIdx(i))\r\n          throw new Error(\"An item with id \" + self._heap[i].id +\r\n                          \" has a parent younger than it: \" +\r\n                          self._heap[parentIdx(i)].id);\r\n  }\r\n});\r\n\r\nfunction leftChildIdx (i) { return i * 2 + 1; }\r\nfunction rightChildIdx (i) { return i * 2 + 2; }\r\nfunction parentIdx (i) { return (i - 1) >> 1; }\r\n\r\n","// This implementation of Min/Max-Heap is just a subclass of Max-Heap\r\n// with a Min-Heap as an encapsulated property.\r\n//\r\n// Most of the operations are just proxy methods to call the same method on both\r\n// heaps.\r\n//\r\n// This implementation takes 2*N memory but is fairly simple to write and\r\n// understand. And the constant factor of a simple Heap is usually smaller\r\n// compared to other two-way priority queues like Min/Max Heaps\r\n// (http://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf)\r\n// and Interval Heaps\r\n// (http://www.cise.ufl.edu/~sahni/dsaac/enrich/c13/double.htm)\r\nMinMaxHeap = function (comparator, options) {\r\n  var self = this;\r\n\r\n  MaxHeap.call(self, comparator, options);\r\n  self._minHeap = new MaxHeap(function (a, b) {\r\n    return -comparator(a, b);\r\n  }, options);\r\n};\r\n\r\nMeteor._inherits(MinMaxHeap, MaxHeap);\r\n\r\n_.extend(MinMaxHeap.prototype, {\r\n  set: function (id, value) {\r\n    var self = this;\r\n    MaxHeap.prototype.set.apply(self, arguments);\r\n    self._minHeap.set(id, value);\r\n  },\r\n  remove: function (id) {\r\n    var self = this;\r\n    MaxHeap.prototype.remove.apply(self, arguments);\r\n    self._minHeap.remove(id);\r\n  },\r\n  clear: function () {\r\n    var self = this;\r\n    MaxHeap.prototype.clear.apply(self, arguments);\r\n    self._minHeap.clear();\r\n  },\r\n  setDefault: function (id, def) {\r\n    var self = this;\r\n    MaxHeap.prototype.setDefault.apply(self, arguments);\r\n    return self._minHeap.setDefault(id, def);\r\n  },\r\n  clone: function () {\r\n    var self = this;\r\n    var clone = new MinMaxHeap(self._comparator, self._heap);\r\n    return clone;\r\n  },\r\n  minElementId: function () {\r\n    var self = this;\r\n    return self._minHeap.maxElementId();\r\n  }\r\n});\r\n\r\n"]}