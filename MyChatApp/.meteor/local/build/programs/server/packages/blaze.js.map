{"version":3,"file":"\\packages\\blaze.js","sources":["blaze/preamble.js","blaze/exceptions.js","blaze/reactivevar.js","blaze/view.js","blaze/builtins.js","blaze/lookup.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,W;;;;;;;;;;;;;;;;;;;ACAA,c;;AAEA,2E;AACA,8E;AACA,4E;AACA,sB;AACA,E;AACA,S;AACA,E;AACA,M;AACA,Q;AACA,yB;AACA,gB;AACA,0B;AACA,I;AACA,M;AACA,E;AACA,6D;;AAEA,yD;AACA,wD;AACA,iD;AACA,kC;;AAEA,2C;AACA,kC;AACA,sC;AACA,Y;AACA,G;;AAEA,kB;AACA,wB;AACA,6B;AACA,6D;AACA,8E;AACA,gC;AACA,M;;AAEA,4E;AACA,gF;AACA,gE;AACA,4E;AACA,E;;AAEA,oD;AACA,8B;AACA,a;;AAEA,sB;AACA,S;AACA,sC;AACA,iB;AACA,8D;AACA,K;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACvDA,G;AACA,yD;AACA,E;AACA,8D;AACA,gE;AACA,6D;AACA,gB;AACA,E;AACA,uE;AACA,yE;AACA,sE;AACA,0E;AACA,E;AACA,uE;AACA,wE;AACA,8D;AACA,qE;AACA,kE;AACA,uE;AACA,uE;AACA,yE;AACA,qE;AACA,sC;AACA,E;AACA,qE;AACA,8D;AACA,G;;AAEA,yD;AACA,4C;AACA,2B;AACA,2D;;AAEA,+B;AACA,+B;AACA,iC;AACA,E;;AAEA,4D;AACA,iC;AACA,0D;AACA,iD;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,+C;AACA,kB;AACA,sB;;AAEA,uB;AACA,E;;AAEA,uD;AACA,+B;;AAEA,0E;AACA,iC;AACA,W;;AAEA,2B;AACA,qB;AACA,E;;AAEA,oD;AACA,2C;AACA,E;;;;;;;;;;;;;;;;;;;ACrEA,0C;AACA,G;AACA,iE;AACA,2B;AACA,G;AACA,uE;AACA,uE;AACA,G;AACA,oE;AACA,gE;AACA,iC;AACA,G;AACA,kE;AACA,+D;AACA,8C;AACA,G;AACA,iE;AACA,4D;AACA,G;AACA,iE;AACA,oE;AACA,+D;AACA,qE;AACA,iE;AACA,6C;AACA,G;AACA,2B;AACA,G;AACA,oE;AACA,mE;AACA,mE;AACA,gE;AACA,sE;AACA,oD;AACA,sC;AACA,qC;AACA,2B;AACA,wC;;AAEA,mC;AACA,8B;AACA,kB;AACA,c;AACA,G;AACA,mB;AACA,uB;;AAEA,qB;AACA,kB;AACA,uB;AACA,mB;AACA,mB;AACA,I;;AAEA,yD;AACA,0D;AACA,kD;AACA,yB;AACA,qC;AACA,2B;AACA,0B;AACA,yB;AACA,uB;;AAEA,uB;AACA,E;;AAEA,2D;;AAEA,gD;AACA,0D;AACA,mC;AACA,E;AACA,qD;AACA,oE;AACA,wC;AACA,E;AACA,iD;AACA,4D;AACA,oC;AACA,E;AACA,kD;AACA,8D;AACA,qC;AACA,E;;AAEA,sB;AACA,G;AACA,+D;AACA,6D;AACA,2D;AACA,8D;AACA,gE;AACA,4C;AACA,G;AACA,+D;AACA,iE;AACA,mE;AACA,8C;AACA,G;AACA,6C;AACA,sE;AACA,6D;AACA,yD;AACA,kD;AACA,2D;AACA,kB;;AAEA,qE;AACA,sE;AACA,mE;AACA,qE;AACA,sE;AACA,+C;AACA,I;AACA,qE;AACA,iE;AACA,sE;AACA,iE;AACA,iE;AACA,kE;AACA,0B;AACA,I;AACA,uE;AACA,oE;AACA,qE;AACA,oE;AACA,uE;AACA,0B;AACA,yB;AACA,6F;AACA,G;AACA,wB;AACA,0H;AACA,G;AACA,oB;AACA,6H;AACA,G;;AAEA,gD;AACA,oE;AACA,6B;AACA,O;AACA,K;AACA,8C;;AAEA,W;AACA,E;;AAEA,+C;AACA,2C;AACA,+C;AACA,uC;AACA,0D;AACA,0B;AACA,O;AACA,K;AACA,E;;AAEA,qD;AACA,yC;;AAEA,qB;AACA,wD;AACA,wB;;AAEA,wC;;AAEA,e;;AAEA,oC;AACA,8C;AACA,sD;AACA,sE;AACA,+C;AACA,0D;AACA,wC;AACA,iD;AACA,S;AACA,S;AACA,K;AACA,I;;AAEA,iB;AACA,qE;AACA,8B;AACA,gC;AACA,uC;AACA,8C;AACA,sE;AACA,wB;AACA,yB;AACA,6B;AACA,iC;AACA,8B;;AAEA,iD;AACA,yE;AACA,4D;AACA,wE;AACA,2B;AACA,0D;AACA,qC;AACA,iC;AACA,kB;AACA,gD;AACA,W;AACA,qD;AACA,uC;AACA,2B;AACA,uC;AACA,S;AACA,S;AACA,0B;;AAEA,sE;AACA,mE;AACA,kE;AACA,wD;AACA,qC;AACA,kC;AACA,S;AACA,O;;AAEA,4B;;AAEA,2D;AACA,iE;AACA,sC;AACA,yD;AACA,W;;AAEA,iC;AACA,O;;AAEA,kC;AACA,kC;AACA,0C;AACA,0B;AACA,O;AACA,K;;AAEA,kB;AACA,E;;AAEA,gE;AACA,oE;AACA,gE;AACA,sE;AACA,mE;AACA,iE;AACA,gE;AACA,oE;AACA,Y;AACA,iD;AACA,yC;;AAEA,qB;AACA,wD;AACA,wB;AACA,oC;;AAEA,wC;;AAEA,yB;AACA,wD;AACA,yB;AACA,K;AACA,0B;;AAEA,2C;;AAEA,oB;AACA,mC;AACA,8B;AACA,O;AACA,U;AACA,4B;AACA,G;;AAEA,gB;AACA,E;;AAEA,wB;AACA,yD;AACA,0B;AACA,6B;AACA,4B;AACA,+B;AACA,gC;AACA,mD;;AAEA,+D;AACA,wE;AACA,I;AACA,qC;AACA,gC;AACA,oC;AACA,4D;;AAEA,2D;AACA,gF;AACA,I;AACA,+C;AACA,uE;AACA,yD;AACA,oC;AACA,4D;;AAEA,kE;AACA,8B;AACA,G;AACA,G;;AAEA,6D;AACA,wC;AACA,0C;AACA,+B;AACA,iD;AACA,E;;AAEA,+C;AACA,sD;AACA,mC;AACA,6C;AACA,E;;AAEA,wD;AACA,sD;AACA,mC;AACA,sD;AACA,E;;AAEA,iD;AACA,uB;AACA,W;AACA,0B;;AAEA,0C;;AAEA,4D;AACA,+D;AACA,iE;;AAEA,oB;AACA,mC;AACA,E;;AAEA,qC;AACA,0B;AACA,oD;AACA,E;;AAEA,6D;AACA,+D;AACA,S;AACA,yC;AACA,8B;AACA,4D;AACA,yB;AACA,uB;AACA,U;AACA,uB;AACA,6D;AACA,gC;AACA,G;AACA,E;;AAEA,yB;;AAEA,+C;AACA,kC;AACA,O;AACA,6B;AACA,kB;AACA,a;AACA,gC;AACA,G;AACA,E;;AAEA,iC;AACA,mD;AACA,E;;AAEA,4C;AACA,4B;AACA,4C;AACA,0D;AACA,yC;AACA,E;;AAEA,+C;AACA,sD;;AAEA,W;AACA,sC;AACA,yC;AACA,yC;AACA,sC;AACA,U;AACA,0C;AACA,gF;AACA,mB;AACA,G;AACA,iD;AACA,E;;AAEA,8C;AACA,mC;AACA,yE;AACA,sD;AACA,wD;AACA,E;;AAEA,wD;AACA,mC;AACA,yE;;AAEA,qE;AACA,kC;AACA,0B;AACA,sB;AACA,G;AACA,sD;;AAEA,iB;AACA,yC;AACA,6C;AACA,6C;AACA,+C;AACA,qD;;AAEA,kE;AACA,E;;AAEA,oC;AACA,6C;AACA,gD;AACA,E;;AAEA,wD;AACA,U;AACA,wC;AACA,+B;AACA,wD;AACA,4D;AACA,4D;AACA,qD;AACA,a;AACA,gD;;AAEA,a;AACA,sC;AACA,6B;AACA,wB;AACA,U;AACA,4D;AACA,yB;AACA,gB;AACA,G;AACA,E;;AAEA,gE;AACA,4C;AACA,oC;;AAEA,iC;AACA,2B;;AAEA,sB;AACA,E;;AAEA,6C;AACA,0B;;AAEA,a;AACA,gC;AACA,uB;AACA,G;;AAEA,mB;AACA,E;;AAEA,8C;AACA,8C;AACA,kB;AACA,2B;AACA,gC;AACA,iB;AACA,4B;AACA,kC;AACA,U;AACA,+D;AACA,K;AACA,G;;AAEA,a;AACA,sC;AACA,6B;AACA,wB;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,wC;AACA,mD;AACA,gD;AACA,E;;AAEA,qC;AACA,kD;AACA,gD;AACA,E;;AAEA,+D;AACA,0C;AACA,mB;;AAEA,sB;AACA,iD;;AAEA,wE;AACA,+C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,+C;AACA,uC;AACA,0B;AACA,2D;AACA,0B;AACA,oD;AACA,wC;AACA,4D;AACA,6D;AACA,e;AACA,Y;AACA,+B;AACA,iC;AACA,c;AACA,S;AACA,O;AACA,K;;AAEA,gC;AACA,kC;AACA,e;AACA,O;AACA,uB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC7iBA,6C;AACA,iD;AACA,iB;AACA,iB;AACA,E;;AAEA,2C;AACA,6C;;AAEA,uC;;AAEA,8B;AACA,qC;AACA,sC;AACA,gC;AACA,iC;AACA,0B;AACA,Y;AACA,6B;AACA,K;AACA,K;;AAEA,c;AACA,E;;AAEA,kE;AACA,2C;;AAEA,6D;AACA,+C;AACA,qC;AACA,K;AACA,qC;AACA,8B;AACA,8B;AACA,4D;AACA,+C;AACA,wB;AACA,K;;AAEA,c;AACA,E;;AAEA,gE;AACA,uE;AACA,E;;AAEA,wD;AACA,iD;AACA,wC;AACA,gC;AACA,qC;AACA,kD;AACA,qC;AACA,K;AACA,oB;AACA,K;AACA,gC;AACA,wB;AACA,8B;AACA,6B;AACA,qC;AACA,+B;AACA,0C;;AAEA,kC;AACA,qD;AACA,gE;AACA,oD;AACA,kC;AACA,qC;AACA,4B;;AAEA,+D;AACA,mC;AACA,Q;AACA,2C;AACA,sC;AACA,mE;AACA,8B;;AAEA,0C;AACA,gD;AACA,yC;AACA,sC;AACA,gD;AACA,0C;AACA,a;;AAEA,qE;AACA,sD;AACA,kB;AACA,mE;AACA,W;AACA,W;AACA,Q;AACA,6C;AACA,sC;AACA,8B;AACA,0C;AACA,gD;AACA,yC;AACA,kD;AACA,+D;AACA,yC;AACA,0C;AACA,sC;AACA,4D;AACA,gC;AACA,a;AACA,kB;AACA,sD;AACA,W;AACA,W;AACA,Q;AACA,yD;AACA,sC;AACA,uB;AACA,0C;AACA,gD;AACA,yC;AACA,+D;AACA,kB;AACA,uD;AACA,W;AACA,wC;AACA,W;AACA,Q;AACA,wD;AACA,sC;AACA,0C;AACA,gD;AACA,yC;AACA,6D;AACA,kB;AACA,oD;AACA,+C;AACA,0C;AACA,kD;AACA,W;AACA,W;AACA,O;AACA,O;;AAEA,uD;AACA,iC;AACA,mC;AACA,mD;AACA,K;AACA,K;;AAEA,oC;AACA,4B;AACA,iC;AACA,K;;AAEA,kB;AACA,E;;AAEA,mE;AACA,6D;AACA,2C;;AAEA,iE;AACA,oE;AACA,+D;AACA,+D;AACA,kC;AACA,uC;;AAEA,8B;AACA,8C;AACA,iC;AACA,K;AACA,c;AACA,E;;;;;;;;;;;;;;;;;;;AC/KA,6C;AACA,8B;AACA,a;AACA,sB;AACA,sC;AACA,I;AACA,E;;AAEA,kD;AACA,gC;AACA,wB;AACA,wC;AACA,uB;AACA,kB;AACA,sC;AACA,M;AACA,G;AACA,W;AACA,E;;AAEA,+B;AACA,4D;AACA,E;;AAEA,2C;AACA,uD;AACA,sD;AACA,uD;AACA,qC;AACA,+B;AACA,E;AACA,sD;AACA,mD;AACA,0C;AACA,yD;AACA,+B;AACA,qD;;AAEA,yB;AACA,mE;AACA,0C;AACA,8B;AACA,uE;;AAEA,yE;;AAEA,8C;AACA,qE;AACA,2D;AACA,qC;AACA,uC;AACA,8E;AACA,U;AACA,wB;AACA,sD;AACA,wC;AACA,qD;AACA,qD;AACA,O;AACA,yD;AACA,qD;AACA,O;AACA,iB;AACA,oB;AACA,yB;AACA,oC;AACA,iC;AACA,2D;AACA,S;AACA,iB;AACA,O;AACA,sC;AACA,M;AACA,G;AACA,c;AACA,E;;AAEA,kC;AACA,6C;AACA,yD;AACA,6C;AACA,iD;AACA,mD;AACA,G;;AAEA,gB;AACA,gB;AACA,uB;AACA,yD;AACA,+B;AACA,E;;;AAGA,uD;AACA,4C;AACA,E","sourcesContent":["Blaze = {};\r\n","var debugFunc;\r\n\r\n// We call into user code in many places, and it's nice to catch exceptions\r\n// propagated from user code immediately so that the whole system doesn't just\r\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\r\n// reports exceptions.\r\n//\r\n// Usage:\r\n//\r\n// ```\r\n// try {\r\n//   // ... someStuff ...\r\n// } catch (e) {\r\n//   reportUIException(e);\r\n// }\r\n// ```\r\n//\r\n// An optional second argument overrides the default message.\r\n\r\n// Set this to `true` to cause `reportException` to throw\r\n// the next exception rather than reporting it.  This is\r\n// useful in unit tests that test error messages.\r\nBlaze._throwNextException = false;\r\n\r\nBlaze.reportException = function (e, msg) {\r\n  if (Blaze._throwNextException) {\r\n    Blaze._throwNextException = false;\r\n    throw e;\r\n  }\r\n\r\n  if (! debugFunc)\r\n    // adapted from Deps\r\n    debugFunc = function () {\r\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\r\n              ((typeof console !== \"undefined\") && console.log ? console.log :\r\n               function () {}));\r\n    };\r\n\r\n  // In Chrome, `e.stack` is a multiline string that starts with the message\r\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\r\n  // `console.log` supplies the space between the two arguments.\r\n  debugFunc()(msg || 'Exception caught in template:', e.stack || e.message);\r\n};\r\n\r\nBlaze.wrapCatchingExceptions = function (f, where) {\r\n  if (typeof f !== 'function')\r\n    return f;\r\n\r\n  return function () {\r\n    try {\r\n      return f.apply(this, arguments);\r\n    } catch (e) {\r\n      Blaze.reportException(e, 'Exception in ' + where + ':');\r\n    }\r\n  };\r\n};\r\n","/**\r\n * ## [new] Blaze.ReactiveVar(initialValue, [equalsFunc])\r\n *\r\n * A ReactiveVar holds a single value that can be get and set,\r\n * such that calling `set` will invalidate any Computations that\r\n * called `get`, according to the usual contract for reactive\r\n * data sources.\r\n *\r\n * A ReactiveVar is much like a Session variable -- compare `foo.get()`\r\n * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\r\n * automatically migrated across hot code pushes.  Also, while Session\r\n * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\r\n *\r\n * An important property of ReactiveVars, which is sometimes the reason\r\n * to use one, is that setting the value to the same value as before has\r\n * no effect, meaning ReactiveVars can be used to absorb extra\r\n * invalidations that wouldn't serve a purpose.  However, by default,\r\n * ReactiveVars are extremely conservative about what changes they\r\n * absorb.  Calling `set` with an object argument will *always* trigger\r\n * invalidations, because even if the new value is `===` the old value,\r\n * the object may have been mutated.  You can change the default behavior\r\n * by passing a function of two arguments, `oldValue` and `newValue`,\r\n * to the constructor as `equalsFunc`.\r\n *\r\n * This class is extremely basic right now, but the idea is to evolve\r\n * it into the ReactiveVar of Geoff's Lickable Forms proposal.\r\n */\r\n\r\nBlaze.ReactiveVar = function (initialValue, equalsFunc) {\r\n  if (! (this instanceof Blaze.ReactiveVar))\r\n    // called without `new`\r\n    return new Blaze.ReactiveVar(initialValue, equalsFunc);\r\n\r\n  this.curValue = initialValue;\r\n  this.equalsFunc = equalsFunc;\r\n  this.dep = new Deps.Dependency;\r\n};\r\n\r\nBlaze.ReactiveVar._isEqual = function (oldValue, newValue) {\r\n  var a = oldValue, b = newValue;\r\n  // Two values are \"equal\" here if they are `===` and are\r\n  // number, boolean, string, undefined, or null.\r\n  if (a !== b)\r\n    return false;\r\n  else\r\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\r\n            (typeof a === 'string'));\r\n};\r\n\r\nBlaze.ReactiveVar.prototype.get = function () {\r\n  if (Deps.active)\r\n    this.dep.depend();\r\n\r\n  return this.curValue;\r\n};\r\n\r\nBlaze.ReactiveVar.prototype.set = function (newValue) {\r\n  var oldValue = this.curValue;\r\n\r\n  if ((this.equalsFunc || Blaze.ReactiveVar._isEqual)(oldValue, newValue))\r\n    // value is same as last time\r\n    return;\r\n\r\n  this.curValue = newValue;\r\n  this.dep.changed();\r\n};\r\n\r\nBlaze.ReactiveVar.prototype.toString = function () {\r\n  return 'ReactiveVar{' + this.get() + '}';\r\n};\r\n","/// [new] Blaze.View([kind], renderMethod)\r\n///\r\n/// Blaze.View is the building block of reactive DOM.  Views have\r\n/// the following features:\r\n///\r\n/// * lifecycle callbacks - Views are created, rendered, and destroyed,\r\n///   and callbacks can be registered to fire when these things happen.\r\n///\r\n/// * parent pointer - A View points to its parentView, which is the\r\n///   View that caused it to be rendered.  These pointers form a\r\n///   hierarchy or tree of Views.\r\n///\r\n/// * render() method - A View's render() method specifies the DOM\r\n///   (or HTML) content of the View.  If the method establishes\r\n///   reactive dependencies, it may be re-run.\r\n///\r\n/// * a DOMRange - If a View is rendered to DOM, its position and\r\n///   extent in the DOM are tracked using a DOMRange object.\r\n///\r\n/// When a View is constructed by calling Blaze.View, the View is\r\n/// not yet considered \"created.\"  It doesn't have a parentView yet,\r\n/// and no logic has been run to initialize the View.  All real\r\n/// work is deferred until at least creation time, when the onCreated\r\n/// callbacks are fired, which happens when the View is \"used\" in\r\n/// some way that requires it to be rendered.\r\n///\r\n/// ...more lifecycle stuff\r\n///\r\n/// `kind` is an optional string tag identifying the View.  The only\r\n/// time it's used is when looking in the View tree for a View of a\r\n/// particular kind; for example, data contexts are stored on Views\r\n/// of kind \"with\".  Kinds are also useful when debugging, so in\r\n/// general it's good for functions that create Views to set the kind.\r\n/// Templates have kinds of the form \"Template.foo\".\r\nBlaze.View = function (kind, render) {\r\n  if (! (this instanceof Blaze.View))\r\n    // called without `new`\r\n    return new Blaze.View(kind, render);\r\n\r\n  if (typeof kind === 'function') {\r\n    // omitted \"kind\" argument\r\n    render = kind;\r\n    kind = '';\r\n  }\r\n  this.kind = kind;\r\n  this.render = render;\r\n\r\n  this._callbacks = {\r\n    created: null,\r\n    materialized: null,\r\n    rendered: null,\r\n    destroyed: null\r\n  };\r\n\r\n  // Setting all properties here is good for readability,\r\n  // and also may help Chrome optimize the code by keeping\r\n  // the View object from changing shape too much.\r\n  this.isCreated = false;\r\n  this.isCreatedForExpansion = false;\r\n  this.isDestroyed = false;\r\n  this.isInRender = false;\r\n  this.parentView = null;\r\n  this.domrange = null;\r\n\r\n  this.renderCount = 0;\r\n};\r\n\r\nBlaze.View.prototype.render = function () { return null; };\r\n\r\nBlaze.View.prototype.onCreated = function (cb) {\r\n  this._callbacks.created = this._callbacks.created || [];\r\n  this._callbacks.created.push(cb);\r\n};\r\nBlaze.View.prototype.onMaterialized = function (cb) {\r\n  this._callbacks.materialized = this._callbacks.materialized || [];\r\n  this._callbacks.materialized.push(cb);\r\n};\r\nBlaze.View.prototype.onRendered = function (cb) {\r\n  this._callbacks.rendered = this._callbacks.rendered || [];\r\n  this._callbacks.rendered.push(cb);\r\n};\r\nBlaze.View.prototype.onDestroyed = function (cb) {\r\n  this._callbacks.destroyed = this._callbacks.destroyed || [];\r\n  this._callbacks.destroyed.push(cb);\r\n};\r\n\r\n/// View#autorun(func)\r\n///\r\n/// Sets up a Deps autorun that is \"scoped\" to this View in two\r\n/// important ways: 1) Blaze.currentView is automatically set\r\n/// on every re-run, and 2) the autorun is stopped when the\r\n/// View is destroyed.  As with Deps.autorun, the first run of\r\n/// the function is immediate, and a Computation object that can\r\n/// be used to stop the autorun is returned.\r\n///\r\n/// View#autorun is meant to be called from View callbacks like\r\n/// onCreated, or from outside the rendering process.  It may not\r\n/// be called before the onCreated callbacks are fired (too early),\r\n/// or from a render() method (too confusing).\r\n///\r\n/// Typically, autoruns that update the state\r\n/// of the View (as in Blaze.With) should be started from an onCreated\r\n/// callback.  Autoruns that update the DOM should be started\r\n/// from either onCreated (guarded against the absence of\r\n/// view.domrange), onMaterialized, or onRendered.\r\nBlaze.View.prototype.autorun = function (f, _inViewScope) {\r\n  var self = this;\r\n\r\n  // The restrictions on when View#autorun can be called are in order\r\n  // to avoid bad patterns, like creating a Blaze.View and immediately\r\n  // calling autorun on it.  A freshly created View is not ready to\r\n  // have logic run on it; it doesn't have a parentView, for example.\r\n  // It's when the View is materialized or expanded that the onCreated\r\n  // handlers are fired and the View starts up.\r\n  //\r\n  // Letting the render() method call `this.autorun()` is problematic\r\n  // because of re-render.  The best we can do is to stop the old\r\n  // autorun and start a new one for each render, but that's a pattern\r\n  // we try to avoid internally because it leads to helpers being\r\n  // called extra times, in the case where the autorun causes the\r\n  // view to re-render (and thus the autorun to be torn down and a\r\n  // new one established).\r\n  //\r\n  // We could lift these restrictions in various ways.  One interesting\r\n  // idea is to allow you to call `view.autorun` after instantiating\r\n  // `view`, and automatically wrap it in `view.onCreated`, deferring\r\n  // the autorun so that it starts at an appropriate time.  However,\r\n  // then we can't return the Computation object to the caller, because\r\n  // it doesn't exist yet.\r\n  if (! self.isCreated) {\r\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");\r\n  }\r\n  if (this.isInRender) {\r\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\r\n  }\r\n  if (Deps.active) {\r\n    throw new Error(\"Can't call View#autorun from a Deps Computation; try calling it from the created or rendered callback\");\r\n  }\r\n\r\n  var c = Deps.autorun(function viewAutorun(c) {\r\n    return Blaze.withCurrentView(_inViewScope || self, function () {\r\n      return f.call(self, c);\r\n    });\r\n  });\r\n  self.onDestroyed(function () { c.stop(); });\r\n\r\n  return c;\r\n};\r\n\r\nBlaze._fireCallbacks = function (view, which) {\r\n  Blaze.withCurrentView(view, function () {\r\n    Deps.nonreactive(function fireCallbacks() {\r\n      var cbs = view._callbacks[which];\r\n      for (var i = 0, N = (cbs && cbs.length); i < N; i++)\r\n        cbs[i].call(view);\r\n    });\r\n  });\r\n};\r\n\r\nBlaze.materializeView = function (view, parentView) {\r\n  view.parentView = (parentView || null);\r\n\r\n  if (view.isCreated)\r\n    throw new Error(\"Can't render the same View twice\");\r\n  view.isCreated = true;\r\n\r\n  Blaze._fireCallbacks(view, 'created');\r\n\r\n  var domrange;\r\n\r\n  var needsRenderedCallback = false;\r\n  var scheduleRenderedCallback = function () {\r\n    if (needsRenderedCallback && ! view.isDestroyed &&\r\n        view._callbacks.rendered && view._callbacks.rendered.length) {\r\n      Deps.afterFlush(function callRendered() {\r\n        if (needsRenderedCallback && ! view.isDestroyed) {\r\n          needsRenderedCallback = false;\r\n          Blaze._fireCallbacks(view, 'rendered');\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  var lastHtmljs;\r\n  // We don't expect to be called in a Computation, but just in case,\r\n  // wrap in Deps.nonreactive.\r\n  Deps.nonreactive(function () {\r\n    view.autorun(function doRender(c) {\r\n      // `view.autorun` sets the current view.\r\n      // Any dependencies that should invalidate this Computation come\r\n      // from this line:\r\n      view.renderCount++;\r\n      view.isInRender = true;\r\n      var htmljs = view.render();\r\n      view.isInRender = false;\r\n\r\n      Deps.nonreactive(function doMaterialize() {\r\n        var materializer = new Blaze.DOMMaterializer({parentView: view});\r\n        var rangesAndNodes = materializer.visit(htmljs, []);\r\n        if (c.firstRun || ! Blaze._isContentEqual(lastHtmljs, htmljs)) {\r\n          if (c.firstRun) {\r\n            domrange = new Blaze.DOMRange(rangesAndNodes);\r\n            view.domrange = domrange;\r\n            domrange.view = view;\r\n          } else {\r\n            domrange.setMembers(rangesAndNodes);\r\n          }\r\n          Blaze._fireCallbacks(view, 'materialized');\r\n          needsRenderedCallback = true;\r\n          if (! c.firstRun)\r\n            scheduleRenderedCallback();\r\n        }\r\n      });\r\n      lastHtmljs = htmljs;\r\n\r\n      // Causes any nested views to stop immediately, not when we call\r\n      // `setMembers` the next time around the autorun.  Otherwise,\r\n      // helpers in the DOM tree to be replaced might be scheduled\r\n      // to re-run before we have a chance to stop them.\r\n      Deps.onInvalidate(function () {\r\n        domrange.destroyMembers();\r\n      });\r\n    });\r\n\r\n    var teardownHook = null;\r\n\r\n    domrange.onAttached(function attached(range, element) {\r\n      teardownHook = Blaze.DOMBackend.Teardown.onElementTeardown(\r\n        element, function teardown() {\r\n          Blaze.destroyView(view, true /* _skipNodes */);\r\n        });\r\n\r\n      scheduleRenderedCallback();\r\n    });\r\n\r\n    // tear down the teardown hook\r\n    view.onDestroyed(function () {\r\n      teardownHook && teardownHook.stop();\r\n      teardownHook = null;\r\n    });\r\n  });\r\n\r\n  return domrange;\r\n};\r\n\r\n// Expands a View to HTMLjs, calling `render` recursively on all\r\n// Views and evaluating any dynamic attributes.  Calls the `created`\r\n// callback, but not the `materialized` or `rendered` callbacks.\r\n// Destroys the view immediately, unless called in a Deps Computation,\r\n// in which case the view will be destroyed when the Computation is\r\n// invalidated.  If called in a Deps Computation, the result is a\r\n// reactive string; that is, the Computation will be invalidated\r\n// if any changes are made to the view or subviews that might affect\r\n// the HTML.\r\nBlaze._expandView = function (view, parentView) {\r\n  view.parentView = (parentView || null);\r\n\r\n  if (view.isCreated)\r\n    throw new Error(\"Can't render the same View twice\");\r\n  view.isCreated = true;\r\n  view.isCreatedForExpansion = true;\r\n\r\n  Blaze._fireCallbacks(view, 'created');\r\n\r\n  view.isInRender = true;\r\n  var htmljs = Blaze.withCurrentView(view, function () {\r\n    return view.render();\r\n  });\r\n  view.isInRender = false;\r\n\r\n  var result = Blaze._expand(htmljs, view);\r\n\r\n  if (Deps.active) {\r\n    Deps.onInvalidate(function () {\r\n      Blaze.destroyView(view);\r\n    });\r\n  } else {\r\n    Blaze.destroyView(view);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// Options: `parentView`\r\nBlaze.HTMLJSExpander = HTML.TransformingVisitor.extend();\r\nBlaze.HTMLJSExpander.def({\r\n  visitObject: function (x) {\r\n    if (Blaze.isTemplate(x))\r\n      x = Blaze.runTemplate(x);\r\n    if (x instanceof Blaze.View)\r\n      return Blaze._expandView(x, this.parentView);\r\n\r\n    // this will throw an error; other objects are not allowed!\r\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\r\n  },\r\n  visitAttributes: function (attrs) {\r\n    // expand dynamic attributes\r\n    if (typeof attrs === 'function')\r\n      attrs = Blaze.withCurrentView(this.parentView, attrs);\r\n\r\n    // call super (e.g. for case where `attrs` is an array)\r\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\r\n  },\r\n  visitAttribute: function (name, value, tag) {\r\n    // expand attribute values that are functions.  Any attribute value\r\n    // that contains Views must be wrapped in a function.\r\n    if (typeof value === 'function')\r\n      value = Blaze.withCurrentView(this.parentView, value);\r\n\r\n    return HTML.TransformingVisitor.prototype.visitAttribute.call(\r\n      this, name, value, tag);\r\n  }\r\n});\r\n\r\n// Return Blaze.currentView, but only if it is being rendered\r\n// (i.e. we are in its render() method).\r\nvar currentViewIfRendering = function () {\r\n  var view = Blaze.currentView;\r\n  return (view && view.isInRender) ? view : null;\r\n};\r\n\r\nBlaze._expand = function (htmljs, parentView) {\r\n  parentView = parentView || currentViewIfRendering();\r\n  return (new Blaze.HTMLJSExpander(\r\n    {parentView: parentView})).visit(htmljs);\r\n};\r\n\r\nBlaze._expandAttributes = function (attrs, parentView) {\r\n  parentView = parentView || currentViewIfRendering();\r\n  return (new Blaze.HTMLJSExpander(\r\n    {parentView: parentView})).visitAttributes(attrs);\r\n};\r\n\r\nBlaze.destroyView = function (view, _skipNodes) {\r\n  if (view.isDestroyed)\r\n    return;\r\n  view.isDestroyed = true;\r\n\r\n  Blaze._fireCallbacks(view, 'destroyed');\r\n\r\n  // Destroy views and elements recursively.  If _skipNodes,\r\n  // only recurse up to views, not elements, for the case where\r\n  // the backend (jQuery) is recursing over the elements already.\r\n\r\n  if (view.domrange)\r\n    view.domrange.destroyMembers();\r\n};\r\n\r\nBlaze.destroyNode = function (node) {\r\n  if (node.nodeType === 1)\r\n    Blaze.DOMBackend.Teardown.tearDownElement(node);\r\n};\r\n\r\n// Are the HTMLjs entities `a` and `b` the same?  We could be\r\n// more elaborate here but the point is to catch the most basic\r\n// cases.\r\nBlaze._isContentEqual = function (a, b) {\r\n  if (a instanceof HTML.Raw) {\r\n    return (b instanceof HTML.Raw) && (a.value === b.value);\r\n  } else if (a == null) {\r\n    return (b == null);\r\n  } else {\r\n    return (a === b) &&\r\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\r\n       (typeof a === 'string'));\r\n  }\r\n};\r\n\r\nBlaze.currentView = null;\r\n\r\nBlaze.withCurrentView = function (view, func) {\r\n  var oldView = Blaze.currentView;\r\n  try {\r\n    Blaze.currentView = view;\r\n    return func();\r\n  } finally {\r\n    Blaze.currentView = oldView;\r\n  }\r\n};\r\n\r\nBlaze.isTemplate = function (t) {\r\n  return t && (typeof t.__makeView === 'function');\r\n};\r\n\r\nBlaze.runTemplate = function (t/*, args*/) {\r\n  if (! Blaze.isTemplate(t))\r\n    throw new Error(\"Not a template: \" + t);\r\n  var restArgs = Array.prototype.slice.call(arguments, 1);\r\n  return t.__makeView.apply(t, restArgs);\r\n};\r\n\r\nBlaze.render = function (content, parentView) {\r\n  parentView = parentView || currentViewIfRendering();\r\n\r\n  var view;\r\n  if (typeof content === 'function') {\r\n    view = Blaze.View('render', content);\r\n  } else if (Blaze.isTemplate(content)) {\r\n    view = Blaze.runTemplate(content);\r\n  } else {\r\n    if (! (content instanceof Blaze.View))\r\n      throw new Error(\"Expected a function, template, or View in Blaze.render\");\r\n    view = content;\r\n  }\r\n  return Blaze.materializeView(view, parentView);\r\n};\r\n\r\nBlaze.toHTML = function (htmljs, parentView) {\r\n  if (typeof htmljs === 'function')\r\n    throw new Error(\"Blaze.toHTML doesn't take a function, just HTMLjs\");\r\n  parentView = parentView || currentViewIfRendering();\r\n  return HTML.toHTML(Blaze._expand(htmljs, parentView));\r\n};\r\n\r\nBlaze.toText = function (htmljs, parentView, textMode) {\r\n  if (typeof htmljs === 'function')\r\n    throw new Error(\"Blaze.toText doesn't take a function, just HTMLjs\");\r\n\r\n  if ((parentView != null) && ! (parentView instanceof Blaze.View)) {\r\n    // omitted parentView argument\r\n    textMode = parentView;\r\n    parentView = null;\r\n  }\r\n  parentView = parentView || currentViewIfRendering();\r\n\r\n  if (! textMode)\r\n    throw new Error(\"textMode required\");\r\n  if (! (textMode === HTML.TEXTMODE.STRING ||\r\n         textMode === HTML.TEXTMODE.RCDATA ||\r\n         textMode === HTML.TEXTMODE.ATTRIBUTE))\r\n    throw new Error(\"Unknown textMode: \" + textMode);\r\n\r\n  return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\r\n};\r\n\r\nBlaze.getCurrentData = function () {\r\n  var theWith = Blaze.getCurrentView('with');\r\n  return theWith ? theWith.dataVar.get() : null;\r\n};\r\n\r\n// Gets the current view or its nearest ancestor of kind\r\n// `kind`.\r\nBlaze.getCurrentView = function (kind) {\r\n  var view = Blaze.currentView;\r\n  // Better to fail in cases where it doesn't make sense\r\n  // to use Blaze.getCurrentView().  There will be a current\r\n  // view anywhere it does.  You can check Blaze.currentView\r\n  // if you want to know whether there is one or not.\r\n  if (! view)\r\n    throw new Error(\"There is no current view\");\r\n\r\n  if (kind) {\r\n    while (view && view.kind !== kind)\r\n      view = view.parentView;\r\n    return view || null;\r\n  } else {\r\n    // Blaze.getCurrentView() with no arguments just returns\r\n    // Blaze.currentView.\r\n    return view;\r\n  }\r\n};\r\n\r\n// Gets the nearest ancestor view that corresponds to a template\r\nBlaze.getCurrentTemplateView = function () {\r\n  var view = Blaze.getCurrentView();\r\n\r\n  while (view && ! view.template)\r\n    view = view.parentView;\r\n\r\n  return view || null;\r\n};\r\n\r\nBlaze.getParentView = function (view, kind) {\r\n  var v = view.parentView;\r\n\r\n  if (kind) {\r\n    while (v && v.kind !== kind)\r\n      v = v.parentView;\r\n  }\r\n\r\n  return v || null;\r\n};\r\n\r\nBlaze.getElementView = function (elem, kind) {\r\n  var range = Blaze.DOMRange.forElement(elem);\r\n  var view = null;\r\n  while (range && ! view) {\r\n    view = (range.view || null);\r\n    if (! view) {\r\n      if (range.parentRange)\r\n        range = range.parentRange;\r\n      else\r\n        range = Blaze.DOMRange.forElement(range.parentElement);\r\n    }\r\n  }\r\n\r\n  if (kind) {\r\n    while (view && view.kind !== kind)\r\n      view = view.parentView;\r\n    return view || null;\r\n  } else {\r\n    return view;\r\n  }\r\n};\r\n\r\nBlaze.getElementData = function (elem) {\r\n  var theWith = Blaze.getElementView(elem, 'with');\r\n  return theWith ? theWith.dataVar.get() : null;\r\n};\r\n\r\nBlaze.getViewData = function (view) {\r\n  var theWith = Blaze.getParentView(view, 'with');\r\n  return theWith ? theWith.dataVar.get() : null;\r\n};\r\n\r\nBlaze._addEventMap = function (view, eventMap, thisInHandler) {\r\n  thisInHandler = (thisInHandler || null);\r\n  var handles = [];\r\n\r\n  if (! view.domrange)\r\n    throw new Error(\"View must have a DOMRange\");\r\n\r\n  view.domrange.onAttached(function attached_eventMaps(range, element) {\r\n    _.each(eventMap, function (handler, spec) {\r\n      var clauses = spec.split(/,\\s+/);\r\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\r\n      _.each(clauses, function (clause) {\r\n        var parts = clause.split(/\\s+/);\r\n        if (parts.length === 0)\r\n          return;\r\n\r\n        var newEvents = parts.shift();\r\n        var selector = parts.join(' ');\r\n        handles.push(Blaze.EventSupport.listen(\r\n          element, newEvents, selector,\r\n          function (evt) {\r\n            if (! range.containsElement(evt.currentTarget))\r\n              return null;\r\n            var handlerThis = thisInHandler || this;\r\n            var handlerArgs = arguments;\r\n            return Blaze.withCurrentView(view, function () {\r\n              return handler.apply(handlerThis, handlerArgs);\r\n            });\r\n          },\r\n          range, function (r) {\r\n            return r.parentRange;\r\n          }));\r\n      });\r\n    });\r\n  });\r\n\r\n  view.onDestroyed(function () {\r\n    _.each(handles, function (h) {\r\n      h.stop();\r\n    });\r\n    handles.length = 0;\r\n  });\r\n};\r\n","Blaze._calculateCondition = function (cond) {\r\n  if (cond instanceof Array && cond.length === 0)\r\n    cond = false;\r\n  return !! cond;\r\n};\r\n\r\nBlaze.With = function (data, contentFunc) {\r\n  var view = Blaze.View('with', contentFunc);\r\n\r\n  view.dataVar = new Blaze.ReactiveVar;\r\n\r\n  view.onCreated(function () {\r\n    if (typeof data === 'function') {\r\n      // `data` is a reactive function\r\n      view.autorun(function () {\r\n        view.dataVar.set(data());\r\n      }, view.parentView);\r\n    } else {\r\n      view.dataVar.set(data);\r\n    }\r\n  });\r\n\r\n  return view;\r\n};\r\n\r\nBlaze.If = function (conditionFunc, contentFunc, elseFunc, _not) {\r\n  var conditionVar = new Blaze.ReactiveVar;\r\n\r\n  var view = Blaze.View(_not ? 'unless' : 'if', function () {\r\n    return conditionVar.get() ? contentFunc() :\r\n      (elseFunc ? elseFunc() : null);\r\n  });\r\n  view.__conditionVar = conditionVar;\r\n  view.onCreated(function () {\r\n    this.autorun(function () {\r\n      var cond = Blaze._calculateCondition(conditionFunc());\r\n      conditionVar.set(_not ? (! cond) : cond);\r\n    }, this.parentView);\r\n  });\r\n\r\n  return view;\r\n};\r\n\r\nBlaze.Unless = function (conditionFunc, contentFunc, elseFunc) {\r\n  return Blaze.If(conditionFunc, contentFunc, elseFunc, true /*_not*/);\r\n};\r\n\r\nBlaze.Each = function (argFunc, contentFunc, elseFunc) {\r\n  var eachView = Blaze.View('each', function () {\r\n    var subviews = this.initialSubviews;\r\n    this.initialSubviews = null;\r\n    if (this.isCreatedForExpansion) {\r\n      this.expandedValueDep = new Deps.Dependency;\r\n      this.expandedValueDep.depend();\r\n    }\r\n    return subviews;\r\n  });\r\n  eachView.initialSubviews = [];\r\n  eachView.numItems = 0;\r\n  eachView.inElseMode = false;\r\n  eachView.stopHandle = null;\r\n  eachView.contentFunc = contentFunc;\r\n  eachView.elseFunc = elseFunc;\r\n  eachView.argVar = new Blaze.ReactiveVar;\r\n\r\n  eachView.onCreated(function () {\r\n    // We evaluate argFunc in an autorun to make sure\r\n    // Blaze.currentView is always set when it runs (rather than\r\n    // passing argFunc straight to ObserveSequence).\r\n    eachView.autorun(function () {\r\n      eachView.argVar.set(argFunc());\r\n    }, eachView.parentView);\r\n\r\n    eachView.stopHandle = ObserveSequence.observe(function () {\r\n      return eachView.argVar.get();\r\n    }, {\r\n      addedAt: function (id, item, index) {\r\n        Deps.nonreactive(function () {\r\n          var newItemView = Blaze.With(item, eachView.contentFunc);\r\n          eachView.numItems++;\r\n\r\n          if (eachView.expandedValueDep) {\r\n            eachView.expandedValueDep.changed();\r\n          } else if (eachView.domrange) {\r\n            if (eachView.inElseMode) {\r\n              eachView.domrange.removeMember(0);\r\n              eachView.inElseMode = false;\r\n            }\r\n\r\n            var range = Blaze.materializeView(newItemView, eachView);\r\n            eachView.domrange.addMember(range, index);\r\n          } else {\r\n            eachView.initialSubviews.splice(index, 0, newItemView);\r\n          }\r\n        });\r\n      },\r\n      removedAt: function (id, item, index) {\r\n        Deps.nonreactive(function () {\r\n          eachView.numItems--;\r\n          if (eachView.expandedValueDep) {\r\n            eachView.expandedValueDep.changed();\r\n          } else if (eachView.domrange) {\r\n            eachView.domrange.removeMember(index);\r\n            if (eachView.elseFunc && eachView.numItems === 0) {\r\n              eachView.inElseMode = true;\r\n              eachView.domrange.addMember(\r\n                Blaze.materializeView(\r\n                  Blaze.View('each_else',eachView.elseFunc),\r\n                  eachView), 0);\r\n            }\r\n          } else {\r\n            eachView.initialSubviews.splice(index, 1);\r\n          }\r\n        });\r\n      },\r\n      changedAt: function (id, newItem, oldItem, index) {\r\n        Deps.nonreactive(function () {\r\n          var itemView;\r\n          if (eachView.expandedValueDep) {\r\n            eachView.expandedValueDep.changed();\r\n          } else if (eachView.domrange) {\r\n            itemView = eachView.domrange.getMember(index).view;\r\n          } else {\r\n            itemView = eachView.initialSubviews[index];\r\n          }\r\n          itemView.dataVar.set(newItem);\r\n        });\r\n      },\r\n      movedTo: function (id, item, fromIndex, toIndex) {\r\n        Deps.nonreactive(function () {\r\n          if (eachView.expandedValueDep) {\r\n            eachView.expandedValueDep.changed();\r\n          } else if (eachView.domrange) {\r\n            eachView.domrange.moveMember(fromIndex, toIndex);\r\n          } else {\r\n            var subviews = eachView.initialSubviews;\r\n            var itemView = subviews[fromIndex];\r\n            subviews.splice(fromIndex, 1);\r\n            subviews.splice(toIndex, 0, itemView);\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    if (eachView.elseFunc && eachView.numItems === 0) {\r\n      eachView.inElseMode = true;\r\n      eachView.initialSubviews[0] =\r\n        Blaze.View('each_else', eachView.elseFunc);\r\n    }\r\n  });\r\n\r\n  eachView.onDestroyed(function () {\r\n    if (eachView.stopHandle)\r\n      eachView.stopHandle.stop();\r\n  });\r\n\r\n  return eachView;\r\n};\r\n\r\nBlaze.InOuterTemplateScope = function (templateView, contentFunc) {\r\n  var view = Blaze.View('InOuterTemplateScope', contentFunc);\r\n  var parentView = templateView.parentView;\r\n\r\n  // Hack so that if you call `{{> foo bar}}` and it expands into\r\n  // `{{#with bar}}{{> foo}}{{/with}}`, and then `foo` is a template\r\n  // that inserts `{{> UI.contentBlock}}`, the data context for\r\n  // `UI.contentBlock` is not `bar` but the one enclosing that.\r\n  if (parentView.__isTemplateWith)\r\n    parentView = parentView.parentView;\r\n\r\n  view.onCreated(function () {\r\n    this.originalParentView = this.parentView;\r\n    this.parentView = parentView;\r\n  });\r\n  return view;\r\n};\r\n","var bindIfIsFunction = function (x, target) {\r\n  if (typeof x !== 'function')\r\n    return x;\r\n  return function () {\r\n    return x.apply(target, arguments);\r\n  };\r\n};\r\n\r\nvar bindToCurrentDataIfIsFunction = function (x) {\r\n  if (typeof x === 'function') {\r\n    return function () {\r\n      var data = Blaze.getCurrentData();\r\n      if (data == null)\r\n        data = {};\r\n      return x.apply(data, arguments);\r\n    };\r\n  }\r\n  return x;\r\n};\r\n\r\nvar wrapHelper = function (f) {\r\n  return Blaze.wrapCatchingExceptions(f, 'template helper');\r\n};\r\n\r\n// Implements {{foo}} where `name` is \"foo\"\r\n// and `component` is the component the tag is found in\r\n// (the lexical \"self,\" on which to look for methods).\r\n// If a function is found, it is bound to the object it\r\n// was found on.  Returns a function,\r\n// non-function value, or null.\r\n//\r\n// NOTE: This function must not establish any reactive\r\n// dependencies.  If there is any reactivity in the\r\n// value, lookup should return a function.\r\nBlaze.View.prototype.lookup = function (name, _options) {\r\n  var template = this.template;\r\n  var lookupTemplate = _options && _options.template;\r\n\r\n  if (/^\\./.test(name)) {\r\n    // starts with a dot. must be a series of dots which maps to an\r\n    // ancestor of the appropriate height.\r\n    if (!/^(\\.)+$/.test(name))\r\n      throw new Error(\"id starting with dot must be a series of dots\");\r\n\r\n    return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\r\n\r\n  } else if (template && (name in template)) {\r\n    return wrapHelper(bindToCurrentDataIfIsFunction(template[name]));\r\n  } else if (lookupTemplate && Template.__lookup__(name)) {\r\n    return Template.__lookup__(name);\r\n  } else if (UI._globalHelpers[name]) {\r\n    return wrapHelper(bindToCurrentDataIfIsFunction(UI._globalHelpers[name]));\r\n  } else {\r\n    return function () {\r\n      var isCalledAsFunction = (arguments.length > 0);\r\n      var data = Blaze.getCurrentData();\r\n      if (lookupTemplate && ! (data && data[name])) {\r\n        throw new Error(\"No such template: \" + name);\r\n      }\r\n      if (isCalledAsFunction && ! (data && data[name])) {\r\n        throw new Error(\"No such function: \" + name);\r\n      }\r\n      if (! data)\r\n        return null;\r\n      var x = data[name];\r\n      if (typeof x !== 'function') {\r\n        if (isCalledAsFunction) {\r\n          throw new Error(\"Can't call non-function: \" + x);\r\n        }\r\n        return x;\r\n      }\r\n      return x.apply(data, arguments);\r\n    };\r\n  }\r\n  return null;\r\n};\r\n\r\n// Implement Spacebars' {{../..}}.\r\n// @param height {Number} The number of '..'s\r\nBlaze._parentData = function (height, _functionWrapped) {\r\n  var theWith = Blaze.getCurrentView('with');\r\n  for (var i = 0; (i < height) && theWith; i++) {\r\n    theWith = Blaze.getParentView(theWith, 'with');\r\n  }\r\n\r\n  if (! theWith)\r\n    return null;\r\n  if (_functionWrapped)\r\n    return function () { return theWith.dataVar.get(); };\r\n  return theWith.dataVar.get();\r\n};\r\n\r\n\r\nBlaze.View.prototype.lookupTemplate = function (name) {\r\n  return this.lookup(name, {template:true});\r\n};\r\n"]}