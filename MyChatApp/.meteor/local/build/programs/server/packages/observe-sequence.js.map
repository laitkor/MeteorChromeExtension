{"version":3,"file":"\\packages\\observe-sequence.js","sources":["observe-sequence/observe_sequence.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,wB;AACA,0C;AACA,wC;AACA,U;AACA,uD;AACA,6C;;AAEA,sC;AACA,G;AACA,E;;AAEA,+C;AACA,uC;;AAEA,mB;AACA,uB;AACA,qB;;AAEA,oE;AACA,wE;AACA,4B;AACA,I;AACA,mE;AACA,mE;AACA,oC;AACA,I;AACA,8D;AACA,6C;AACA,oE;AACA,qE;AACA,mC;AACA,I;AACA,+C;AACA,mD;AACA,0C;AACA,0D;AACA,I;AACA,sE;AACA,kD;AACA,I;AACA,wE;AACA,2E;AACA,0E;AACA,8D;AACA,oE;AACA,+C;AACA,I;AACA,0D;AACA,2D;AACA,I;AACA,oE;AACA,6D;AACA,gE;AACA,oE;AACA,oE;AACA,oC;AACA,+C;AACA,uB;AACA,mC;;AAEA,iE;AACA,gE;AACA,iE;AACA,8B;AACA,M;AACA,qE;AACA,iE;AACA,M;AACA,gC;AACA,qC;AACA,4C;AACA,M;AACA,wD;AACA,M;AACA,oE;AACA,iE;AACA,+C;AACA,sE;AACA,gD;AACA,+B;;AAEA,oC;AACA,gE;;AAEA,8E;AACA,8E;AACA,kE;AACA,kC;AACA,6E;AACA,6C;AACA,a;AACA,qC;AACA,qC;AACA,S;;AAEA,mB;AACA,wB;AACA,uD;AACA,0C;AACA,2B;AACA,wD;AACA,mB;AACA,2C;AACA,uF;AACA,8B;AACA,kD;AACA,mD;AACA,4C;AACA,wB;AACA,kD;AACA,+C;AACA,oB;AACA,wE;AACA,iE;AACA,a;;AAEA,2C;AACA,oC;AACA,4D;AACA,wD;AACA,+B;AACA,oB;AACA,uC;AACA,a;;AAEA,2C;AACA,a;;AAEA,uD;AACA,wC;AACA,2B;AACA,wB;;AAEA,2E;AACA,gD;AACA,2D;AACA,4B;AACA,sE;AACA,qC;AACA,oC;AACA,iF;AACA,qE;AACA,sB;AACA,2E;AACA,e;AACA,c;AACA,qE;AACA,4E;AACA,2C;AACA,c;AACA,wD;AACA,yE;AACA,c;AACA,sE;AACA,gC;AACA,oE;AACA,a;AACA,a;AACA,0B;;AAEA,gF;AACA,0D;AACA,uD;;AAEA,gB;AACA,mC;AACA,S;;AAEA,sB;AACA,gC;AACA,S;AACA,O;;AAEA,Y;AACA,yB;AACA,2B;AACA,gC;AACA,qC;AACA,O;AACA,M;AACA,I;;AAEA,yE;AACA,mE;AACA,+B;AACA,yB;AACA,e;AACA,gB;AACA,sC;AACA,iB;AACA,oC;AACA,yB;AACA,Y;AACA,+B;AACA,K;AACA,G;AACA,E;;AAEA,oC;AACA,wD;AACA,wD;AACA,E;;AAEA,uC;AACA,wC;AACA,+D;AACA,E;;AAEA,wD;AACA,+D;AACA,oD;AACA,8D;AACA,0E;AACA,wB;AACA,wB;AACA,iD;AACA,2B;AACA,kB;AACA,sC;;AAEA,sC;AACA,sC;AACA,qC;AACA,K;AACA,0C;AACA,sC;AACA,qC;AACA,qC;AACA,K;;AAEA,4D;AACA,kE;AACA,gE;AACA,sB;AACA,sC;AACA,6C;AACA,sE;;AAEA,yC;AACA,4B;AACA,uB;AACA,S;;AAEA,kB;AACA,yC;;AAEA,wB;AACA,W;AACA,+C;AACA,iB;AACA,gB;AACA,M;AACA,wC;AACA,iD;AACA,0E;;AAEA,yC;AACA,mD;AACA,uB;AACA,wD;AACA,uB;AACA,S;;AAEA,yC;;AAEA,wB;AACA,W;AACA,+C;AACA,qB;AACA,iB;AACA,gB;AACA,M;AACA,4B;AACA,iD;;AAEA,yC;AACA,gC;AACA,uB;AACA,S;;AAEA,qC;AACA,kB;;AAEA,0B;AACA,W;AACA,mD;AACA,sB;AACA,K;AACA,K;;AAEA,2C;AACA,+B;AACA,kC;AACA,kE;AACA,mE;AACA,mE;AACA,sE;AACA,2D;AACA,oE;AACA,0C;AACA,uC;AACA,wD;;AAEA,6D;AACA,yD;AACA,O;AACA,K;AACA,E","sourcesContent":["var warn = function () {\r\n  if (ObserveSequence._suppressWarnings) {\r\n    ObserveSequence._suppressWarnings--;\r\n  } else {\r\n    if (typeof console !== 'undefined' && console.warn)\r\n      console.warn.apply(console, arguments);\r\n\r\n    ObserveSequence._loggedWarnings++;\r\n  }\r\n};\r\n\r\nvar idStringify = LocalCollection._idStringify;\r\nvar idParse = LocalCollection._idParse;\r\n\r\nObserveSequence = {\r\n  _suppressWarnings: 0,\r\n  _loggedWarnings: 0,\r\n\r\n  // A mechanism similar to cursor.observe which receives a reactive\r\n  // function returning a sequence type and firing appropriate callbacks\r\n  // when the value changes.\r\n  //\r\n  // @param sequenceFunc {Function} a reactive function returning a\r\n  //     sequence type. The currently supported sequence types are:\r\n  //     'null', arrays and cursors.\r\n  //\r\n  // @param callbacks {Object} similar to a specific subset of\r\n  //     callbacks passed to `cursor.observe`\r\n  //     (http://docs.meteor.com/#observe), with minor variations to\r\n  //     support the fact that not all sequences contain objects with\r\n  //     _id fields.  Specifically:\r\n  //\r\n  //     * addedAt(id, item, atIndex, beforeId)\r\n  //     * changedAt(id, newItem, oldItem, atIndex)\r\n  //     * removedAt(id, oldItem, atIndex)\r\n  //     * movedTo(id, item, fromIndex, toIndex, beforeId)\r\n  //\r\n  // @returns {Object(stop: Function)} call 'stop' on the return value\r\n  //     to stop observing this sequence function.\r\n  //\r\n  // We don't make any assumptions about our ability to compare sequence\r\n  // elements (ie, we don't assume EJSON.equals works; maybe there is extra\r\n  // state/random methods on the objects) so unlike cursor.observe, we may\r\n  // sometimes call changedAt() when nothing actually changed.\r\n  // XXX consider if we *can* make the stronger assumption and avoid\r\n  //     no-op changedAt calls (in some cases?)\r\n  //\r\n  // XXX currently only supports the callbacks used by our\r\n  // implementation of {{#each}}, but this can be expanded.\r\n  //\r\n  // XXX #each doesn't use the indices (though we'll eventually need\r\n  // a way to get them when we support `@index`), but calling\r\n  // `cursor.observe` causes the index to be calculated on every\r\n  // callback using a linear scan (unless you turn it off by passing\r\n  // `_no_indices`).  Any way to avoid calculating indices on a pure\r\n  // cursor observe like we used to?\r\n  observe: function (sequenceFunc, callbacks) {\r\n    var lastSeq = null;\r\n    var activeObserveHandle = null;\r\n\r\n    // 'lastSeqArray' contains the previous value of the sequence\r\n    // we're observing. It is an array of objects with '_id' and\r\n    // 'item' fields.  'item' is the element in the array, or the\r\n    // document in the cursor.\r\n    //\r\n    // '_id' is whichever of the following is relevant, unless it has\r\n    // already appeared -- in which case it's randomly generated.\r\n    //\r\n    // * if 'item' is an object:\r\n    //   * an '_id' field, if present\r\n    //   * otherwise, the index in the array\r\n    //\r\n    // * if 'item' is a number or string, use that value\r\n    //\r\n    // XXX this can be generalized by allowing {{#each}} to accept a\r\n    // general 'key' argument which could be a function, a dotted\r\n    // field name, or the special @index value.\r\n    var lastSeqArray = []; // elements are objects of form {_id, item}\r\n    var computation = Deps.autorun(function () {\r\n      var seq = sequenceFunc();\r\n\r\n      Deps.nonreactive(function () {\r\n        var seqArray; // same structure as `lastSeqArray` above.\r\n\r\n        // If we were previously observing a cursor, replace lastSeqArray with\r\n        // more up-to-date information (specifically, the state of the observe\r\n        // before it was stopped, which may be older than the DB).\r\n        if (activeObserveHandle) {\r\n          lastSeqArray = _.map(activeObserveHandle._fetch(), function (doc) {\r\n            return {_id: doc._id, item: doc};\r\n          });\r\n          activeObserveHandle.stop();\r\n          activeObserveHandle = null;\r\n        }\r\n\r\n        if (!seq) {\r\n          seqArray = [];\r\n          diffArray(lastSeqArray, seqArray, callbacks);\r\n        } else if (seq instanceof Array) {\r\n          var idsUsed = {};\r\n          seqArray = _.map(seq, function (item, index) {\r\n            var id;\r\n            if (typeof item === 'string') {\r\n              // ensure not empty, since other layers (eg DomRange) assume this as well\r\n              id = \"-\" + item;\r\n            } else if (typeof item === 'number' ||\r\n                       typeof item === 'boolean' ||\r\n                       item === undefined) {\r\n              id = item;\r\n            } else if (typeof item === 'object') {\r\n              id = (item && item._id) || index;\r\n            } else {\r\n              throw new Error(\"{{#each}} doesn't support arrays with \" +\r\n                              \"elements of type \" + typeof item);\r\n            }\r\n\r\n            var idString = idStringify(id);\r\n            if (idsUsed[idString]) {\r\n              if (typeof item === 'object' && '_id' in item)\r\n                warn(\"duplicate id \" + id + \" in\", seq);\r\n              id = Random.id();\r\n            } else {\r\n              idsUsed[idString] = true;\r\n            }\r\n\r\n            return { _id: id, item: item };\r\n          });\r\n\r\n          diffArray(lastSeqArray, seqArray, callbacks);\r\n        } else if (isStoreCursor(seq)) {\r\n          var cursor = seq;\r\n          seqArray = [];\r\n\r\n          var initial = true; // are we observing initial data from cursor?\r\n          activeObserveHandle = cursor.observe({\r\n            addedAt: function (document, atIndex, before) {\r\n              if (initial) {\r\n                // keep track of initial data so that we can diff once\r\n                // we exit `observe`.\r\n                if (before !== null)\r\n                  throw new Error(\"Expected initial data from observe in order\");\r\n                seqArray.push({ _id: document._id, item: document });\r\n              } else {\r\n                callbacks.addedAt(document._id, document, atIndex, before);\r\n              }\r\n            },\r\n            changedAt: function (newDocument, oldDocument, atIndex) {\r\n              callbacks.changedAt(newDocument._id, newDocument, oldDocument,\r\n                                  atIndex);\r\n            },\r\n            removedAt: function (oldDocument, atIndex) {\r\n              callbacks.removedAt(oldDocument._id, oldDocument, atIndex);\r\n            },\r\n            movedTo: function (document, fromIndex, toIndex, before) {\r\n              callbacks.movedTo(\r\n                document._id, document, fromIndex, toIndex, before);\r\n            }\r\n          });\r\n          initial = false;\r\n\r\n          // diff the old sequnce with initial data in the new cursor. this will\r\n          // fire `addedAt` callbacks on the initial data.\r\n          diffArray(lastSeqArray, seqArray, callbacks);\r\n\r\n        } else {\r\n          throw badSequenceError();\r\n        }\r\n\r\n        lastSeq = seq;\r\n        lastSeqArray = seqArray;\r\n      });\r\n    });\r\n\r\n    return {\r\n      stop: function () {\r\n        computation.stop();\r\n        if (activeObserveHandle)\r\n          activeObserveHandle.stop();\r\n      }\r\n    };\r\n  },\r\n\r\n  // Fetch the items of `seq` into an array, where `seq` is of one of the\r\n  // sequence types accepted by `observe`.  If `seq` is a cursor, a\r\n  // dependency is established.\r\n  fetch: function (seq) {\r\n    if (!seq) {\r\n      return [];\r\n    } else if (seq instanceof Array) {\r\n      return seq;\r\n    } else if (isStoreCursor(seq)) {\r\n      return seq.fetch();\r\n    } else {\r\n      throw badSequenceError();\r\n    }\r\n  }\r\n};\r\n\r\nvar badSequenceError = function () {\r\n  return new Error(\"{{#each}} currently only accepts \" +\r\n                   \"arrays, cursors or falsey values.\");\r\n};\r\n\r\nvar isStoreCursor = function (cursor) {\r\n  return cursor && _.isObject(cursor) &&\r\n    _.isFunction(cursor.observe) && _.isFunction(cursor.fetch);\r\n};\r\n\r\n// Calculates the differences between `lastSeqArray` and\r\n// `seqArray` and calls appropriate functions from `callbacks`.\r\n// Reuses Minimongo's diff algorithm implementation.\r\nvar diffArray = function (lastSeqArray, seqArray, callbacks) {\r\n  var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges;\r\n  var oldIdObjects = [];\r\n  var newIdObjects = [];\r\n  var posOld = {}; // maps from idStringify'd ids\r\n  var posNew = {}; // ditto\r\n  var posCur = {};\r\n  var lengthCur = lastSeqArray.length;\r\n\r\n  _.each(seqArray, function (doc, i) {\r\n    newIdObjects.push({_id: doc._id});\r\n    posNew[idStringify(doc._id)] = i;\r\n  });\r\n  _.each(lastSeqArray, function (doc, i) {\r\n    oldIdObjects.push({_id: doc._id});\r\n    posOld[idStringify(doc._id)] = i;\r\n    posCur[idStringify(doc._id)] = i;\r\n  });\r\n\r\n  // Arrays can contain arbitrary objects. We don't diff the\r\n  // objects. Instead we always fire 'changedAt' callback on every\r\n  // object. The consumer of `observe-sequence` should deal with\r\n  // it appropriately.\r\n  diffFn(oldIdObjects, newIdObjects, {\r\n    addedBefore: function (id, doc, before) {\r\n      var position = before ? posCur[idStringify(before)] : lengthCur;\r\n\r\n      _.each(posCur, function (pos, id) {\r\n        if (pos >= position)\r\n          posCur[id]++;\r\n      });\r\n\r\n      lengthCur++;\r\n      posCur[idStringify(id)] = position;\r\n\r\n      callbacks.addedAt(\r\n        id,\r\n        seqArray[posNew[idStringify(id)]].item,\r\n        position,\r\n        before);\r\n    },\r\n    movedBefore: function (id, before) {\r\n      var prevPosition = posCur[idStringify(id)];\r\n      var position = before ? posCur[idStringify(before)] : lengthCur - 1;\r\n\r\n      _.each(posCur, function (pos, id) {\r\n        if (pos >= prevPosition && pos <= position)\r\n          posCur[id]--;\r\n        else if (pos <= prevPosition && pos >= position)\r\n          posCur[id]++;\r\n      });\r\n\r\n      posCur[idStringify(id)] = position;\r\n\r\n      callbacks.movedTo(\r\n        id,\r\n        seqArray[posNew[idStringify(id)]].item,\r\n        prevPosition,\r\n        position,\r\n        before);\r\n    },\r\n    removed: function (id) {\r\n      var prevPosition = posCur[idStringify(id)];\r\n\r\n      _.each(posCur, function (pos, id) {\r\n        if (pos >= prevPosition)\r\n          posCur[id]--;\r\n      });\r\n\r\n      delete posCur[idStringify(id)];\r\n      lengthCur--;\r\n\r\n      callbacks.removedAt(\r\n        id,\r\n        lastSeqArray[posOld[idStringify(id)]].item,\r\n        prevPosition);\r\n    }\r\n  });\r\n\r\n  _.each(posNew, function (pos, idString) {\r\n    var id = idParse(idString);\r\n    if (_.has(posOld, idString)) {\r\n      // specifically for primitive types, compare equality before\r\n      // firing the 'changedAt' callback. otherwise, always fire it\r\n      // because doing a deep EJSON comparison is not guaranteed to\r\n      // work (an array can contain arbitrary objects, and 'transform'\r\n      // can be used on cursors). also, deep diffing is not\r\n      // necessarily the most efficient (if only a specific subfield\r\n      // of the object is later accessed).\r\n      var newItem = seqArray[pos].item;\r\n      var oldItem = lastSeqArray[posOld[idString]].item;\r\n\r\n      if (typeof newItem === 'object' || newItem !== oldItem)\r\n          callbacks.changedAt(id, newItem, oldItem, pos);\r\n      }\r\n  });\r\n};\r\n"]}