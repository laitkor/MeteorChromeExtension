{"version":3,"file":"\\packages\\spacebars-compiler.js","sources":["spacebars-compiler/templatetag.js","spacebars-compiler/optimizer.js","spacebars-compiler/codegen.js","spacebars-compiler/compiler.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,uB;;AAEA,iE;AACA,E;AACA,0C;AACA,E;AACA,2B;AACA,6B;AACA,8B;AACA,gC;AACA,+B;AACA,gC;AACA,0B;AACA,E;AACA,iE;AACA,E;AACA,yE;AACA,2E;AACA,oB;AACA,E;AACA,wE;AACA,sE;AACA,2E;AACA,uE;AACA,sC;AACA,E;AACA,gE;AACA,E;AACA,qD;AACA,E;AACA,6E;AACA,yE;AACA,qD;AACA,mC;AACA,E;AACA,sE;AACA,sE;AACA,6B;;AAEA,4D;;AAEA,2D;AACA,+C;AACA,E;AACA,kD;AACA,wE;;AAEA,4C;AACA,oD;AACA,6C;AACA,E;;AAEA,c;AACA,0D;AACA,oD;AACA,sD;AACA,uD;AACA,gD;AACA,2D;AACA,2D;AACA,4D;AACA,E;;AAEA,Y;AACA,qB;AACA,sB;AACA,E;;AAEA,iE;AACA,qE;AACA,yE;AACA,6C;AACA,gD;AACA,gC;AACA,kC;AACA,qD;;AAEA,kC;AACA,gD;AACA,gB;;AAEA,8B;AACA,yC;AACA,4C;AACA,iB;AACA,kB;AACA,wB;AACA,8B;AACA,e;AACA,I;;AAEA,mC;AACA,0B;AACA,I;;AAEA,iD;AACA,qD;AACA,a;AACA,6B;AACA,wB;AACA,2D;AACA,yF;;AAEA,c;AACA,I;;AAEA,8B;AACA,sB;;AAEA,oE;AACA,a;AACA,mC;AACA,4D;AACA,2C;;AAEA,wB;AACA,iC;;AAEA,0D;AACA,0B;AACA,sD;AACA,iD;AACA,gB;AACA,iC;AACA,sC;AACA,S;;AAEA,+B;AACA,6B;AACA,S;;AAEA,iC;;AAEA,yB;AACA,wB;AACA,K;;AAEA,kB;AACA,4B;;AAEA,uB;AACA,qC;AACA,kB;AACA,6C;AACA,+B;AACA,uC;AACA,sD;AACA,2B;AACA,c;AACA,mD;AACA,4B;AACA,kC;AACA,6B;AACA,+B;AACA,kB;AACA,oI;AACA,W;AACA,gB;AACA,4B;AACA,S;AACA,O;;AAEA,+B;AACA,gB;AACA,c;AACA,K;;AAEA,oB;AACA,I;;AAEA,mD;AACA,sC;AACA,kD;AACA,iD;AACA,oC;AACA,0E;AACA,gB;AACA,qC;AACA,sB;AACA,Y;AACA,kB;AACA,K;AACA,I;;AAEA,0C;AACA,8C;AACA,sD;AACA,kB;AACA,6B;AACA,kE;AACA,+B;AACA,mD;AACA,I;;AAEA,kE;AACA,4D;AACA,kC;AACA,+B;AACA,e;AACA,qD;AACA,sC;AACA,mE;AACA,sC;AACA,gD;AACA,kC;AACA,oE;AACA,sB;AACA,0B;AACA,8B;AACA,mD;AACA,0C;AACA,c;AACA,iD;AACA,oC;AACA,O;AACA,Y;AACA,+D;AACA,K;AACA,I;;AAEA,W;;AAEA,8B;AACA,uB;AACA,I;;AAEA,kC;AACA,8B;AACA,I;;AAEA,uD;;AAEA,sC;AACA,+C;AACA,+C;AACA,2D;AACA,iD;AACA,qD;AACA,qD;AACA,uD;AACA,M;AACA,gC;;AAEA,4B;AACA,kB;;AAEA,gC;AACA,4C;AACA,iB;AACA,sC;AACA,0D;AACA,kC;AACA,sC;AACA,iB;AACA,gC;AACA,oC;AACA,qC;AACA,0B;AACA,2B;AACA,uB;AACA,+B;AACA,2B;AACA,uB;AACA,U;AACA,2C;AACA,0B;AACA,kB;AACA,2B;AACA,kB;AACA,kB;AACA,8B;AACA,6B;AACA,gB;AACA,wC;AACA,4B;AACA,c;AACA,6B;AACA,gB;AACA,wC;AACA,2B;AACA,O;AACA,6B;AACA,gC;AACA,0B;AACA,c;AACA,uB;AACA,8E;AACA,O;AACA,4B;;AAEA,mC;AACA,0B;AACA,K;AACA,G;;AAEA,a;AACA,E;;AAEA,iF;AACA,4B;AACA,E;AACA,wE;AACA,wB;AACA,uC;AACA,6B;AACA,0C;AACA,yB;AACA,gB;AACA,E;;AAEA,0E;AACA,0E;AACA,+B;AACA,E;AACA,e;AACA,E;AACA,oE;AACA,E;AACA,sE;AACA,8D;AACA,E;AACA,2E;AACA,wC;AACA,E;AACA,yE;AACA,qE;AACA,gC;AACA,kC;AACA,qD;;AAEA,mD;AACA,kD;AACA,e;AACA,kB;;AAEA,qC;AACA,gB;;AAEA,gC;AACA,gB;;AAEA,6B;AACA,yC;;AAEA,mC;AACA,qD;;AAEA,yD;AACA,iD;AACA,+B;;AAEA,oC;AACA,2B;;AAEA,oE;AACA,uE;AACA,oE;AACA,gB;AACA,0C;;AAEA,wB;AACA,qC;AACA,0D;AACA,wC;AACA,gE;AACA,mE;AACA,wC;AACA,O;AACA,2B;AACA,qD;AACA,yC;AACA,0B;AACA,Q;AACA,qE;;AAEA,4C;AACA,yE;;AAEA,yD;AACA,qE;;AAEA,kC;AACA,mD;AACA,2E;;AAEA,8C;AACA,+D;;AAEA,4B;AACA,2C;AACA,K;;AAEA,wC;AACA,8C;AACA,qC;AACA,8B;AACA,yE;AACA,kC;AACA,O;AACA,Y;AACA,4B;AACA,uE;AACA,kC;AACA,K;AACA,G;;AAEA,6B;AACA,yB;AACA,+B;AACA,yB;;AAEA,gB;AACA,E;;AAEA,+C;AACA,qC;AACA,I;AACA,yE;AACA,kE;AACA,yE;AACA,2C;AACA,iB;AACA,mC;AACA,yD;AACA,6C;AACA,oD;AACA,sD;AACA,E;;AAEA,oE;AACA,mE;AACA,W;AACA,4C;;AAEA,+D;AACA,yB;AACA,2E;AACA,qE;AACA,wB;AACA,yH;AACA,K;AACA,G;;AAEA,gE;AACA,wD;AACA,iC;AACA,a;AACA,2C;AACA,2B;AACA,0B;AACA,oD;AACA,wD;AACA,sD;AACA,wD;AACA,0H;AACA,O;AACA,Y;AACA,qF;AACA,K;AACA,+D;AACA,qC;AACA,8N;AACA,K;AACA,iC;AACA,4L;AACA,K;AACA,G;;AAEA,E;;;;;;;;;;;;;;;;;;;ACpdA,yE;AACA,yB;;AAEA,iC;AACA,uC;AACA,E;;AAEA,mB;AACA,U;AACA,W;AACA,S;AACA,E;;AAEA,0E;AACA,yE;AACA,qE;AACA,0E;AACA,8E;AACA,E;AACA,yE;AACA,2E;AACA,sE;AACA,4E;AACA,qB;AACA,+C;AACA,wB;AACA,wC;AACA,6C;AACA,2C;AACA,2C;AACA,uC;AACA,0C;AACA,4C;AACA,4B;AACA,sC;AACA,gD;AACA,iC;AACA,4B;AACA,I;AACA,4B;AACA,8B;AACA,iC;AACA,yE;AACA,qB;AACA,8B;AACA,iD;AACA,uD;AACA,sE;AACA,8B;AACA,qC;AACA,2E;AACA,8E;AACA,wE;AACA,0B;AACA,8B;AACA,K;;AAEA,gC;AACA,6C;AACA,uD;AACA,iC;;AAEA,6D;AACA,+B;;AAEA,4B;AACA,I;AACA,qC;AACA,gB;AACA,wC;AACA,8D;AACA,6C;AACA,4E;AACA,mC;AACA,wB;AACA,oD;AACA,qC;AACA,O;AACA,K;AACA,4B;AACA,G;AACA,G;;AAEA,4C;AACA,iD;AACA,E;;AAEA,0B;AACA,kC;AACA,E;;AAEA,wD;AACA,qB;AACA,8C;AACA,4C;AACA,+C;AACA,mB;;AAEA,oE;AACA,uB;AACA,G;AACA,G;;AAEA,kE;AACA,+D;AACA,iD;AACA,uB;AACA,mB;AACA,wB;AACA,sB;AACA,sB;AACA,gC;AACA,kD;AACA,8C;AACA,0B;AACA,sD;AACA,oE;AACA,Y;AACA,mB;AACA,K;AACA,I;AACA,4B;AACA,gD;AACA,8C;AACA,wB;AACA,sD;AACA,gE;AACA,Y;AACA,iB;AACA,K;AACA,I;AACA,sC;AACA,2D;AACA,qE;AACA,I;AACA,qC;AACA,iB;AACA,G;AACA,G;;AAEA,qD;AACA,oD;AACA,0B;AACA,gC;AACA,oB;AACA,4C;AACA,0B;AACA,uC;AACA,4B;AACA,4B;AACA,gE;AACA,+D;AACA,mE;AACA,2D;AACA,yB;AACA,+C;AACA,0D;AACA,S;AACA,c;AACA,0B;AACA,O;AACA,K;AACA,kB;AACA,G;AACA,G;;AAEA,wE;AACA,kC;AACA,mD;AACA,yB;AACA,4B;AACA,yB;AACA,yD;AACA,kB;AACA,Y;AACA,iB;AACA,K;AACA,G;AACA,G;;AAEA,8C;AACA,6C;AACA,gD;AACA,+C;AACA,c;AACA,E;;;;;;;;;;;;;;;;;;;ACzLA,+D;AACA,mC;;AAEA,qE;AACA,kE;AACA,yC;AACA,yD;;AAEA,oE;AACA,mB;AACA,2B;AACA,2B;AACA,sB;AACA,E;;;AAGA,gE;AACA,iE;AACA,sE;AACA,a;AACA,sB;AACA,mE;AACA,6D;AACA,iE;AACA,qB;AACA,8C;AACA,wC;;AAEA,iE;AACA,0D;AACA,kC;AACA,iC;AACA,E;;AAEA,8D;AACA,iD;AACA,oD;AACA,kD;AACA,E;;AAEA,wC;AACA,iB;AACA,oB;AACA,iE;AACA,sC;AACA,E;;AAEA,6B;AACA,sC;AACA,oB;AACA,wE;AACA,yD;AACA,qE;AACA,0D;AACA,kE;AACA,mB;AACA,Y;AACA,2D;AACA,4D;AACA,oC;AACA,mD;AACA,S;AACA,4E;AACA,mE;AACA,oD;AACA,qD;AACA,oE;AACA,S;AACA,yC;AACA,wE;AACA,4B;;AAEA,uC;AACA,0D;AACA,oC;AACA,Y;AACA,wD;AACA,8E;;AAEA,qF;AACA,uC;AACA,8B;AACA,gF;AACA,gC;AACA,qE;;AAEA,oD;AACA,2E;AACA,iC;AACA,kD;AACA,qE;AACA,wC;AACA,0D;AACA,6E;;AAEA,kD;AACA,+B;AACA,4C;;AAEA,qC;AACA,4E;;AAEA,gB;AACA,wE;AACA,gC;AACA,iC;AACA,0E;AACA,qB;AACA,W;;AAEA,iE;AACA,6C;AACA,gE;AACA,qD;AACA,wE;;AAEA,uC;AACA,wB;AACA,sC;AACA,4B;AACA,4C;AACA,W;;AAEA,2B;AACA,oE;;AAEA,yE;AACA,sE;AACA,mE;AACA,oE;AACA,0E;AACA,0E;AACA,oE;AACA,yB;AACA,yB;AACA,gF;AACA,mC;AACA,W;;AAEA,iC;AACA,wE;AACA,kF;AACA,qC;AACA,W;;AAEA,kD;AACA,S;AACA,c;AACA,kE;AACA,qE;AACA,qE;AACA,O;AACA,K;AACA,I;;AAEA,+C;AACA,I;AACA,6D;AACA,sD;AACA,I;AACA,gE;AACA,I;AACA,a;AACA,I;AACA,qE;AACA,mE;AACA,oE;AACA,iC;AACA,sC;AACA,oD;AACA,uE;AACA,gF;AACA,gE;AACA,+B;AACA,2B;AACA,qE;AACA,0B;AACA,kE;AACA,iD;AACA,qC;AACA,K;;AAEA,wD;AACA,gC;AACA,yD;AACA,sC;AACA,kE;;AAEA,0B;AACA,6C;AACA,sE;AACA,K;;AAEA,gB;AACA,I;;AAEA,+D;AACA,mE;AACA,I;AACA,iE;AACA,4D;AACA,mC;AACA,oB;;AAEA,yB;AACA,0B;;AAEA,gB;AACA,sB;AACA,kB;AACA,kB;AACA,mB;AACA,gB;AACA,iD;AACA,Y;AACA,gB;AACA,2C;AACA,Y;AACA,Y;AACA,uB;AACA,yD;AACA,K;;AAEA,mB;AACA,I;;AAEA,wE;AACA,uE;AACA,qC;AACA,wD;AACA,oB;;AAEA,0C;AACA,iD;AACA,gD;;AAEA,qD;AACA,uD;AACA,I;;AAEA,oD;AACA,iB;AACA,2C;AACA,oB;;AAEA,0C;AACA,gC;;AAEA,0B;AACA,oC;AACA,8C;;AAEA,2B;AACA,gE;AACA,gC;AACA,iC;AACA,c;AACA,8B;AACA,4B;AACA,2B;AACA,O;AACA,O;;AAEA,sD;AACA,iB;AACA,0B;AACA,mE;AACA,K;;AAEA,gB;AACA,I;;AAEA,oC;AACA,8C;AACA,I;;AAEA,6C;AACA,oB;;AAEA,4B;;AAEA,wB;AACA,wB;AACA,kB;AACA,sC;AACA,2D;AACA,yB;AACA,mC;AACA,4B;AACA,gF;AACA,S;AACA,kD;AACA,uC;AACA,wD;AACA,Q;AACA,uE;AACA,2C;AACA,mD;AACA,mC;AACA,qC;AACA,4E;AACA,Y;AACA,8D;AACA,wB;AACA,oE;AACA,0D;AACA,K;;AAEA,0D;AACA,G;;AAEA,G;;;;;;;;;;;;;;;;;;;;ACtTA,4C;;AAEA,qC;AACA,U;AACA,sD;;AAEA,c;AACA,E;;AAEA,uD;AACA,4C;AACA,kD;AACA,E;;AAEA,2E;AACA,4C;AACA,6B;AACA,6C;;AAEA,gE;AACA,0D;AACA,4D;AACA,kE;AACA,6D;AACA,yB;AACA,gC;AACA,kE;;AAEA,gD;AACA,K;;AAEA,wE;AACA,I;AACA,qC;AACA,+C;AACA,oD;;AAEA,2D;AACA,gF;AACA,I;AACA,+C;AACA,iC;AACA,mC;AACA,kC;;AAEA,2B;AACA,sE;AACA,sE;AACA,wD;AACA,uE;AACA,4E;AACA,iD;AACA,oE;AACA,K;AACA,kB;AACA,G;AACA,G;;AAEA,2D;AACA,sD;AACA,wB;AACA,mD;AACA,2C;;AAEA,uB;;AAEA,4D;AACA,6B;AACA,4E;AACA,0B;AACA,4C;AACA,G;;AAEA,8C;AACA,qD;AACA,qC;;AAEA,+B;AACA,6B;AACA,gC;AACA,G;AACA,oB;AACA,gC;AACA,iB;;AAEA,2C;;AAEA,c;AACA,E;;AAEA,+C;AACA,8D;AACA,qC;AACA,mD;AACA,gD;AACA,kD;AACA,2D;AACA,4D;AACA,2D;AACA,6B;AACA,+E;AACA,gC;AACA,sC;AACA,kB;AACA,U;AACA,2C;AACA,gB;AACA,G;AACA,E","sourcesContent":["SpacebarsCompiler = {};\r\n\r\n// A TemplateTag is the result of parsing a single `{{...}}` tag.\r\n//\r\n// The `.type` of a TemplateTag is one of:\r\n//\r\n// - `\"DOUBLE\"` - `{{foo}}`\r\n// - `\"TRIPLE\"` - `{{{foo}}}`\r\n// - `\"COMMENT\"` - `{{! foo}}`\r\n// - `\"INCLUSION\"` - `{{> foo}}`\r\n// - `\"BLOCKOPEN\"` - `{{#foo}}`\r\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`\r\n// - `\"ELSE\"` - `{{else}}`\r\n//\r\n// Besides `type`, the mandatory properties of a TemplateTag are:\r\n//\r\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\r\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\r\n//   and BLOCKCLOSE.\r\n//\r\n// - `args` - An array of zero or more argument specs.  An argument spec\r\n//   is a two or three element array, consisting of a type, value, and\r\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\r\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\r\n//   TRIPLE, INCLUSION, and BLOCKOPEN.\r\n//\r\n// - `value` - For COMMENT tags, a string of the comment's text.\r\n//\r\n// These additional are typically set during parsing:\r\n//\r\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\r\n//   of site the TemplateTag was encountered (e.g. at element level or as\r\n//   part of an attribute value). Its absence implies\r\n//   TEMPLATE_TAG_POSITION.ELEMENT.\r\n//\r\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\r\n//   parsed, they are put here.  `elseContent` will only be present if\r\n//   an `{{else}}` was found.\r\n\r\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\r\n\r\nTemplateTag = SpacebarsCompiler.TemplateTag = function () {\r\n  HTMLTools.TemplateTag.apply(this, arguments);\r\n};\r\nTemplateTag.prototype = new HTMLTools.TemplateTag;\r\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';\r\n\r\nvar makeStacheTagStartRegex = function (r) {\r\n  return new RegExp(r.source + /(?![{>!#/])/.source,\r\n                    r.ignoreCase ? 'i' : '');\r\n};\r\n\r\nvar starts = {\r\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(?=[\\s}])/i),\r\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\r\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\r\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\r\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\r\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\r\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\r\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\r\n};\r\n\r\nvar ends = {\r\n  DOUBLE: /^\\s*\\}\\}/,\r\n  TRIPLE: /^\\s*\\}\\}\\}/\r\n};\r\n\r\n// Parse a tag from the provided scanner or string.  If the input\r\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds\r\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using\r\n// `scanner.fatal` if a scanner is provided).\r\nTemplateTag.parse = function (scannerOrString) {\r\n  var scanner = scannerOrString;\r\n  if (typeof scanner === 'string')\r\n    scanner = new HTMLTools.Scanner(scannerOrString);\r\n\r\n  if (! (scanner.peek() === '{' &&\r\n         (scanner.rest()).slice(0, 2) === '{{'))\r\n    return null;\r\n\r\n  var run = function (regex) {\r\n    // regex is assumed to start with `^`\r\n    var result = regex.exec(scanner.rest());\r\n    if (! result)\r\n      return null;\r\n    var ret = result[0];\r\n    scanner.pos += ret.length;\r\n    return ret;\r\n  };\r\n\r\n  var advance = function (amount) {\r\n    scanner.pos += amount;\r\n  };\r\n\r\n  var scanIdentifier = function (isFirstInPath) {\r\n    var id = BlazeTools.parseIdentifierName(scanner);\r\n    if (! id)\r\n      expected('IDENTIFIER');\r\n    if (isFirstInPath &&\r\n        (id === 'null' || id === 'true' || id === 'false'))\r\n      scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\r\n\r\n    return id;\r\n  };\r\n\r\n  var scanPath = function () {\r\n    var segments = [];\r\n\r\n    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\r\n    var dots;\r\n    if ((dots = run(/^[\\.\\/]+/))) {\r\n      var ancestorStr = '.'; // eg `../../..` maps to `....`\r\n      var endsWithSlash = /\\/$/.test(dots);\r\n\r\n      if (endsWithSlash)\r\n        dots = dots.slice(0, -1);\r\n\r\n      _.each(dots.split('/'), function(dotClause, index) {\r\n        if (index === 0) {\r\n          if (dotClause !== '.' && dotClause !== '..')\r\n            expected(\"`.`, `..`, `./` or `../`\");\r\n        } else {\r\n          if (dotClause !== '..')\r\n            expected(\"`..` or `../`\");\r\n        }\r\n\r\n        if (dotClause === '..')\r\n          ancestorStr += '.';\r\n      });\r\n\r\n      segments.push(ancestorStr);\r\n\r\n      if (!endsWithSlash)\r\n        return segments;\r\n    }\r\n\r\n    while (true) {\r\n      // scan a path segment\r\n\r\n      if (run(/^\\[/)) {\r\n        var seg = run(/^[\\s\\S]*?\\]/);\r\n        if (! seg)\r\n          error(\"Unterminated path segment\");\r\n        seg = seg.slice(0, -1);\r\n        if (! seg && ! segments.length)\r\n          error(\"Path can't start with empty string\");\r\n        segments.push(seg);\r\n      } else {\r\n        var id = scanIdentifier(! segments.length);\r\n        if (id === 'this') {\r\n          if (! segments.length) {\r\n            // initial `this`\r\n            segments.push('.');\r\n          } else {\r\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\r\n          }\r\n        } else {\r\n          segments.push(id);\r\n        }\r\n      }\r\n\r\n      var sep = run(/^[\\.\\/]/);\r\n      if (! sep)\r\n        break;\r\n    }\r\n\r\n    return segments;\r\n  };\r\n\r\n  // scan the keyword portion of a keyword argument\r\n  // (the \"foo\" portion in \"foo=bar\").\r\n  // Result is either the keyword matched, or null\r\n  // if we're not at a keyword argument position.\r\n  var scanArgKeyword = function () {\r\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());\r\n    if (match) {\r\n      scanner.pos += match[0].length;\r\n      return match[1];\r\n    } else {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  // scan an argument; succeeds or errors.\r\n  // Result is an array of two or three items:\r\n  // type , value, and (indicating a keyword argument)\r\n  // keyword name.\r\n  var scanArg = function () {\r\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg\r\n    var value = scanArgValue();\r\n    return keyword ? value.concat(keyword) : value;\r\n  };\r\n\r\n  // scan an argument value (for keyword or positional arguments);\r\n  // succeeds or errors.  Result is an array of type, value.\r\n  var scanArgValue = function () {\r\n    var startPos = scanner.pos;\r\n    var result;\r\n    if ((result = BlazeTools.parseNumber(scanner))) {\r\n      return ['NUMBER', result.value];\r\n    } else if ((result = BlazeTools.parseStringLiteral(scanner))) {\r\n      return ['STRING', result.value];\r\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {\r\n      return ['PATH', scanPath()];\r\n    } else if ((result = BlazeTools.parseIdentifierName(scanner))) {\r\n      var id = result;\r\n      if (id === 'null') {\r\n        return ['NULL', null];\r\n      } else if (id === 'true' || id === 'false') {\r\n        return ['BOOLEAN', id === 'true'];\r\n      } else {\r\n        scanner.pos = startPos; // unconsume `id`\r\n        return ['PATH', scanPath()];\r\n      }\r\n    } else {\r\n      expected('identifier, number, string, boolean, or null');\r\n    }\r\n  };\r\n\r\n  var type;\r\n\r\n  var error = function (msg) {\r\n    scanner.fatal(msg);\r\n  };\r\n\r\n  var expected = function (what) {\r\n    error('Expected ' + what);\r\n  };\r\n\r\n  // must do ELSE first; order of others doesn't matter\r\n\r\n  if (run(starts.ELSE)) type = 'ELSE';\r\n  else if (run(starts.DOUBLE)) type = 'DOUBLE';\r\n  else if (run(starts.TRIPLE)) type = 'TRIPLE';\r\n  else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';\r\n  else if (run(starts.COMMENT)) type = 'COMMENT';\r\n  else if (run(starts.INCLUSION)) type = 'INCLUSION';\r\n  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';\r\n  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';\r\n  else\r\n    error('Unknown stache tag');\r\n\r\n  var tag = new TemplateTag;\r\n  tag.type = type;\r\n\r\n  if (type === 'BLOCKCOMMENT') {\r\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\r\n    if (! result)\r\n      error(\"Unclosed block comment\");\r\n    tag.value = result.slice(0, result.lastIndexOf('--'));\r\n  } else if (type === 'COMMENT') {\r\n    var result = run(/^[\\s\\S]*?\\}\\}/);\r\n    if (! result)\r\n      error(\"Unclosed comment\");\r\n    tag.value = result.slice(0, -2);\r\n  } else if (type === 'BLOCKCLOSE') {\r\n    tag.path = scanPath();\r\n    if (! run(ends.DOUBLE))\r\n      expected('`}}`');\r\n  } else if (type === 'ELSE') {\r\n    if (! run(ends.DOUBLE))\r\n      expected('`}}`');\r\n  } else {\r\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\r\n    tag.path = scanPath();\r\n    tag.args = [];\r\n    var foundKwArg = false;\r\n    while (true) {\r\n      run(/^\\s*/);\r\n      if (type === 'TRIPLE') {\r\n        if (run(ends.TRIPLE))\r\n          break;\r\n        else if (scanner.peek() === '}')\r\n          expected('`}}}`');\r\n      } else {\r\n        if (run(ends.DOUBLE))\r\n          break;\r\n        else if (scanner.peek() === '}')\r\n          expected('`}}`');\r\n      }\r\n      var newArg = scanArg();\r\n      if (newArg.length === 3) {\r\n        foundKwArg = true;\r\n      } else {\r\n        if (foundKwArg)\r\n          error(\"Can't have a non-keyword argument after a keyword argument\");\r\n      }\r\n      tag.args.push(newArg);\r\n\r\n      if (run(/^(?=[\\s}])/) !== '')\r\n        expected('space');\r\n    }\r\n  }\r\n\r\n  return tag;\r\n};\r\n\r\n// Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner\r\n// at its original position.\r\n//\r\n// An error will still be thrown if there is not a valid template tag at\r\n// the current position.\r\nTemplateTag.peek = function (scanner) {\r\n  var startPos = scanner.pos;\r\n  var result = TemplateTag.parse(scanner);\r\n  scanner.pos = startPos;\r\n  return result;\r\n};\r\n\r\n// Like `TemplateTag.parse`, but in the case of blocks, parse the complete\r\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\r\n// than just the BLOCKOPEN tag.\r\n//\r\n// In addition:\r\n//\r\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\r\n//\r\n// - Returns `null` for a COMMENT.  (This case is distinguishable from\r\n//   parsing no tag by the fact that the scanner is advanced.)\r\n//\r\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\r\n//   TemplateTag's `.position` property.\r\n//\r\n// - Validates the tag's well-formedness and legality at in its position.\r\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {\r\n  var scanner = scannerOrString;\r\n  if (typeof scanner === 'string')\r\n    scanner = new HTMLTools.Scanner(scannerOrString);\r\n\r\n  var startPos = scanner.pos; // for error messages\r\n  var result = TemplateTag.parse(scannerOrString);\r\n  if (! result)\r\n    return result;\r\n\r\n  if (result.type === 'BLOCKCOMMENT')\r\n    return null;\r\n\r\n  if (result.type === 'COMMENT')\r\n    return null;\r\n\r\n  if (result.type === 'ELSE')\r\n    scanner.fatal(\"Unexpected {{else}}\");\r\n\r\n  if (result.type === 'BLOCKCLOSE')\r\n    scanner.fatal(\"Unexpected closing template tag\");\r\n\r\n  position = (position || TEMPLATE_TAG_POSITION.ELEMENT);\r\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT)\r\n    result.position = position;\r\n\r\n  if (result.type === 'BLOCKOPEN') {\r\n    // parse block contents\r\n\r\n    // Construct a string version of `.path` for comparing start and\r\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\r\n    // and now becomes `foo,0`.  This form may also show up in error\r\n    // messages.\r\n    var blockName = result.path.join(',');\r\n\r\n    var textMode = null;\r\n      if (blockName === 'markdown' ||\r\n          position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\r\n        textMode = HTML.TEXTMODE.STRING;\r\n      } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA ||\r\n                 position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\r\n        textMode = HTML.TEXTMODE.RCDATA;\r\n      }\r\n      var parserOptions = {\r\n        getTemplateTag: TemplateTag.parseCompleteTag,\r\n        shouldStop: isAtBlockCloseOrElse,\r\n        textMode: textMode\r\n      };\r\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);\r\n\r\n    if (scanner.rest().slice(0, 2) !== '{{')\r\n      scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\r\n\r\n    var lastPos = scanner.pos; // save for error messages\r\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\r\n\r\n    if (tmplTag.type === 'ELSE') {\r\n      // parse {{else}} and content up to close tag\r\n      result.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\r\n\r\n      if (scanner.rest().slice(0, 2) !== '{{')\r\n        scanner.fatal(\"Expected block close for \" + blockName);\r\n\r\n      lastPos = scanner.pos;\r\n      tmplTag = TemplateTag.parse(scanner);\r\n    }\r\n\r\n    if (tmplTag.type === 'BLOCKCLOSE') {\r\n      var blockName2 = tmplTag.path.join(',');\r\n      if (blockName !== blockName2) {\r\n        scanner.pos = lastPos;\r\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' +\r\n                      blockName2);\r\n      }\r\n    } else {\r\n      scanner.pos = lastPos;\r\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' +\r\n                    tmplTag.type);\r\n    }\r\n  }\r\n\r\n  var finalPos = scanner.pos;\r\n  scanner.pos = startPos;\r\n  validateTag(result, scanner);\r\n  scanner.pos = finalPos;\r\n\r\n  return result;\r\n};\r\n\r\nvar isAtBlockCloseOrElse = function (scanner) {\r\n  // Detect `{{else}}` or `{{/foo}}`.\r\n  //\r\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,\r\n  // for efficiency (we're called for every input token) and to be\r\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it\r\n  // sees `{{` followed by a malformed tag.\r\n  var rest, type;\r\n  return (scanner.peek() === '{' &&\r\n          (rest = scanner.rest()).slice(0, 2) === '{{' &&\r\n          /^\\{\\{\\s*(\\/|else\\b)/.test(rest) &&\r\n          (type = TemplateTag.peek(scanner).type) &&\r\n          (type === 'BLOCKCLOSE' || type === 'ELSE'));\r\n};\r\n\r\n// Validate that `templateTag` is correctly formed and legal for its\r\n// HTML position.  Use `scanner` to report errors. On success, does\r\n// nothing.\r\nvar validateTag = function (ttag, scanner) {\r\n\r\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\r\n    var args = ttag.args;\r\n    if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\r\n      // we have a positional argument that is not a PATH followed by\r\n      // other arguments\r\n      scanner.fatal(\"First argument must be a function, to be called on the rest of the arguments; found \" + args[0][0]);\r\n    }\r\n  }\r\n\r\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\r\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\r\n    if (ttag.type === 'DOUBLE') {\r\n      return;\r\n    } else if (ttag.type === 'BLOCKOPEN') {\r\n      var path = ttag.path;\r\n      var path0 = path[0];\r\n      if (! (path.length === 1 && (path0 === 'if' ||\r\n                                   path0 === 'unless' ||\r\n                                   path0 === 'with' ||\r\n                                   path0 === 'each'))) {\r\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\r\n      }\r\n    } else {\r\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\r\n    }\r\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\r\n    if (! (ttag.type === 'DOUBLE')) {\r\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\r\n    }\r\n    if (scanner.peek() === '=') {\r\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\r\n    }\r\n  }\r\n\r\n};\r\n","// Optimize parts of an HTMLjs tree into raw HTML strings when they don't\r\n// contain template tags.\r\n\r\nvar constant = function (value) {\r\n  return function () { return value; };\r\n};\r\n\r\nvar OPTIMIZABLE = {\r\n  NONE: 0,\r\n  PARTS: 1,\r\n  FULL: 2\r\n};\r\n\r\n// We can only turn content into an HTML string if it contains no template\r\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content\r\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an\r\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree\r\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.\r\n//\r\n// For example, we always create SVG elements programmatically, since SVG\r\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.\r\n// However, if we are given a big tree that contains SVG somewhere, we\r\n// return PARTS so that the optimizer can descend into the tree and optimize\r\n// other parts of it.\r\nvar CanOptimizeVisitor = HTML.Visitor.extend();\r\nCanOptimizeVisitor.def({\r\n  visitNull: constant(OPTIMIZABLE.FULL),\r\n  visitPrimitive: constant(OPTIMIZABLE.FULL),\r\n  visitComment: constant(OPTIMIZABLE.FULL),\r\n  visitCharRef: constant(OPTIMIZABLE.FULL),\r\n  visitRaw: constant(OPTIMIZABLE.FULL),\r\n  visitObject: constant(OPTIMIZABLE.NONE),\r\n  visitFunction: constant(OPTIMIZABLE.NONE),\r\n  visitArray: function (x) {\r\n    for (var i = 0; i < x.length; i++)\r\n      if (this.visit(x[i]) !== OPTIMIZABLE.FULL)\r\n        return OPTIMIZABLE.PARTS;\r\n    return OPTIMIZABLE.FULL;\r\n  },\r\n  visitTag: function (tag) {\r\n    var tagName = tag.tagName;\r\n    if (tagName === 'textarea') {\r\n      // optimizing into a TEXTAREA's RCDATA would require being a little\r\n      // more clever.\r\n      return OPTIMIZABLE.NONE;\r\n    } else if (! (HTML.isKnownElement(tagName) &&\r\n                  ! HTML.isKnownSVGElement(tagName))) {\r\n      // foreign elements like SVG can't be stringified for innerHTML.\r\n      return OPTIMIZABLE.NONE;\r\n    } else if (tagName === 'table') {\r\n      // Avoid ever producing HTML containing `<table><tr>...`, because the\r\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and\r\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\r\n      // (assuming IE 8+).\r\n      return OPTIMIZABLE.NONE;\r\n    }\r\n\r\n    var children = tag.children;\r\n    for (var i = 0; i < children.length; i++)\r\n      if (this.visit(children[i]) !== OPTIMIZABLE.FULL)\r\n        return OPTIMIZABLE.PARTS;\r\n\r\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL)\r\n      return OPTIMIZABLE.PARTS;\r\n\r\n    return OPTIMIZABLE.FULL;\r\n  },\r\n  visitAttributes: function (attrs) {\r\n    if (attrs) {\r\n      var isArray = HTML.isArray(attrs);\r\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {\r\n        var a = (isArray ? attrs[i] : attrs);\r\n        if ((typeof a !== 'object') || (a instanceof HTMLTools.TemplateTag))\r\n          return OPTIMIZABLE.PARTS;\r\n        for (var k in a)\r\n          if (this.visit(a[k]) !== OPTIMIZABLE.FULL)\r\n            return OPTIMIZABLE.PARTS;\r\n      }\r\n    }\r\n    return OPTIMIZABLE.FULL;\r\n  }\r\n});\r\n\r\nvar getOptimizability = function (content) {\r\n  return (new CanOptimizeVisitor).visit(content);\r\n};\r\n\r\nvar toRaw = function (x) {\r\n  return HTML.Raw(HTML.toHTML(x));\r\n};\r\n\r\nvar TreeTransformer = HTML.TransformingVisitor.extend();\r\nTreeTransformer.def({\r\n  visitAttributes: function (attrs/*, ...*/) {\r\n    // pass template tags through by default\r\n    if (attrs instanceof HTMLTools.TemplateTag)\r\n      return attrs;\r\n\r\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(\r\n      this, arguments);\r\n  }\r\n});\r\n\r\n// Replace parts of the HTMLjs tree that have no template tags (or\r\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.\r\nvar OptimizingVisitor = TreeTransformer.extend();\r\nOptimizingVisitor.def({\r\n  visitNull: toRaw,\r\n  visitPrimitive: toRaw,\r\n  visitComment: toRaw,\r\n  visitCharRef: toRaw,\r\n  visitArray: function (array) {\r\n    var optimizability = getOptimizability(array);\r\n    if (optimizability === OPTIMIZABLE.FULL) {\r\n      return toRaw(array);\r\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\r\n      return TreeTransformer.prototype.visitArray.call(this, array);\r\n    } else {\r\n      return array;\r\n    }\r\n  },\r\n  visitTag: function (tag) {\r\n    var optimizability = getOptimizability(tag);\r\n    if (optimizability === OPTIMIZABLE.FULL) {\r\n      return toRaw(tag);\r\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\r\n      return TreeTransformer.prototype.visitTag.call(this, tag);\r\n    } else {\r\n      return tag;\r\n    }\r\n  },\r\n  visitChildren: function (children) {\r\n    // don't optimize the children array into a Raw object!\r\n    return TreeTransformer.prototype.visitArray.call(this, children);\r\n  },\r\n  visitAttributes: function (attrs) {\r\n    return attrs;\r\n  }\r\n});\r\n\r\n// Combine consecutive HTML.Raws.  Remove empty ones.\r\nvar RawCompactingVisitor = TreeTransformer.extend();\r\nRawCompactingVisitor.def({\r\n  visitArray: function (array) {\r\n    var result = [];\r\n    for (var i = 0; i < array.length; i++) {\r\n      var item = array[i];\r\n      if ((item instanceof HTML.Raw) &&\r\n          ((! item.value) ||\r\n           (result.length &&\r\n            (result[result.length - 1] instanceof HTML.Raw)))) {\r\n        // two cases: item is an empty Raw, or previous item is\r\n        // a Raw as well.  In the latter case, replace the previous\r\n        // Raw with a longer one that includes the new Raw.\r\n        if (item.value) {\r\n          result[result.length - 1] = HTML.Raw(\r\n            result[result.length - 1].value + item.value);\r\n        }\r\n      } else {\r\n        result.push(item);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n});\r\n\r\n// Replace pointless Raws like `HTMl.Raw('foo')` that contain no special\r\n// characters with simple strings.\r\nvar RawReplacingVisitor = TreeTransformer.extend();\r\nRawReplacingVisitor.def({\r\n  visitRaw: function (raw) {\r\n    var html = raw.value;\r\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {\r\n      return html;\r\n    } else {\r\n      return raw;\r\n    }\r\n  }\r\n});\r\n\r\nSpacebarsCompiler.optimize = function (tree) {\r\n  tree = (new OptimizingVisitor).visit(tree);\r\n  tree = (new RawCompactingVisitor).visit(tree);\r\n  tree = (new RawReplacingVisitor).visit(tree);\r\n  return tree;\r\n};\r\n","// ============================================================\r\n// Code-generation of template tags\r\n\r\n// The `CodeGen` class currently has no instance state, but in theory\r\n// it could be useful to track per-function state, like whether we\r\n// need to emit `var self = this` or not.\r\nvar CodeGen = SpacebarsCompiler.CodeGen = function () {};\r\n\r\nvar builtInBlockHelpers = SpacebarsCompiler._builtInBlockHelpers = {\r\n  'if': 'Blaze.If',\r\n  'unless': 'Blaze.Unless',\r\n  'with': 'Spacebars.With',\r\n  'each': 'Blaze.Each'\r\n};\r\n\r\n\r\n// Some `UI.*` paths are special in that they generate code that\r\n // doesn't folow the normal lookup rules for dotted symbols. The\r\n // following names must be prefixed with `UI.` when you use them in a\r\n // template.\r\nvar builtInUIPaths = {\r\n  // `template` is a local variable defined in the generated render\r\n  // function for the template in which `UI.contentBlock` (or\r\n  // `UI.elseBlock`) is invoked. `template` is a reference to the\r\n  // template itself.\r\n  'contentBlock': 'view.templateContentBlock',\r\n  'elseBlock': 'view.templateElseBlock',\r\n\r\n  // `Template` is the global template namespace. If you define a\r\n  // template named `foo` in Spacebars, it gets defined as\r\n  // `Template.foo` in JavaScript.\r\n  'dynamic': 'Template.__dynamic'\r\n};\r\n\r\n// A \"reserved name\" can't be used as a <template> name.  This\r\n// function is used by the template file scanner.\r\nSpacebarsCompiler.isReservedName = function (name) {\r\n  return builtInBlockHelpers.hasOwnProperty(name);\r\n};\r\n\r\nvar makeObjectLiteral = function (obj) {\r\n  var parts = [];\r\n  for (var k in obj)\r\n    parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);\r\n  return '{' + parts.join(', ') + '}';\r\n};\r\n\r\n_.extend(CodeGen.prototype, {\r\n  codeGenTemplateTag: function (tag) {\r\n    var self = this;\r\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\r\n      // Special dynamic attributes: `<div {{attrs}}>...`\r\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\r\n      return BlazeTools.EmitCode('function () { return ' +\r\n          self.codeGenMustache(tag.path, tag.args, 'attrMustache')\r\n          + '; }');\r\n    } else {\r\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {\r\n        var code = self.codeGenMustache(tag.path, tag.args);\r\n        if (tag.type === 'TRIPLE') {\r\n          code = 'Spacebars.makeRaw(' + code + ')';\r\n        }\r\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\r\n          // Reactive attributes are already wrapped in a function,\r\n          // and there's no fine-grained reactivity.\r\n          // Anywhere else, we need to create a View.\r\n          code = 'Blaze.View(function () { return ' + code + '; })';\r\n        }\r\n        return BlazeTools.EmitCode(code);\r\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\r\n        var path = tag.path;\r\n\r\n        if (tag.type === 'BLOCKOPEN' &&\r\n            builtInBlockHelpers.hasOwnProperty(path[0])) {\r\n          // if, unless, with, each.\r\n          //\r\n          // If someone tries to do `{{> if}}`, we don't\r\n          // get here, but an error is thrown when we try to codegen the path.\r\n\r\n          // Note: If we caught these errors earlier, while scanning, we'd be able to\r\n          // provide nice line numbers.\r\n          if (path.length > 1)\r\n            throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\r\n          if (! tag.args.length)\r\n            throw new Error(\"#\" + path[0] + \" requires an argument\");\r\n\r\n          // `args` must exist (tag.args.length > 0)\r\n          var dataCode = self.codeGenInclusionDataFunc(tag.args) || 'null';\r\n          // `content` must exist\r\n          var contentBlock = (('content' in tag) ?\r\n                              self.codeGenBlock(tag.content) : null);\r\n          // `elseContent` may not exist\r\n          var elseContentBlock = (('elseContent' in tag) ?\r\n                                  self.codeGenBlock(tag.elseContent) : null);\r\n\r\n          var callArgs = [dataCode, contentBlock];\r\n          if (elseContentBlock)\r\n            callArgs.push(elseContentBlock);\r\n\r\n          return BlazeTools.EmitCode(\r\n            builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\r\n\r\n        } else {\r\n          var compCode = self.codeGenPath(path, {lookupTemplate: true});\r\n          if (path.length > 1) {\r\n            // capture reactivity\r\n            compCode = 'function () { return Spacebars.call(' + compCode +\r\n              '); }';\r\n          }\r\n\r\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);\r\n          var content = (('content' in tag) ?\r\n                         self.codeGenBlock(tag.content) : null);\r\n          var elseContent = (('elseContent' in tag) ?\r\n                             self.codeGenBlock(tag.elseContent) : null);\r\n\r\n          var includeArgs = [compCode];\r\n          if (content) {\r\n            includeArgs.push(content);\r\n            if (elseContent)\r\n              includeArgs.push(elseContent);\r\n          }\r\n\r\n          var includeCode =\r\n                'Spacebars.include(' + includeArgs.join(', ') + ')';\r\n\r\n          // calling convention compat -- set the data context around the\r\n          // entire inclusion, so that if the name of the inclusion is\r\n          // a helper function, it gets the data context in `this`.\r\n          // This makes for a pretty confusing calling convention --\r\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`\r\n          // -- but it's what we shipped for 0.8.0.  The rationale is that\r\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.\r\n          if (dataCode) {\r\n            includeCode =\r\n              'Spacebars.TemplateWith(' + dataCode + ', function () { return ' +\r\n              includeCode + '; })';\r\n          }\r\n\r\n          if (path[0] === 'UI' &&\r\n              (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\r\n            includeCode = 'Blaze.InOuterTemplateScope(view, function () { return '\r\n              + includeCode + '; })';\r\n          }\r\n\r\n          return BlazeTools.EmitCode(includeCode);\r\n        }\r\n      } else {\r\n        // Can't get here; TemplateTag validation should catch any\r\n        // inappropriate tag types that might come out of the parser.\r\n        throw new Error(\"Unexpected template tag type: \" + tag.type);\r\n      }\r\n    }\r\n  },\r\n\r\n  // `path` is an array of at least one string.\r\n  //\r\n  // If `path.length > 1`, the generated code may be reactive\r\n  // (i.e. it may invalidate the current computation).\r\n  //\r\n  // No code is generated to call the result if it's a function.\r\n  //\r\n  // Options:\r\n  //\r\n  // - lookupTemplate {Boolean} If true, generated code also looks in\r\n  //   the list of templates. (After helpers, before data context).\r\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\r\n  //   used for non-dotted paths.\r\n  codeGenPath: function (path, opts) {\r\n    if (builtInBlockHelpers.hasOwnProperty(path[0]))\r\n      throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");\r\n    // Let `{{#if UI.contentBlock}}` check whether this template was invoked via\r\n    // inclusion or as a block helper, in addition to supporting\r\n    // `{{> UI.contentBlock}}`.\r\n    if (path.length >= 2 &&\r\n        path[0] === 'UI' && builtInUIPaths.hasOwnProperty(path[1])) {\r\n      if (path.length > 2)\r\n        throw new Error(\"Unexpected dotted path beginning with \" +\r\n                        path[0] + '.' + path[1]);\r\n      return builtInUIPaths[path[1]];\r\n    }\r\n\r\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);\r\n    var lookupMethod = 'lookup';\r\n    if (opts && opts.lookupTemplate && path.length === 1)\r\n      lookupMethod = 'lookupTemplate';\r\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';\r\n\r\n    if (path.length > 1) {\r\n      code = 'Spacebars.dot(' + code + ', ' +\r\n        _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';\r\n    }\r\n\r\n    return code;\r\n  },\r\n\r\n  // Generates code for an `[argType, argValue]` argument spec,\r\n  // ignoring the third element (keyword argument name) if present.\r\n  //\r\n  // The resulting code may be reactive (in the case of a PATH of\r\n  // more than one element) and is not wrapped in a closure.\r\n  codeGenArgValue: function (arg) {\r\n    var self = this;\r\n\r\n    var argType = arg[0];\r\n    var argValue = arg[1];\r\n\r\n    var argCode;\r\n    switch (argType) {\r\n    case 'STRING':\r\n    case 'NUMBER':\r\n    case 'BOOLEAN':\r\n    case 'NULL':\r\n      argCode = BlazeTools.toJSLiteral(argValue);\r\n      break;\r\n    case 'PATH':\r\n      argCode = self.codeGenPath(argValue);\r\n      break;\r\n    default:\r\n      // can't get here\r\n      throw new Error(\"Unexpected arg type: \" + argType);\r\n    }\r\n\r\n    return argCode;\r\n  },\r\n\r\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.\r\n  // The resulting code has no function literals and must be wrapped in\r\n  // one for fine-grained reactivity.\r\n  codeGenMustache: function (path, args, mustacheType) {\r\n    var self = this;\r\n\r\n    var nameCode = self.codeGenPath(path);\r\n    var argCode = self.codeGenMustacheArgs(args);\r\n    var mustache = (mustacheType || 'mustache');\r\n\r\n    return 'Spacebars.' + mustache + '(' + nameCode +\r\n      (argCode ? ', ' + argCode.join(', ') : '') + ')';\r\n  },\r\n\r\n  // returns: array of source strings, or null if no\r\n  // args at all.\r\n  codeGenMustacheArgs: function (tagArgs) {\r\n    var self = this;\r\n\r\n    var kwArgs = null; // source -> source\r\n    var args = null; // [source]\r\n\r\n    // tagArgs may be null\r\n    _.each(tagArgs, function (arg) {\r\n      var argCode = self.codeGenArgValue(arg);\r\n\r\n      if (arg.length > 2) {\r\n        // keyword argument (represented as [type, value, name])\r\n        kwArgs = (kwArgs || {});\r\n        kwArgs[arg[2]] = argCode;\r\n      } else {\r\n        // positional argument\r\n        args = (args || []);\r\n        args.push(argCode);\r\n      }\r\n    });\r\n\r\n    // put kwArgs in options dictionary at end of args\r\n    if (kwArgs) {\r\n      args = (args || []);\r\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\r\n    }\r\n\r\n    return args;\r\n  },\r\n\r\n  codeGenBlock: function (content) {\r\n    return SpacebarsCompiler.codeGen(content);\r\n  },\r\n\r\n  codeGenInclusionDataFunc: function (args) {\r\n    var self = this;\r\n\r\n    var dataFuncCode = null;\r\n\r\n    if (! args.length) {\r\n      // e.g. `{{#foo}}`\r\n      return null;\r\n    } else if (args[0].length === 3) {\r\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`\r\n      var dataProps = {};\r\n      _.each(args, function (arg) {\r\n        var argKey = arg[2];\r\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';\r\n      });\r\n      dataFuncCode = makeObjectLiteral(dataProps);\r\n    } else if (args[0][0] !== 'PATH') {\r\n      // literal first argument, e.g. `{{> foo \"blah\"}}`\r\n      //\r\n      // tag validation has confirmed, in this case, that there is only\r\n      // one argument (`args.length === 1`)\r\n      dataFuncCode = self.codeGenArgValue(args[0]);\r\n    } else if (args.length === 1) {\r\n      // one argument, must be a PATH\r\n      dataFuncCode = 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';\r\n    } else {\r\n      // Multiple positional arguments; treat them as a nested\r\n      // \"data mustache\"\r\n      dataFuncCode = self.codeGenMustache(args[0][1], args.slice(1),\r\n                                          'dataMustache');\r\n    }\r\n\r\n    return 'function () { return ' + dataFuncCode + '; }';\r\n  }\r\n\r\n});\r\n","\r\nSpacebarsCompiler.parse = function (input) {\r\n\r\n  var tree = HTMLTools.parseFragment(\r\n    input,\r\n    { getTemplateTag: TemplateTag.parseCompleteTag });\r\n\r\n  return tree;\r\n};\r\n\r\nSpacebarsCompiler.compile = function (input, options) {\r\n  var tree = SpacebarsCompiler.parse(input);\r\n  return SpacebarsCompiler.codeGen(tree, options);\r\n};\r\n\r\nSpacebarsCompiler._TemplateTagReplacer = HTML.TransformingVisitor.extend();\r\nSpacebarsCompiler._TemplateTagReplacer.def({\r\n  visitObject: function (x) {\r\n    if (x instanceof HTMLTools.TemplateTag) {\r\n\r\n      // Make sure all TemplateTags in attributes have the right\r\n      // `.position` set on them.  This is a bit of a hack\r\n      // (we shouldn't be mutating that here), but it allows\r\n      // cleaner codegen of \"synthetic\" attributes like TEXTAREA's\r\n      // \"value\", where the template tags were originally not\r\n      // in an attribute.\r\n      if (this.inAttributeValue)\r\n        x.position = HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE;\r\n\r\n      return this.codegen.codeGenTemplateTag(x);\r\n    }\r\n\r\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\r\n  },\r\n  visitAttributes: function (attrs) {\r\n    if (attrs instanceof HTMLTools.TemplateTag)\r\n      return this.codegen.codeGenTemplateTag(attrs);\r\n\r\n    // call super (e.g. for case where `attrs` is an array)\r\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\r\n  },\r\n  visitAttribute: function (name, value, tag) {\r\n    this.inAttributeValue = true;\r\n    var result = this.visit(value);\r\n    this.inAttributeValue = false;\r\n\r\n    if (result !== value) {\r\n      // some template tags must have been replaced, because otherwise\r\n      // we try to keep things `===` when transforming.  Wrap the code\r\n      // in a function as per the rules.  You can't have\r\n      // `{id: Blaze.View(...)}` as an attributes dict because the View\r\n      // would be rendered more than once; you need to wrap it in a function\r\n      // so that it's a different View each time.\r\n      return BlazeTools.EmitCode(this.codegen.codeGenBlock(result));\r\n    }\r\n    return result;\r\n  }\r\n});\r\n\r\nSpacebarsCompiler.codeGen = function (parseTree, options) {\r\n  // is this a template, rather than a block passed to\r\n  // a block helper, say\r\n  var isTemplate = (options && options.isTemplate);\r\n  var isBody = (options && options.isBody);\r\n\r\n  var tree = parseTree;\r\n\r\n  // The flags `isTemplate` and `isBody` are kind of a hack.\r\n  if (isTemplate || isBody) {\r\n    // optimizing fragments would require being smarter about whether we are\r\n    // in a TEXTAREA, say.\r\n    tree = SpacebarsCompiler.optimize(tree);\r\n  }\r\n\r\n  var codegen = new SpacebarsCompiler.CodeGen;\r\n  tree = (new SpacebarsCompiler._TemplateTagReplacer(\r\n    {codegen: codegen})).visit(tree);\r\n\r\n  var code = '(function () { ';\r\n  if (isTemplate || isBody) {\r\n    code += 'var view = this; ';\r\n  }\r\n  code += 'return ';\r\n  code += BlazeTools.toJS(tree);\r\n  code += '; })';\r\n\r\n  code = SpacebarsCompiler._beautify(code);\r\n\r\n  return code;\r\n};\r\n\r\nSpacebarsCompiler._beautify = function (code) {\r\n  if (Package.minifiers && Package.minifiers.UglifyJSMinify) {\r\n    var result = UglifyJSMinify(code,\r\n                                { fromString: true,\r\n                                  mangle: false,\r\n                                  compress: false,\r\n                                  output: { beautify: true,\r\n                                            indent_level: 2,\r\n                                            width: 80 } });\r\n    var output = result.code;\r\n    // Uglify interprets our expression as a statement and may add a semicolon.\r\n    // Strip trailing semicolon.\r\n    output = output.replace(/;$/, '');\r\n    return output;\r\n  } else {\r\n    // don't actually beautify; no UglifyJS\r\n    return code;\r\n  }\r\n};\r\n"]}